<?php
/**
 * ActionsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Configuration;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\HeaderSelector;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ObjectSerializer;

/**
 * ActionsApi Class Doc Comment
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ActionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'actionsAddCustomLabelsToSelfHostedRunnerForOrg' => [
            'application/json',
        ],
        'actionsAddCustomLabelsToSelfHostedRunnerForRepo' => [
            'application/json',
        ],
        'actionsAddRepoAccessToSelfHostedRunnerGroupInOrg' => [
            'application/json',
        ],
        'actionsAddSelectedRepoToOrgSecret' => [
            'application/json',
        ],
        'actionsAddSelectedRepoToOrgVariable' => [
            'application/json',
        ],
        'actionsAddSelfHostedRunnerToGroupForOrg' => [
            'application/json',
        ],
        'actionsCancelWorkflowRun' => [
            'application/json',
        ],
        'actionsCreateEnvironmentVariable' => [
            'application/json',
        ],
        'actionsCreateOrUpdateEnvironmentSecret' => [
            'application/json',
        ],
        'actionsCreateOrUpdateOrgSecret' => [
            'application/json',
        ],
        'actionsCreateOrUpdateRepoSecret' => [
            'application/json',
        ],
        'actionsCreateOrgVariable' => [
            'application/json',
        ],
        'actionsCreateRegistrationTokenForOrg' => [
            'application/json',
        ],
        'actionsCreateRegistrationTokenForRepo' => [
            'application/json',
        ],
        'actionsCreateRemoveTokenForOrg' => [
            'application/json',
        ],
        'actionsCreateRemoveTokenForRepo' => [
            'application/json',
        ],
        'actionsCreateRepoVariable' => [
            'application/json',
        ],
        'actionsCreateSelfHostedRunnerGroupForOrg' => [
            'application/json',
        ],
        'actionsCreateWorkflowDispatch' => [
            'application/json',
        ],
        'actionsDeleteActionsCacheById' => [
            'application/json',
        ],
        'actionsDeleteActionsCacheByKey' => [
            'application/json',
        ],
        'actionsDeleteArtifact' => [
            'application/json',
        ],
        'actionsDeleteEnvironmentSecret' => [
            'application/json',
        ],
        'actionsDeleteEnvironmentVariable' => [
            'application/json',
        ],
        'actionsDeleteOrgSecret' => [
            'application/json',
        ],
        'actionsDeleteOrgVariable' => [
            'application/json',
        ],
        'actionsDeleteRepoSecret' => [
            'application/json',
        ],
        'actionsDeleteRepoVariable' => [
            'application/json',
        ],
        'actionsDeleteSelfHostedRunnerFromOrg' => [
            'application/json',
        ],
        'actionsDeleteSelfHostedRunnerFromRepo' => [
            'application/json',
        ],
        'actionsDeleteSelfHostedRunnerGroupFromOrg' => [
            'application/json',
        ],
        'actionsDeleteWorkflowRun' => [
            'application/json',
        ],
        'actionsDeleteWorkflowRunLogs' => [
            'application/json',
        ],
        'actionsDisableSelectedRepositoryGithubActionsOrganization' => [
            'application/json',
        ],
        'actionsDisableWorkflow' => [
            'application/json',
        ],
        'actionsDownloadArtifact' => [
            'application/json',
        ],
        'actionsDownloadJobLogsForWorkflowRun' => [
            'application/json',
        ],
        'actionsDownloadWorkflowRunAttemptLogs' => [
            'application/json',
        ],
        'actionsDownloadWorkflowRunLogs' => [
            'application/json',
        ],
        'actionsEnableSelectedRepositoryGithubActionsOrganization' => [
            'application/json',
        ],
        'actionsEnableWorkflow' => [
            'application/json',
        ],
        'actionsForceCancelWorkflowRun' => [
            'application/json',
        ],
        'actionsGenerateRunnerJitconfigForEnterprise' => [
            'application/json',
        ],
        'actionsGenerateRunnerJitconfigForOrg' => [
            'application/json',
        ],
        'actionsGenerateRunnerJitconfigForRepo' => [
            'application/json',
        ],
        'actionsGetActionsCacheList' => [
            'application/json',
        ],
        'actionsGetActionsCacheUsage' => [
            'application/json',
        ],
        'actionsGetActionsCacheUsageByRepoForOrg' => [
            'application/json',
        ],
        'actionsGetActionsCacheUsageForEnterprise' => [
            'application/json',
        ],
        'actionsGetActionsCacheUsageForOrg' => [
            'application/json',
        ],
        'actionsGetActionsCacheUsagePolicy' => [
            'application/json',
        ],
        'actionsGetActionsCacheUsagePolicyForEnterprise' => [
            'application/json',
        ],
        'actionsGetAllowedActionsOrganization' => [
            'application/json',
        ],
        'actionsGetAllowedActionsRepository' => [
            'application/json',
        ],
        'actionsGetArtifact' => [
            'application/json',
        ],
        'actionsGetCustomOidcSubClaimForRepo' => [
            'application/json',
        ],
        'actionsGetEnvironmentPublicKey' => [
            'application/json',
        ],
        'actionsGetEnvironmentSecret' => [
            'application/json',
        ],
        'actionsGetEnvironmentVariable' => [
            'application/json',
        ],
        'actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise' => [
            'application/json',
        ],
        'actionsGetGithubActionsDefaultWorkflowPermissionsOrganization' => [
            'application/json',
        ],
        'actionsGetGithubActionsDefaultWorkflowPermissionsRepository' => [
            'application/json',
        ],
        'actionsGetGithubActionsPermissionsOrganization' => [
            'application/json',
        ],
        'actionsGetGithubActionsPermissionsRepository' => [
            'application/json',
        ],
        'actionsGetJobForWorkflowRun' => [
            'application/json',
        ],
        'actionsGetOrgPublicKey' => [
            'application/json',
        ],
        'actionsGetOrgSecret' => [
            'application/json',
        ],
        'actionsGetOrgVariable' => [
            'application/json',
        ],
        'actionsGetPendingDeploymentsForRun' => [
            'application/json',
        ],
        'actionsGetRepoPublicKey' => [
            'application/json',
        ],
        'actionsGetRepoSecret' => [
            'application/json',
        ],
        'actionsGetRepoVariable' => [
            'application/json',
        ],
        'actionsGetReviewsForRun' => [
            'application/json',
        ],
        'actionsGetSelfHostedRunnerForOrg' => [
            'application/json',
        ],
        'actionsGetSelfHostedRunnerForRepo' => [
            'application/json',
        ],
        'actionsGetSelfHostedRunnerGroupForOrg' => [
            'application/json',
        ],
        'actionsGetWorkflow' => [
            'application/json',
        ],
        'actionsGetWorkflowAccessToRepository' => [
            'application/json',
        ],
        'actionsGetWorkflowRun' => [
            'application/json',
        ],
        'actionsGetWorkflowRunAttempt' => [
            'application/json',
        ],
        'actionsListArtifactsForRepo' => [
            'application/json',
        ],
        'actionsListEnvironmentSecrets' => [
            'application/json',
        ],
        'actionsListEnvironmentVariables' => [
            'application/json',
        ],
        'actionsListJobsForWorkflowRun' => [
            'application/json',
        ],
        'actionsListJobsForWorkflowRunAttempt' => [
            'application/json',
        ],
        'actionsListLabelsForSelfHostedRunnerForOrg' => [
            'application/json',
        ],
        'actionsListLabelsForSelfHostedRunnerForRepo' => [
            'application/json',
        ],
        'actionsListOrgSecrets' => [
            'application/json',
        ],
        'actionsListOrgVariables' => [
            'application/json',
        ],
        'actionsListRepoAccessToSelfHostedRunnerGroupInOrg' => [
            'application/json',
        ],
        'actionsListRepoOrganizationSecrets' => [
            'application/json',
        ],
        'actionsListRepoOrganizationVariables' => [
            'application/json',
        ],
        'actionsListRepoSecrets' => [
            'application/json',
        ],
        'actionsListRepoVariables' => [
            'application/json',
        ],
        'actionsListRepoWorkflows' => [
            'application/json',
        ],
        'actionsListRunnerApplicationsForOrg' => [
            'application/json',
        ],
        'actionsListRunnerApplicationsForRepo' => [
            'application/json',
        ],
        'actionsListSelectedReposForOrgSecret' => [
            'application/json',
        ],
        'actionsListSelectedReposForOrgVariable' => [
            'application/json',
        ],
        'actionsListSelectedRepositoriesEnabledGithubActionsOrganization' => [
            'application/json',
        ],
        'actionsListSelfHostedRunnerGroupsForOrg' => [
            'application/json',
        ],
        'actionsListSelfHostedRunnersForOrg' => [
            'application/json',
        ],
        'actionsListSelfHostedRunnersForRepo' => [
            'application/json',
        ],
        'actionsListSelfHostedRunnersInGroupForOrg' => [
            'application/json',
        ],
        'actionsListWorkflowRunArtifacts' => [
            'application/json',
        ],
        'actionsListWorkflowRuns' => [
            'application/json',
        ],
        'actionsListWorkflowRunsForRepo' => [
            'application/json',
        ],
        'actionsReRunJobForWorkflowRun' => [
            'application/json',
        ],
        'actionsReRunWorkflow' => [
            'application/json',
        ],
        'actionsReRunWorkflowFailedJobs' => [
            'application/json',
        ],
        'actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg' => [
            'application/json',
        ],
        'actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo' => [
            'application/json',
        ],
        'actionsRemoveCustomLabelFromSelfHostedRunnerForOrg' => [
            'application/json',
        ],
        'actionsRemoveCustomLabelFromSelfHostedRunnerForRepo' => [
            'application/json',
        ],
        'actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg' => [
            'application/json',
        ],
        'actionsRemoveSelectedRepoFromOrgSecret' => [
            'application/json',
        ],
        'actionsRemoveSelectedRepoFromOrgVariable' => [
            'application/json',
        ],
        'actionsRemoveSelfHostedRunnerFromGroupForOrg' => [
            'application/json',
        ],
        'actionsReviewCustomGatesForRun' => [
            'application/json',
        ],
        'actionsReviewPendingDeploymentsForRun' => [
            'application/json',
        ],
        'actionsSetActionsCacheUsagePolicy' => [
            'application/json',
        ],
        'actionsSetActionsCacheUsagePolicyForEnterprise' => [
            'application/json',
        ],
        'actionsSetAllowedActionsOrganization' => [
            'application/json',
        ],
        'actionsSetAllowedActionsRepository' => [
            'application/json',
        ],
        'actionsSetCustomLabelsForSelfHostedRunnerForOrg' => [
            'application/json',
        ],
        'actionsSetCustomLabelsForSelfHostedRunnerForRepo' => [
            'application/json',
        ],
        'actionsSetCustomOidcSubClaimForRepo' => [
            'application/json',
        ],
        'actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise' => [
            'application/json',
        ],
        'actionsSetGithubActionsDefaultWorkflowPermissionsOrganization' => [
            'application/json',
        ],
        'actionsSetGithubActionsDefaultWorkflowPermissionsRepository' => [
            'application/json',
        ],
        'actionsSetGithubActionsPermissionsOrganization' => [
            'application/json',
        ],
        'actionsSetGithubActionsPermissionsRepository' => [
            'application/json',
        ],
        'actionsSetRepoAccessToSelfHostedRunnerGroupInOrg' => [
            'application/json',
        ],
        'actionsSetSelectedReposForOrgSecret' => [
            'application/json',
        ],
        'actionsSetSelectedReposForOrgVariable' => [
            'application/json',
        ],
        'actionsSetSelectedRepositoriesEnabledGithubActionsOrganization' => [
            'application/json',
        ],
        'actionsSetSelfHostedRunnersInGroupForOrg' => [
            'application/json',
        ],
        'actionsSetWorkflowAccessToRepository' => [
            'application/json',
        ],
        'actionsUpdateEnvironmentVariable' => [
            'application/json',
        ],
        'actionsUpdateOrgVariable' => [
            'application/json',
        ],
        'actionsUpdateRepoVariable' => [
            'application/json',
        ],
        'actionsUpdateSelfHostedRunnerGroupForOrg' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForOrg
     *
     * Add custom labels to a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForOrg($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'][0])
    {
        list($response) = $this->actionsAddCustomLabelsToSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForOrgWithHttpInfo
     *
     * Add custom labels to a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'][0])
    {
        $request = $this->actionsAddCustomLabelsToSelfHostedRunnerForOrgRequest($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForOrgAsync
     *
     * Add custom labels to a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForOrgAsync($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'][0])
    {
        return $this->actionsAddCustomLabelsToSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForOrgAsyncWithHttpInfo
     *
     * Add custom labels to a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsAddCustomLabelsToSelfHostedRunnerForOrgRequest($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsAddCustomLabelsToSelfHostedRunnerForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForOrgRequest($org, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsAddCustomLabelsToSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsAddCustomLabelsToSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request' is set
        if ($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request === null || (is_array($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request) && count($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request when calling actionsAddCustomLabelsToSelfHostedRunnerForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForRepo
     *
     * Add custom labels to a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForRepo($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'][0])
    {
        list($response) = $this->actionsAddCustomLabelsToSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForRepoWithHttpInfo
     *
     * Add custom labels to a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'][0])
    {
        $request = $this->actionsAddCustomLabelsToSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForRepoAsync
     *
     * Add custom labels to a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForRepoAsync($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'][0])
    {
        return $this->actionsAddCustomLabelsToSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsAddCustomLabelsToSelfHostedRunnerForRepoAsyncWithHttpInfo
     *
     * Add custom labels to a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsAddCustomLabelsToSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsAddCustomLabelsToSelfHostedRunnerForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsAddCustomLabelsToSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsAddCustomLabelsToSelfHostedRunnerForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsAddCustomLabelsToSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsAddCustomLabelsToSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsAddCustomLabelsToSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request' is set
        if ($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request === null || (is_array($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request) && count($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request when calling actionsAddCustomLabelsToSelfHostedRunnerForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsAddRepoAccessToSelfHostedRunnerGroupInOrg
     *
     * Add repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsAddRepoAccessToSelfHostedRunnerGroupInOrg($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $this->actionsAddRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $repository_id, $contentType);
    }

    /**
     * Operation actionsAddRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo
     *
     * Add repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsAddRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $request = $this->actionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsAddRepoAccessToSelfHostedRunnerGroupInOrgAsync
     *
     * Add repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddRepoAccessToSelfHostedRunnerGroupInOrgAsync($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        return $this->actionsAddRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsAddRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo
     *
     * Add repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsAddRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsAddRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsAddSelectedRepoToOrgSecret
     *
     * Add selected repository to an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsAddSelectedRepoToOrgSecret($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgSecret'][0])
    {
        $this->actionsAddSelectedRepoToOrgSecretWithHttpInfo($org, $secret_name, $repository_id, $contentType);
    }

    /**
     * Operation actionsAddSelectedRepoToOrgSecretWithHttpInfo
     *
     * Add selected repository to an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsAddSelectedRepoToOrgSecretWithHttpInfo($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgSecret'][0])
    {
        $request = $this->actionsAddSelectedRepoToOrgSecretRequest($org, $secret_name, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsAddSelectedRepoToOrgSecretAsync
     *
     * Add selected repository to an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddSelectedRepoToOrgSecretAsync($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgSecret'][0])
    {
        return $this->actionsAddSelectedRepoToOrgSecretAsyncWithHttpInfo($org, $secret_name, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsAddSelectedRepoToOrgSecretAsyncWithHttpInfo
     *
     * Add selected repository to an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddSelectedRepoToOrgSecretAsyncWithHttpInfo($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgSecret'][0])
    {
        $returnType = '';
        $request = $this->actionsAddSelectedRepoToOrgSecretRequest($org, $secret_name, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsAddSelectedRepoToOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsAddSelectedRepoToOrgSecretRequest($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsAddSelectedRepoToOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsAddSelectedRepoToOrgSecret'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsAddSelectedRepoToOrgSecret'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsAddSelectedRepoToOrgVariable
     *
     * Add selected repository to an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsAddSelectedRepoToOrgVariable($org, $name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgVariable'][0])
    {
        $this->actionsAddSelectedRepoToOrgVariableWithHttpInfo($org, $name, $repository_id, $contentType);
    }

    /**
     * Operation actionsAddSelectedRepoToOrgVariableWithHttpInfo
     *
     * Add selected repository to an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsAddSelectedRepoToOrgVariableWithHttpInfo($org, $name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgVariable'][0])
    {
        $request = $this->actionsAddSelectedRepoToOrgVariableRequest($org, $name, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsAddSelectedRepoToOrgVariableAsync
     *
     * Add selected repository to an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddSelectedRepoToOrgVariableAsync($org, $name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgVariable'][0])
    {
        return $this->actionsAddSelectedRepoToOrgVariableAsyncWithHttpInfo($org, $name, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsAddSelectedRepoToOrgVariableAsyncWithHttpInfo
     *
     * Add selected repository to an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddSelectedRepoToOrgVariableAsyncWithHttpInfo($org, $name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsAddSelectedRepoToOrgVariableRequest($org, $name, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsAddSelectedRepoToOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelectedRepoToOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsAddSelectedRepoToOrgVariableRequest($org, $name, $repository_id, string $contentType = self::contentTypes['actionsAddSelectedRepoToOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsAddSelectedRepoToOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsAddSelectedRepoToOrgVariable'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsAddSelectedRepoToOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables/{name}/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsAddSelfHostedRunnerToGroupForOrg
     *
     * Add a self-hosted runner to a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsAddSelfHostedRunnerToGroupForOrg($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'][0])
    {
        $this->actionsAddSelfHostedRunnerToGroupForOrgWithHttpInfo($org, $runner_group_id, $runner_id, $contentType);
    }

    /**
     * Operation actionsAddSelfHostedRunnerToGroupForOrgWithHttpInfo
     *
     * Add a self-hosted runner to a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsAddSelfHostedRunnerToGroupForOrgWithHttpInfo($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'][0])
    {
        $request = $this->actionsAddSelfHostedRunnerToGroupForOrgRequest($org, $runner_group_id, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsAddSelfHostedRunnerToGroupForOrgAsync
     *
     * Add a self-hosted runner to a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddSelfHostedRunnerToGroupForOrgAsync($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'][0])
    {
        return $this->actionsAddSelfHostedRunnerToGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsAddSelfHostedRunnerToGroupForOrgAsyncWithHttpInfo
     *
     * Add a self-hosted runner to a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsAddSelfHostedRunnerToGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsAddSelfHostedRunnerToGroupForOrgRequest($org, $runner_group_id, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsAddSelfHostedRunnerToGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsAddSelfHostedRunnerToGroupForOrgRequest($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsAddSelfHostedRunnerToGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsAddSelfHostedRunnerToGroupForOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsAddSelfHostedRunnerToGroupForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsAddSelfHostedRunnerToGroupForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCancelWorkflowRun
     *
     * Cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsCancelWorkflowRun($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsCancelWorkflowRun'][0])
    {
        list($response) = $this->actionsCancelWorkflowRunWithHttpInfo($owner, $repo, $run_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsCancelWorkflowRunWithHttpInfo
     *
     * Cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCancelWorkflowRunWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsCancelWorkflowRun'][0])
    {
        $request = $this->actionsCancelWorkflowRunRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCancelWorkflowRunAsync
     *
     * Cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCancelWorkflowRunAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsCancelWorkflowRun'][0])
    {
        return $this->actionsCancelWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCancelWorkflowRunAsyncWithHttpInfo
     *
     * Cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCancelWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsCancelWorkflowRun'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCancelWorkflowRunRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCancelWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCancelWorkflowRunRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsCancelWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCancelWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCancelWorkflowRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsCancelWorkflowRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateEnvironmentVariable
     *
     * Create an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsCreateEnvironmentVariable($owner, $repo, $environment_name, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateEnvironmentVariable'][0])
    {
        list($response) = $this->actionsCreateEnvironmentVariableWithHttpInfo($owner, $repo, $environment_name, $actions_create_repo_variable_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateEnvironmentVariableWithHttpInfo
     *
     * Create an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateEnvironmentVariableWithHttpInfo($owner, $repo, $environment_name, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateEnvironmentVariable'][0])
    {
        $request = $this->actionsCreateEnvironmentVariableRequest($owner, $repo, $environment_name, $actions_create_repo_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateEnvironmentVariableAsync
     *
     * Create an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateEnvironmentVariableAsync($owner, $repo, $environment_name, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateEnvironmentVariable'][0])
    {
        return $this->actionsCreateEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $environment_name, $actions_create_repo_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateEnvironmentVariableAsyncWithHttpInfo
     *
     * Create an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $environment_name, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateEnvironmentVariable'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCreateEnvironmentVariableRequest($owner, $repo, $environment_name, $actions_create_repo_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateEnvironmentVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateEnvironmentVariableRequest($owner, $repo, $environment_name, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateEnvironmentVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateEnvironmentVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateEnvironmentVariable'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsCreateEnvironmentVariable'
            );
        }

        // verify the required parameter 'actions_create_repo_variable_request' is set
        if ($actions_create_repo_variable_request === null || (is_array($actions_create_repo_variable_request) && count($actions_create_repo_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_repo_variable_request when calling actionsCreateEnvironmentVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_repo_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_repo_variable_request));
            } else {
                $httpBody = $actions_create_repo_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateOrUpdateEnvironmentSecret
     *
     * Create or update an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateEnvironmentSecretRequest $actions_create_or_update_environment_secret_request actions_create_or_update_environment_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsCreateOrUpdateEnvironmentSecret($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'][0])
    {
        list($response) = $this->actionsCreateOrUpdateEnvironmentSecretWithHttpInfo($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateOrUpdateEnvironmentSecretWithHttpInfo
     *
     * Create or update an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateEnvironmentSecretRequest $actions_create_or_update_environment_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateOrUpdateEnvironmentSecretWithHttpInfo($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'][0])
    {
        $request = $this->actionsCreateOrUpdateEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateOrUpdateEnvironmentSecretAsync
     *
     * Create or update an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateEnvironmentSecretRequest $actions_create_or_update_environment_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrUpdateEnvironmentSecretAsync($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'][0])
    {
        return $this->actionsCreateOrUpdateEnvironmentSecretAsyncWithHttpInfo($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateOrUpdateEnvironmentSecretAsyncWithHttpInfo
     *
     * Create or update an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateEnvironmentSecretRequest $actions_create_or_update_environment_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrUpdateEnvironmentSecretAsyncWithHttpInfo($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCreateOrUpdateEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateOrUpdateEnvironmentSecret'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateEnvironmentSecretRequest $actions_create_or_update_environment_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateOrUpdateEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $actions_create_or_update_environment_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateEnvironmentSecret'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateOrUpdateEnvironmentSecret'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateOrUpdateEnvironmentSecret'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsCreateOrUpdateEnvironmentSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsCreateOrUpdateEnvironmentSecret'
            );
        }

        // verify the required parameter 'actions_create_or_update_environment_secret_request' is set
        if ($actions_create_or_update_environment_secret_request === null || (is_array($actions_create_or_update_environment_secret_request) && count($actions_create_or_update_environment_secret_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_or_update_environment_secret_request when calling actionsCreateOrUpdateEnvironmentSecret'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_or_update_environment_secret_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_or_update_environment_secret_request));
            } else {
                $httpBody = $actions_create_or_update_environment_secret_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateOrUpdateOrgSecret
     *
     * Create or update an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateOrgSecretRequest $actions_create_or_update_org_secret_request actions_create_or_update_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsCreateOrUpdateOrgSecret($org, $secret_name, $actions_create_or_update_org_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateOrgSecret'][0])
    {
        list($response) = $this->actionsCreateOrUpdateOrgSecretWithHttpInfo($org, $secret_name, $actions_create_or_update_org_secret_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateOrUpdateOrgSecretWithHttpInfo
     *
     * Create or update an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateOrgSecretRequest $actions_create_or_update_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateOrUpdateOrgSecretWithHttpInfo($org, $secret_name, $actions_create_or_update_org_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateOrgSecret'][0])
    {
        $request = $this->actionsCreateOrUpdateOrgSecretRequest($org, $secret_name, $actions_create_or_update_org_secret_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateOrUpdateOrgSecretAsync
     *
     * Create or update an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateOrgSecretRequest $actions_create_or_update_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrUpdateOrgSecretAsync($org, $secret_name, $actions_create_or_update_org_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateOrgSecret'][0])
    {
        return $this->actionsCreateOrUpdateOrgSecretAsyncWithHttpInfo($org, $secret_name, $actions_create_or_update_org_secret_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateOrUpdateOrgSecretAsyncWithHttpInfo
     *
     * Create or update an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateOrgSecretRequest $actions_create_or_update_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrUpdateOrgSecretAsyncWithHttpInfo($org, $secret_name, $actions_create_or_update_org_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateOrgSecret'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCreateOrUpdateOrgSecretRequest($org, $secret_name, $actions_create_or_update_org_secret_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateOrUpdateOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateOrgSecretRequest $actions_create_or_update_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateOrUpdateOrgSecretRequest($org, $secret_name, $actions_create_or_update_org_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsCreateOrUpdateOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsCreateOrUpdateOrgSecret'
            );
        }

        // verify the required parameter 'actions_create_or_update_org_secret_request' is set
        if ($actions_create_or_update_org_secret_request === null || (is_array($actions_create_or_update_org_secret_request) && count($actions_create_or_update_org_secret_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_or_update_org_secret_request when calling actionsCreateOrUpdateOrgSecret'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_or_update_org_secret_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_or_update_org_secret_request));
            } else {
                $httpBody = $actions_create_or_update_org_secret_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateOrUpdateRepoSecret
     *
     * Create or update a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateRepoSecretRequest $actions_create_or_update_repo_secret_request actions_create_or_update_repo_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateRepoSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsCreateOrUpdateRepoSecret($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateRepoSecret'][0])
    {
        list($response) = $this->actionsCreateOrUpdateRepoSecretWithHttpInfo($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateOrUpdateRepoSecretWithHttpInfo
     *
     * Create or update a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateRepoSecretRequest $actions_create_or_update_repo_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateRepoSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateOrUpdateRepoSecretWithHttpInfo($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateRepoSecret'][0])
    {
        $request = $this->actionsCreateOrUpdateRepoSecretRequest($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateOrUpdateRepoSecretAsync
     *
     * Create or update a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateRepoSecretRequest $actions_create_or_update_repo_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrUpdateRepoSecretAsync($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateRepoSecret'][0])
    {
        return $this->actionsCreateOrUpdateRepoSecretAsyncWithHttpInfo($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateOrUpdateRepoSecretAsyncWithHttpInfo
     *
     * Create or update a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateRepoSecretRequest $actions_create_or_update_repo_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrUpdateRepoSecretAsyncWithHttpInfo($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateRepoSecret'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCreateOrUpdateRepoSecretRequest($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateOrUpdateRepoSecret'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrUpdateRepoSecretRequest $actions_create_or_update_repo_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrUpdateRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateOrUpdateRepoSecretRequest($owner, $repo, $secret_name, $actions_create_or_update_repo_secret_request, string $contentType = self::contentTypes['actionsCreateOrUpdateRepoSecret'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateOrUpdateRepoSecret'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateOrUpdateRepoSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsCreateOrUpdateRepoSecret'
            );
        }

        // verify the required parameter 'actions_create_or_update_repo_secret_request' is set
        if ($actions_create_or_update_repo_secret_request === null || (is_array($actions_create_or_update_repo_secret_request) && count($actions_create_or_update_repo_secret_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_or_update_repo_secret_request when calling actionsCreateOrUpdateRepoSecret'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_or_update_repo_secret_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_or_update_repo_secret_request));
            } else {
                $httpBody = $actions_create_or_update_repo_secret_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateOrgVariable
     *
     * Create an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrgVariableRequest $actions_create_org_variable_request actions_create_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsCreateOrgVariable($org, $actions_create_org_variable_request, string $contentType = self::contentTypes['actionsCreateOrgVariable'][0])
    {
        list($response) = $this->actionsCreateOrgVariableWithHttpInfo($org, $actions_create_org_variable_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateOrgVariableWithHttpInfo
     *
     * Create an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrgVariableRequest $actions_create_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateOrgVariableWithHttpInfo($org, $actions_create_org_variable_request, string $contentType = self::contentTypes['actionsCreateOrgVariable'][0])
    {
        $request = $this->actionsCreateOrgVariableRequest($org, $actions_create_org_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateOrgVariableAsync
     *
     * Create an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrgVariableRequest $actions_create_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrgVariableAsync($org, $actions_create_org_variable_request, string $contentType = self::contentTypes['actionsCreateOrgVariable'][0])
    {
        return $this->actionsCreateOrgVariableAsyncWithHttpInfo($org, $actions_create_org_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateOrgVariableAsyncWithHttpInfo
     *
     * Create an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrgVariableRequest $actions_create_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateOrgVariableAsyncWithHttpInfo($org, $actions_create_org_variable_request, string $contentType = self::contentTypes['actionsCreateOrgVariable'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCreateOrgVariableRequest($org, $actions_create_org_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateOrgVariableRequest $actions_create_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateOrgVariableRequest($org, $actions_create_org_variable_request, string $contentType = self::contentTypes['actionsCreateOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsCreateOrgVariable'
            );
        }

        // verify the required parameter 'actions_create_org_variable_request' is set
        if ($actions_create_org_variable_request === null || (is_array($actions_create_org_variable_request) && count($actions_create_org_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_org_variable_request when calling actionsCreateOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_org_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_org_variable_request));
            } else {
                $httpBody = $actions_create_org_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateRegistrationTokenForOrg
     *
     * Create a registration token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken
     */
    public function actionsCreateRegistrationTokenForOrg($org, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForOrg'][0])
    {
        list($response) = $this->actionsCreateRegistrationTokenForOrgWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateRegistrationTokenForOrgWithHttpInfo
     *
     * Create a registration token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateRegistrationTokenForOrgWithHttpInfo($org, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForOrg'][0])
    {
        $request = $this->actionsCreateRegistrationTokenForOrgRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateRegistrationTokenForOrgAsync
     *
     * Create a registration token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRegistrationTokenForOrgAsync($org, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForOrg'][0])
    {
        return $this->actionsCreateRegistrationTokenForOrgAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateRegistrationTokenForOrgAsyncWithHttpInfo
     *
     * Create a registration token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRegistrationTokenForOrgAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
        $request = $this->actionsCreateRegistrationTokenForOrgRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateRegistrationTokenForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateRegistrationTokenForOrgRequest($org, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsCreateRegistrationTokenForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/registration-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateRegistrationTokenForRepo
     *
     * Create a registration token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken
     */
    public function actionsCreateRegistrationTokenForRepo($owner, $repo, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForRepo'][0])
    {
        list($response) = $this->actionsCreateRegistrationTokenForRepoWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateRegistrationTokenForRepoWithHttpInfo
     *
     * Create a registration token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateRegistrationTokenForRepoWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForRepo'][0])
    {
        $request = $this->actionsCreateRegistrationTokenForRepoRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateRegistrationTokenForRepoAsync
     *
     * Create a registration token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRegistrationTokenForRepoAsync($owner, $repo, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForRepo'][0])
    {
        return $this->actionsCreateRegistrationTokenForRepoAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateRegistrationTokenForRepoAsyncWithHttpInfo
     *
     * Create a registration token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRegistrationTokenForRepoAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
        $request = $this->actionsCreateRegistrationTokenForRepoRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateRegistrationTokenForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRegistrationTokenForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateRegistrationTokenForRepoRequest($owner, $repo, string $contentType = self::contentTypes['actionsCreateRegistrationTokenForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateRegistrationTokenForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateRegistrationTokenForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/registration-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateRemoveTokenForOrg
     *
     * Create a remove token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken
     */
    public function actionsCreateRemoveTokenForOrg($org, string $contentType = self::contentTypes['actionsCreateRemoveTokenForOrg'][0])
    {
        list($response) = $this->actionsCreateRemoveTokenForOrgWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateRemoveTokenForOrgWithHttpInfo
     *
     * Create a remove token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateRemoveTokenForOrgWithHttpInfo($org, string $contentType = self::contentTypes['actionsCreateRemoveTokenForOrg'][0])
    {
        $request = $this->actionsCreateRemoveTokenForOrgRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateRemoveTokenForOrgAsync
     *
     * Create a remove token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRemoveTokenForOrgAsync($org, string $contentType = self::contentTypes['actionsCreateRemoveTokenForOrg'][0])
    {
        return $this->actionsCreateRemoveTokenForOrgAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateRemoveTokenForOrgAsyncWithHttpInfo
     *
     * Create a remove token for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRemoveTokenForOrgAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsCreateRemoveTokenForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
        $request = $this->actionsCreateRemoveTokenForOrgRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateRemoveTokenForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateRemoveTokenForOrgRequest($org, string $contentType = self::contentTypes['actionsCreateRemoveTokenForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsCreateRemoveTokenForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/remove-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateRemoveTokenForRepo
     *
     * Create a remove token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken
     */
    public function actionsCreateRemoveTokenForRepo($owner, $repo, string $contentType = self::contentTypes['actionsCreateRemoveTokenForRepo'][0])
    {
        list($response) = $this->actionsCreateRemoveTokenForRepoWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateRemoveTokenForRepoWithHttpInfo
     *
     * Create a remove token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateRemoveTokenForRepoWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsCreateRemoveTokenForRepo'][0])
    {
        $request = $this->actionsCreateRemoveTokenForRepoRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateRemoveTokenForRepoAsync
     *
     * Create a remove token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRemoveTokenForRepoAsync($owner, $repo, string $contentType = self::contentTypes['actionsCreateRemoveTokenForRepo'][0])
    {
        return $this->actionsCreateRemoveTokenForRepoAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateRemoveTokenForRepoAsyncWithHttpInfo
     *
     * Create a remove token for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRemoveTokenForRepoAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsCreateRemoveTokenForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
        $request = $this->actionsCreateRemoveTokenForRepoRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateRemoveTokenForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRemoveTokenForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateRemoveTokenForRepoRequest($owner, $repo, string $contentType = self::contentTypes['actionsCreateRemoveTokenForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateRemoveTokenForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateRemoveTokenForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/remove-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateRepoVariable
     *
     * Create a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsCreateRepoVariable($owner, $repo, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateRepoVariable'][0])
    {
        list($response) = $this->actionsCreateRepoVariableWithHttpInfo($owner, $repo, $actions_create_repo_variable_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateRepoVariableWithHttpInfo
     *
     * Create a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateRepoVariableWithHttpInfo($owner, $repo, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateRepoVariable'][0])
    {
        $request = $this->actionsCreateRepoVariableRequest($owner, $repo, $actions_create_repo_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateRepoVariableAsync
     *
     * Create a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRepoVariableAsync($owner, $repo, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateRepoVariable'][0])
    {
        return $this->actionsCreateRepoVariableAsyncWithHttpInfo($owner, $repo, $actions_create_repo_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateRepoVariableAsyncWithHttpInfo
     *
     * Create a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateRepoVariableAsyncWithHttpInfo($owner, $repo, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateRepoVariable'][0])
    {
        $returnType = 'object';
        $request = $this->actionsCreateRepoVariableRequest($owner, $repo, $actions_create_repo_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateRepoVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateRepoVariableRequest $actions_create_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateRepoVariableRequest($owner, $repo, $actions_create_repo_variable_request, string $contentType = self::contentTypes['actionsCreateRepoVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateRepoVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateRepoVariable'
            );
        }

        // verify the required parameter 'actions_create_repo_variable_request' is set
        if ($actions_create_repo_variable_request === null || (is_array($actions_create_repo_variable_request) && count($actions_create_repo_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_repo_variable_request when calling actionsCreateRepoVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_repo_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_repo_variable_request));
            } else {
                $httpBody = $actions_create_repo_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateSelfHostedRunnerGroupForOrg
     *
     * Create a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateSelfHostedRunnerGroupForOrgRequest $actions_create_self_hosted_runner_group_for_org_request actions_create_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg
     */
    public function actionsCreateSelfHostedRunnerGroupForOrg($org, $actions_create_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'][0])
    {
        list($response) = $this->actionsCreateSelfHostedRunnerGroupForOrgWithHttpInfo($org, $actions_create_self_hosted_runner_group_for_org_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsCreateSelfHostedRunnerGroupForOrgWithHttpInfo
     *
     * Create a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateSelfHostedRunnerGroupForOrgRequest $actions_create_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateSelfHostedRunnerGroupForOrgWithHttpInfo($org, $actions_create_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'][0])
    {
        $request = $this->actionsCreateSelfHostedRunnerGroupForOrgRequest($org, $actions_create_self_hosted_runner_group_for_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateSelfHostedRunnerGroupForOrgAsync
     *
     * Create a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateSelfHostedRunnerGroupForOrgRequest $actions_create_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateSelfHostedRunnerGroupForOrgAsync($org, $actions_create_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'][0])
    {
        return $this->actionsCreateSelfHostedRunnerGroupForOrgAsyncWithHttpInfo($org, $actions_create_self_hosted_runner_group_for_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateSelfHostedRunnerGroupForOrgAsyncWithHttpInfo
     *
     * Create a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateSelfHostedRunnerGroupForOrgRequest $actions_create_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateSelfHostedRunnerGroupForOrgAsyncWithHttpInfo($org, $actions_create_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg';
        $request = $this->actionsCreateSelfHostedRunnerGroupForOrgRequest($org, $actions_create_self_hosted_runner_group_for_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateSelfHostedRunnerGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateSelfHostedRunnerGroupForOrgRequest $actions_create_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateSelfHostedRunnerGroupForOrgRequest($org, $actions_create_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsCreateSelfHostedRunnerGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsCreateSelfHostedRunnerGroupForOrg'
            );
        }

        // verify the required parameter 'actions_create_self_hosted_runner_group_for_org_request' is set
        if ($actions_create_self_hosted_runner_group_for_org_request === null || (is_array($actions_create_self_hosted_runner_group_for_org_request) && count($actions_create_self_hosted_runner_group_for_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_self_hosted_runner_group_for_org_request when calling actionsCreateSelfHostedRunnerGroupForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_self_hosted_runner_group_for_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_self_hosted_runner_group_for_org_request));
            } else {
                $httpBody = $actions_create_self_hosted_runner_group_for_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsCreateWorkflowDispatch
     *
     * Create a workflow dispatch event
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateWorkflowDispatchRequest $actions_create_workflow_dispatch_request actions_create_workflow_dispatch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateWorkflowDispatch'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsCreateWorkflowDispatch($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, string $contentType = self::contentTypes['actionsCreateWorkflowDispatch'][0])
    {
        $this->actionsCreateWorkflowDispatchWithHttpInfo($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, $contentType);
    }

    /**
     * Operation actionsCreateWorkflowDispatchWithHttpInfo
     *
     * Create a workflow dispatch event
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateWorkflowDispatchRequest $actions_create_workflow_dispatch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateWorkflowDispatch'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsCreateWorkflowDispatchWithHttpInfo($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, string $contentType = self::contentTypes['actionsCreateWorkflowDispatch'][0])
    {
        $request = $this->actionsCreateWorkflowDispatchRequest($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsCreateWorkflowDispatchAsync
     *
     * Create a workflow dispatch event
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateWorkflowDispatchRequest $actions_create_workflow_dispatch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateWorkflowDispatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateWorkflowDispatchAsync($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, string $contentType = self::contentTypes['actionsCreateWorkflowDispatch'][0])
    {
        return $this->actionsCreateWorkflowDispatchAsyncWithHttpInfo($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsCreateWorkflowDispatchAsyncWithHttpInfo
     *
     * Create a workflow dispatch event
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateWorkflowDispatchRequest $actions_create_workflow_dispatch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateWorkflowDispatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsCreateWorkflowDispatchAsyncWithHttpInfo($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, string $contentType = self::contentTypes['actionsCreateWorkflowDispatch'][0])
    {
        $returnType = '';
        $request = $this->actionsCreateWorkflowDispatchRequest($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsCreateWorkflowDispatch'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCreateWorkflowDispatchRequest $actions_create_workflow_dispatch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsCreateWorkflowDispatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsCreateWorkflowDispatchRequest($owner, $repo, $workflow_id, $actions_create_workflow_dispatch_request, string $contentType = self::contentTypes['actionsCreateWorkflowDispatch'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsCreateWorkflowDispatch'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsCreateWorkflowDispatch'
            );
        }

        // verify the required parameter 'workflow_id' is set
        if ($workflow_id === null || (is_array($workflow_id) && count($workflow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workflow_id when calling actionsCreateWorkflowDispatch'
            );
        }

        // verify the required parameter 'actions_create_workflow_dispatch_request' is set
        if ($actions_create_workflow_dispatch_request === null || (is_array($actions_create_workflow_dispatch_request) && count($actions_create_workflow_dispatch_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_create_workflow_dispatch_request when calling actionsCreateWorkflowDispatch'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($workflow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow_id' . '}',
                ObjectSerializer::toPathValue($workflow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_create_workflow_dispatch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_create_workflow_dispatch_request));
            } else {
                $httpBody = $actions_create_workflow_dispatch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteActionsCacheById
     *
     * Delete a GitHub Actions cache for a repository (using a cache ID)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $cache_id The unique identifier of the GitHub Actions cache. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheById'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteActionsCacheById($owner, $repo, $cache_id, string $contentType = self::contentTypes['actionsDeleteActionsCacheById'][0])
    {
        $this->actionsDeleteActionsCacheByIdWithHttpInfo($owner, $repo, $cache_id, $contentType);
    }

    /**
     * Operation actionsDeleteActionsCacheByIdWithHttpInfo
     *
     * Delete a GitHub Actions cache for a repository (using a cache ID)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $cache_id The unique identifier of the GitHub Actions cache. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheById'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteActionsCacheByIdWithHttpInfo($owner, $repo, $cache_id, string $contentType = self::contentTypes['actionsDeleteActionsCacheById'][0])
    {
        $request = $this->actionsDeleteActionsCacheByIdRequest($owner, $repo, $cache_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteActionsCacheByIdAsync
     *
     * Delete a GitHub Actions cache for a repository (using a cache ID)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $cache_id The unique identifier of the GitHub Actions cache. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteActionsCacheByIdAsync($owner, $repo, $cache_id, string $contentType = self::contentTypes['actionsDeleteActionsCacheById'][0])
    {
        return $this->actionsDeleteActionsCacheByIdAsyncWithHttpInfo($owner, $repo, $cache_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteActionsCacheByIdAsyncWithHttpInfo
     *
     * Delete a GitHub Actions cache for a repository (using a cache ID)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $cache_id The unique identifier of the GitHub Actions cache. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteActionsCacheByIdAsyncWithHttpInfo($owner, $repo, $cache_id, string $contentType = self::contentTypes['actionsDeleteActionsCacheById'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteActionsCacheByIdRequest($owner, $repo, $cache_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteActionsCacheById'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $cache_id The unique identifier of the GitHub Actions cache. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteActionsCacheByIdRequest($owner, $repo, $cache_id, string $contentType = self::contentTypes['actionsDeleteActionsCacheById'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteActionsCacheById'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteActionsCacheById'
            );
        }

        // verify the required parameter 'cache_id' is set
        if ($cache_id === null || (is_array($cache_id) && count($cache_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cache_id when calling actionsDeleteActionsCacheById'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/caches/{cache_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($cache_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cache_id' . '}',
                ObjectSerializer::toPathValue($cache_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteActionsCacheByKey
     *
     * Delete GitHub Actions caches for a repository (using a cache key)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $key A key for identifying the cache. (required)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheByKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList
     */
    public function actionsDeleteActionsCacheByKey($owner, $repo, $key, $ref = null, string $contentType = self::contentTypes['actionsDeleteActionsCacheByKey'][0])
    {
        list($response) = $this->actionsDeleteActionsCacheByKeyWithHttpInfo($owner, $repo, $key, $ref, $contentType);
        return $response;
    }

    /**
     * Operation actionsDeleteActionsCacheByKeyWithHttpInfo
     *
     * Delete GitHub Actions caches for a repository (using a cache key)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $key A key for identifying the cache. (required)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheByKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteActionsCacheByKeyWithHttpInfo($owner, $repo, $key, $ref = null, string $contentType = self::contentTypes['actionsDeleteActionsCacheByKey'][0])
    {
        $request = $this->actionsDeleteActionsCacheByKeyRequest($owner, $repo, $key, $ref, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteActionsCacheByKeyAsync
     *
     * Delete GitHub Actions caches for a repository (using a cache key)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $key A key for identifying the cache. (required)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheByKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteActionsCacheByKeyAsync($owner, $repo, $key, $ref = null, string $contentType = self::contentTypes['actionsDeleteActionsCacheByKey'][0])
    {
        return $this->actionsDeleteActionsCacheByKeyAsyncWithHttpInfo($owner, $repo, $key, $ref, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteActionsCacheByKeyAsyncWithHttpInfo
     *
     * Delete GitHub Actions caches for a repository (using a cache key)
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $key A key for identifying the cache. (required)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheByKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteActionsCacheByKeyAsyncWithHttpInfo($owner, $repo, $key, $ref = null, string $contentType = self::contentTypes['actionsDeleteActionsCacheByKey'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList';
        $request = $this->actionsDeleteActionsCacheByKeyRequest($owner, $repo, $key, $ref, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteActionsCacheByKey'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $key A key for identifying the cache. (required)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteActionsCacheByKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteActionsCacheByKeyRequest($owner, $repo, $key, $ref = null, string $contentType = self::contentTypes['actionsDeleteActionsCacheByKey'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteActionsCacheByKey'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteActionsCacheByKey'
            );
        }

        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling actionsDeleteActionsCacheByKey'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/caches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key,
            'key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ref,
            'ref', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteArtifact
     *
     * Delete an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteArtifact'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteArtifact($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsDeleteArtifact'][0])
    {
        $this->actionsDeleteArtifactWithHttpInfo($owner, $repo, $artifact_id, $contentType);
    }

    /**
     * Operation actionsDeleteArtifactWithHttpInfo
     *
     * Delete an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteArtifact'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteArtifactWithHttpInfo($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsDeleteArtifact'][0])
    {
        $request = $this->actionsDeleteArtifactRequest($owner, $repo, $artifact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteArtifactAsync
     *
     * Delete an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteArtifactAsync($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsDeleteArtifact'][0])
    {
        return $this->actionsDeleteArtifactAsyncWithHttpInfo($owner, $repo, $artifact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteArtifactAsyncWithHttpInfo
     *
     * Delete an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteArtifactAsyncWithHttpInfo($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsDeleteArtifact'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteArtifactRequest($owner, $repo, $artifact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteArtifact'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteArtifactRequest($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsDeleteArtifact'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteArtifact'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteArtifact'
            );
        }

        // verify the required parameter 'artifact_id' is set
        if ($artifact_id === null || (is_array($artifact_id) && count($artifact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_id when calling actionsDeleteArtifact'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($artifact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'artifact_id' . '}',
                ObjectSerializer::toPathValue($artifact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteEnvironmentSecret
     *
     * Delete an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteEnvironmentSecret($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentSecret'][0])
    {
        $this->actionsDeleteEnvironmentSecretWithHttpInfo($owner, $repo, $environment_name, $secret_name, $contentType);
    }

    /**
     * Operation actionsDeleteEnvironmentSecretWithHttpInfo
     *
     * Delete an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteEnvironmentSecretWithHttpInfo($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentSecret'][0])
    {
        $request = $this->actionsDeleteEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteEnvironmentSecretAsync
     *
     * Delete an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteEnvironmentSecretAsync($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentSecret'][0])
    {
        return $this->actionsDeleteEnvironmentSecretAsyncWithHttpInfo($owner, $repo, $environment_name, $secret_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteEnvironmentSecretAsyncWithHttpInfo
     *
     * Delete an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteEnvironmentSecretAsyncWithHttpInfo($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentSecret'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteEnvironmentSecret'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentSecret'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteEnvironmentSecret'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteEnvironmentSecret'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsDeleteEnvironmentSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsDeleteEnvironmentSecret'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteEnvironmentVariable
     *
     * Delete an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteEnvironmentVariable($owner, $repo, $name, $environment_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentVariable'][0])
    {
        $this->actionsDeleteEnvironmentVariableWithHttpInfo($owner, $repo, $name, $environment_name, $contentType);
    }

    /**
     * Operation actionsDeleteEnvironmentVariableWithHttpInfo
     *
     * Delete an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteEnvironmentVariableWithHttpInfo($owner, $repo, $name, $environment_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentVariable'][0])
    {
        $request = $this->actionsDeleteEnvironmentVariableRequest($owner, $repo, $name, $environment_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteEnvironmentVariableAsync
     *
     * Delete an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteEnvironmentVariableAsync($owner, $repo, $name, $environment_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentVariable'][0])
    {
        return $this->actionsDeleteEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $name, $environment_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteEnvironmentVariableAsyncWithHttpInfo
     *
     * Delete an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $name, $environment_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteEnvironmentVariableRequest($owner, $repo, $name, $environment_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteEnvironmentVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteEnvironmentVariableRequest($owner, $repo, $name, $environment_name, string $contentType = self::contentTypes['actionsDeleteEnvironmentVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteEnvironmentVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteEnvironmentVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsDeleteEnvironmentVariable'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsDeleteEnvironmentVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteOrgSecret
     *
     * Delete an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteOrgSecret($org, $secret_name, string $contentType = self::contentTypes['actionsDeleteOrgSecret'][0])
    {
        $this->actionsDeleteOrgSecretWithHttpInfo($org, $secret_name, $contentType);
    }

    /**
     * Operation actionsDeleteOrgSecretWithHttpInfo
     *
     * Delete an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteOrgSecretWithHttpInfo($org, $secret_name, string $contentType = self::contentTypes['actionsDeleteOrgSecret'][0])
    {
        $request = $this->actionsDeleteOrgSecretRequest($org, $secret_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteOrgSecretAsync
     *
     * Delete an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteOrgSecretAsync($org, $secret_name, string $contentType = self::contentTypes['actionsDeleteOrgSecret'][0])
    {
        return $this->actionsDeleteOrgSecretAsyncWithHttpInfo($org, $secret_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteOrgSecretAsyncWithHttpInfo
     *
     * Delete an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteOrgSecretAsyncWithHttpInfo($org, $secret_name, string $contentType = self::contentTypes['actionsDeleteOrgSecret'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteOrgSecretRequest($org, $secret_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteOrgSecretRequest($org, $secret_name, string $contentType = self::contentTypes['actionsDeleteOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsDeleteOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsDeleteOrgSecret'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteOrgVariable
     *
     * Delete an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteOrgVariable($org, $name, string $contentType = self::contentTypes['actionsDeleteOrgVariable'][0])
    {
        $this->actionsDeleteOrgVariableWithHttpInfo($org, $name, $contentType);
    }

    /**
     * Operation actionsDeleteOrgVariableWithHttpInfo
     *
     * Delete an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteOrgVariableWithHttpInfo($org, $name, string $contentType = self::contentTypes['actionsDeleteOrgVariable'][0])
    {
        $request = $this->actionsDeleteOrgVariableRequest($org, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteOrgVariableAsync
     *
     * Delete an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteOrgVariableAsync($org, $name, string $contentType = self::contentTypes['actionsDeleteOrgVariable'][0])
    {
        return $this->actionsDeleteOrgVariableAsyncWithHttpInfo($org, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteOrgVariableAsyncWithHttpInfo
     *
     * Delete an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteOrgVariableAsyncWithHttpInfo($org, $name, string $contentType = self::contentTypes['actionsDeleteOrgVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteOrgVariableRequest($org, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteOrgVariableRequest($org, $name, string $contentType = self::contentTypes['actionsDeleteOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsDeleteOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsDeleteOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteRepoSecret
     *
     * Delete a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteRepoSecret($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsDeleteRepoSecret'][0])
    {
        $this->actionsDeleteRepoSecretWithHttpInfo($owner, $repo, $secret_name, $contentType);
    }

    /**
     * Operation actionsDeleteRepoSecretWithHttpInfo
     *
     * Delete a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteRepoSecretWithHttpInfo($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsDeleteRepoSecret'][0])
    {
        $request = $this->actionsDeleteRepoSecretRequest($owner, $repo, $secret_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteRepoSecretAsync
     *
     * Delete a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteRepoSecretAsync($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsDeleteRepoSecret'][0])
    {
        return $this->actionsDeleteRepoSecretAsyncWithHttpInfo($owner, $repo, $secret_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteRepoSecretAsyncWithHttpInfo
     *
     * Delete a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteRepoSecretAsyncWithHttpInfo($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsDeleteRepoSecret'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteRepoSecretRequest($owner, $repo, $secret_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteRepoSecret'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteRepoSecretRequest($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsDeleteRepoSecret'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteRepoSecret'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteRepoSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsDeleteRepoSecret'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteRepoVariable
     *
     * Delete a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteRepoVariable($owner, $repo, $name, string $contentType = self::contentTypes['actionsDeleteRepoVariable'][0])
    {
        $this->actionsDeleteRepoVariableWithHttpInfo($owner, $repo, $name, $contentType);
    }

    /**
     * Operation actionsDeleteRepoVariableWithHttpInfo
     *
     * Delete a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteRepoVariableWithHttpInfo($owner, $repo, $name, string $contentType = self::contentTypes['actionsDeleteRepoVariable'][0])
    {
        $request = $this->actionsDeleteRepoVariableRequest($owner, $repo, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteRepoVariableAsync
     *
     * Delete a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteRepoVariableAsync($owner, $repo, $name, string $contentType = self::contentTypes['actionsDeleteRepoVariable'][0])
    {
        return $this->actionsDeleteRepoVariableAsyncWithHttpInfo($owner, $repo, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteRepoVariableAsyncWithHttpInfo
     *
     * Delete a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteRepoVariableAsyncWithHttpInfo($owner, $repo, $name, string $contentType = self::contentTypes['actionsDeleteRepoVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteRepoVariableRequest($owner, $repo, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteRepoVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteRepoVariableRequest($owner, $repo, $name, string $contentType = self::contentTypes['actionsDeleteRepoVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteRepoVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteRepoVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsDeleteRepoVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromOrg
     *
     * Delete a self-hosted runner from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteSelfHostedRunnerFromOrg($org, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'][0])
    {
        $this->actionsDeleteSelfHostedRunnerFromOrgWithHttpInfo($org, $runner_id, $contentType);
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromOrgWithHttpInfo
     *
     * Delete a self-hosted runner from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteSelfHostedRunnerFromOrgWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'][0])
    {
        $request = $this->actionsDeleteSelfHostedRunnerFromOrgRequest($org, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromOrgAsync
     *
     * Delete a self-hosted runner from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteSelfHostedRunnerFromOrgAsync($org, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'][0])
    {
        return $this->actionsDeleteSelfHostedRunnerFromOrgAsyncWithHttpInfo($org, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromOrgAsyncWithHttpInfo
     *
     * Delete a self-hosted runner from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteSelfHostedRunnerFromOrgAsyncWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteSelfHostedRunnerFromOrgRequest($org, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteSelfHostedRunnerFromOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteSelfHostedRunnerFromOrgRequest($org, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsDeleteSelfHostedRunnerFromOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsDeleteSelfHostedRunnerFromOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromRepo
     *
     * Delete a self-hosted runner from a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteSelfHostedRunnerFromRepo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'][0])
    {
        $this->actionsDeleteSelfHostedRunnerFromRepoWithHttpInfo($owner, $repo, $runner_id, $contentType);
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromRepoWithHttpInfo
     *
     * Delete a self-hosted runner from a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteSelfHostedRunnerFromRepoWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'][0])
    {
        $request = $this->actionsDeleteSelfHostedRunnerFromRepoRequest($owner, $repo, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromRepoAsync
     *
     * Delete a self-hosted runner from a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteSelfHostedRunnerFromRepoAsync($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'][0])
    {
        return $this->actionsDeleteSelfHostedRunnerFromRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerFromRepoAsyncWithHttpInfo
     *
     * Delete a self-hosted runner from a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteSelfHostedRunnerFromRepoAsyncWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteSelfHostedRunnerFromRepoRequest($owner, $repo, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteSelfHostedRunnerFromRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteSelfHostedRunnerFromRepoRequest($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerFromRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteSelfHostedRunnerFromRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteSelfHostedRunnerFromRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsDeleteSelfHostedRunnerFromRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerGroupFromOrg
     *
     * Delete a self-hosted runner group from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteSelfHostedRunnerGroupFromOrg($org, $runner_group_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'][0])
    {
        $this->actionsDeleteSelfHostedRunnerGroupFromOrgWithHttpInfo($org, $runner_group_id, $contentType);
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerGroupFromOrgWithHttpInfo
     *
     * Delete a self-hosted runner group from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteSelfHostedRunnerGroupFromOrgWithHttpInfo($org, $runner_group_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'][0])
    {
        $request = $this->actionsDeleteSelfHostedRunnerGroupFromOrgRequest($org, $runner_group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerGroupFromOrgAsync
     *
     * Delete a self-hosted runner group from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteSelfHostedRunnerGroupFromOrgAsync($org, $runner_group_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'][0])
    {
        return $this->actionsDeleteSelfHostedRunnerGroupFromOrgAsyncWithHttpInfo($org, $runner_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteSelfHostedRunnerGroupFromOrgAsyncWithHttpInfo
     *
     * Delete a self-hosted runner group from an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteSelfHostedRunnerGroupFromOrgAsyncWithHttpInfo($org, $runner_group_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteSelfHostedRunnerGroupFromOrgRequest($org, $runner_group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteSelfHostedRunnerGroupFromOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteSelfHostedRunnerGroupFromOrgRequest($org, $runner_group_id, string $contentType = self::contentTypes['actionsDeleteSelfHostedRunnerGroupFromOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsDeleteSelfHostedRunnerGroupFromOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsDeleteSelfHostedRunnerGroupFromOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteWorkflowRun
     *
     * Delete a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteWorkflowRun($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRun'][0])
    {
        $this->actionsDeleteWorkflowRunWithHttpInfo($owner, $repo, $run_id, $contentType);
    }

    /**
     * Operation actionsDeleteWorkflowRunWithHttpInfo
     *
     * Delete a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteWorkflowRunWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRun'][0])
    {
        $request = $this->actionsDeleteWorkflowRunRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteWorkflowRunAsync
     *
     * Delete a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteWorkflowRunAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRun'][0])
    {
        return $this->actionsDeleteWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteWorkflowRunAsyncWithHttpInfo
     *
     * Delete a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRun'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteWorkflowRunRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteWorkflowRunRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteWorkflowRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsDeleteWorkflowRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDeleteWorkflowRunLogs
     *
     * Delete workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDeleteWorkflowRunLogs($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRunLogs'][0])
    {
        $this->actionsDeleteWorkflowRunLogsWithHttpInfo($owner, $repo, $run_id, $contentType);
    }

    /**
     * Operation actionsDeleteWorkflowRunLogsWithHttpInfo
     *
     * Delete workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDeleteWorkflowRunLogsWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRunLogs'][0])
    {
        $request = $this->actionsDeleteWorkflowRunLogsRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDeleteWorkflowRunLogsAsync
     *
     * Delete workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteWorkflowRunLogsAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRunLogs'][0])
    {
        return $this->actionsDeleteWorkflowRunLogsAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDeleteWorkflowRunLogsAsyncWithHttpInfo
     *
     * Delete workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDeleteWorkflowRunLogsAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRunLogs'][0])
    {
        $returnType = '';
        $request = $this->actionsDeleteWorkflowRunLogsRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDeleteWorkflowRunLogs'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDeleteWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDeleteWorkflowRunLogsRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDeleteWorkflowRunLogs'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDeleteWorkflowRunLogs'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDeleteWorkflowRunLogs'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsDeleteWorkflowRunLogs'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDisableSelectedRepositoryGithubActionsOrganization
     *
     * Disable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDisableSelectedRepositoryGithubActionsOrganization($org, $repository_id, string $contentType = self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'][0])
    {
        $this->actionsDisableSelectedRepositoryGithubActionsOrganizationWithHttpInfo($org, $repository_id, $contentType);
    }

    /**
     * Operation actionsDisableSelectedRepositoryGithubActionsOrganizationWithHttpInfo
     *
     * Disable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDisableSelectedRepositoryGithubActionsOrganizationWithHttpInfo($org, $repository_id, string $contentType = self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'][0])
    {
        $request = $this->actionsDisableSelectedRepositoryGithubActionsOrganizationRequest($org, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDisableSelectedRepositoryGithubActionsOrganizationAsync
     *
     * Disable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDisableSelectedRepositoryGithubActionsOrganizationAsync($org, $repository_id, string $contentType = self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'][0])
    {
        return $this->actionsDisableSelectedRepositoryGithubActionsOrganizationAsyncWithHttpInfo($org, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDisableSelectedRepositoryGithubActionsOrganizationAsyncWithHttpInfo
     *
     * Disable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDisableSelectedRepositoryGithubActionsOrganizationAsyncWithHttpInfo($org, $repository_id, string $contentType = self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'][0])
    {
        $returnType = '';
        $request = $this->actionsDisableSelectedRepositoryGithubActionsOrganizationRequest($org, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDisableSelectedRepositoryGithubActionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDisableSelectedRepositoryGithubActionsOrganizationRequest($org, $repository_id, string $contentType = self::contentTypes['actionsDisableSelectedRepositoryGithubActionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsDisableSelectedRepositoryGithubActionsOrganization'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsDisableSelectedRepositoryGithubActionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDisableWorkflow
     *
     * Disable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDisableWorkflow($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsDisableWorkflow'][0])
    {
        $this->actionsDisableWorkflowWithHttpInfo($owner, $repo, $workflow_id, $contentType);
    }

    /**
     * Operation actionsDisableWorkflowWithHttpInfo
     *
     * Disable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDisableWorkflowWithHttpInfo($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsDisableWorkflow'][0])
    {
        $request = $this->actionsDisableWorkflowRequest($owner, $repo, $workflow_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDisableWorkflowAsync
     *
     * Disable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDisableWorkflowAsync($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsDisableWorkflow'][0])
    {
        return $this->actionsDisableWorkflowAsyncWithHttpInfo($owner, $repo, $workflow_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDisableWorkflowAsyncWithHttpInfo
     *
     * Disable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDisableWorkflowAsyncWithHttpInfo($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsDisableWorkflow'][0])
    {
        $returnType = '';
        $request = $this->actionsDisableWorkflowRequest($owner, $repo, $workflow_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDisableWorkflow'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDisableWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDisableWorkflowRequest($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsDisableWorkflow'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDisableWorkflow'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDisableWorkflow'
            );
        }

        // verify the required parameter 'workflow_id' is set
        if ($workflow_id === null || (is_array($workflow_id) && count($workflow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workflow_id when calling actionsDisableWorkflow'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($workflow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow_id' . '}',
                ObjectSerializer::toPathValue($workflow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDownloadArtifact
     *
     * Download an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $archive_format archive_format (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadArtifact'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDownloadArtifact($owner, $repo, $artifact_id, $archive_format, string $contentType = self::contentTypes['actionsDownloadArtifact'][0])
    {
        $this->actionsDownloadArtifactWithHttpInfo($owner, $repo, $artifact_id, $archive_format, $contentType);
    }

    /**
     * Operation actionsDownloadArtifactWithHttpInfo
     *
     * Download an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $archive_format (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadArtifact'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDownloadArtifactWithHttpInfo($owner, $repo, $artifact_id, $archive_format, string $contentType = self::contentTypes['actionsDownloadArtifact'][0])
    {
        $request = $this->actionsDownloadArtifactRequest($owner, $repo, $artifact_id, $archive_format, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDownloadArtifactAsync
     *
     * Download an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $archive_format (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadArtifactAsync($owner, $repo, $artifact_id, $archive_format, string $contentType = self::contentTypes['actionsDownloadArtifact'][0])
    {
        return $this->actionsDownloadArtifactAsyncWithHttpInfo($owner, $repo, $artifact_id, $archive_format, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDownloadArtifactAsyncWithHttpInfo
     *
     * Download an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $archive_format (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadArtifactAsyncWithHttpInfo($owner, $repo, $artifact_id, $archive_format, string $contentType = self::contentTypes['actionsDownloadArtifact'][0])
    {
        $returnType = '';
        $request = $this->actionsDownloadArtifactRequest($owner, $repo, $artifact_id, $archive_format, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDownloadArtifact'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $archive_format (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDownloadArtifactRequest($owner, $repo, $artifact_id, $archive_format, string $contentType = self::contentTypes['actionsDownloadArtifact'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDownloadArtifact'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDownloadArtifact'
            );
        }

        // verify the required parameter 'artifact_id' is set
        if ($artifact_id === null || (is_array($artifact_id) && count($artifact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_id when calling actionsDownloadArtifact'
            );
        }

        // verify the required parameter 'archive_format' is set
        if ($archive_format === null || (is_array($archive_format) && count($archive_format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $archive_format when calling actionsDownloadArtifact'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($artifact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'artifact_id' . '}',
                ObjectSerializer::toPathValue($artifact_id),
                $resourcePath
            );
        }
        // path params
        if ($archive_format !== null) {
            $resourcePath = str_replace(
                '{' . 'archive_format' . '}',
                ObjectSerializer::toPathValue($archive_format),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDownloadJobLogsForWorkflowRun
     *
     * Download job logs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadJobLogsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDownloadJobLogsForWorkflowRun($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsDownloadJobLogsForWorkflowRun'][0])
    {
        $this->actionsDownloadJobLogsForWorkflowRunWithHttpInfo($owner, $repo, $job_id, $contentType);
    }

    /**
     * Operation actionsDownloadJobLogsForWorkflowRunWithHttpInfo
     *
     * Download job logs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadJobLogsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDownloadJobLogsForWorkflowRunWithHttpInfo($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsDownloadJobLogsForWorkflowRun'][0])
    {
        $request = $this->actionsDownloadJobLogsForWorkflowRunRequest($owner, $repo, $job_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDownloadJobLogsForWorkflowRunAsync
     *
     * Download job logs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadJobLogsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadJobLogsForWorkflowRunAsync($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsDownloadJobLogsForWorkflowRun'][0])
    {
        return $this->actionsDownloadJobLogsForWorkflowRunAsyncWithHttpInfo($owner, $repo, $job_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDownloadJobLogsForWorkflowRunAsyncWithHttpInfo
     *
     * Download job logs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadJobLogsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadJobLogsForWorkflowRunAsyncWithHttpInfo($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsDownloadJobLogsForWorkflowRun'][0])
    {
        $returnType = '';
        $request = $this->actionsDownloadJobLogsForWorkflowRunRequest($owner, $repo, $job_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDownloadJobLogsForWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadJobLogsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDownloadJobLogsForWorkflowRunRequest($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsDownloadJobLogsForWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDownloadJobLogsForWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDownloadJobLogsForWorkflowRun'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling actionsDownloadJobLogsForWorkflowRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/jobs/{job_id}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'job_id' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDownloadWorkflowRunAttemptLogs
     *
     * Download workflow run attempt logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDownloadWorkflowRunAttemptLogs($owner, $repo, $run_id, $attempt_number, string $contentType = self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'][0])
    {
        $this->actionsDownloadWorkflowRunAttemptLogsWithHttpInfo($owner, $repo, $run_id, $attempt_number, $contentType);
    }

    /**
     * Operation actionsDownloadWorkflowRunAttemptLogsWithHttpInfo
     *
     * Download workflow run attempt logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDownloadWorkflowRunAttemptLogsWithHttpInfo($owner, $repo, $run_id, $attempt_number, string $contentType = self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'][0])
    {
        $request = $this->actionsDownloadWorkflowRunAttemptLogsRequest($owner, $repo, $run_id, $attempt_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDownloadWorkflowRunAttemptLogsAsync
     *
     * Download workflow run attempt logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadWorkflowRunAttemptLogsAsync($owner, $repo, $run_id, $attempt_number, string $contentType = self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'][0])
    {
        return $this->actionsDownloadWorkflowRunAttemptLogsAsyncWithHttpInfo($owner, $repo, $run_id, $attempt_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDownloadWorkflowRunAttemptLogsAsyncWithHttpInfo
     *
     * Download workflow run attempt logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadWorkflowRunAttemptLogsAsyncWithHttpInfo($owner, $repo, $run_id, $attempt_number, string $contentType = self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'][0])
    {
        $returnType = '';
        $request = $this->actionsDownloadWorkflowRunAttemptLogsRequest($owner, $repo, $run_id, $attempt_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDownloadWorkflowRunAttemptLogs'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDownloadWorkflowRunAttemptLogsRequest($owner, $repo, $run_id, $attempt_number, string $contentType = self::contentTypes['actionsDownloadWorkflowRunAttemptLogs'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDownloadWorkflowRunAttemptLogs'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDownloadWorkflowRunAttemptLogs'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsDownloadWorkflowRunAttemptLogs'
            );
        }

        // verify the required parameter 'attempt_number' is set
        if ($attempt_number === null || (is_array($attempt_number) && count($attempt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attempt_number when calling actionsDownloadWorkflowRunAttemptLogs'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }
        // path params
        if ($attempt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'attempt_number' . '}',
                ObjectSerializer::toPathValue($attempt_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsDownloadWorkflowRunLogs
     *
     * Download workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsDownloadWorkflowRunLogs($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDownloadWorkflowRunLogs'][0])
    {
        $this->actionsDownloadWorkflowRunLogsWithHttpInfo($owner, $repo, $run_id, $contentType);
    }

    /**
     * Operation actionsDownloadWorkflowRunLogsWithHttpInfo
     *
     * Download workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsDownloadWorkflowRunLogsWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDownloadWorkflowRunLogs'][0])
    {
        $request = $this->actionsDownloadWorkflowRunLogsRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsDownloadWorkflowRunLogsAsync
     *
     * Download workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadWorkflowRunLogsAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDownloadWorkflowRunLogs'][0])
    {
        return $this->actionsDownloadWorkflowRunLogsAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsDownloadWorkflowRunLogsAsyncWithHttpInfo
     *
     * Download workflow run logs
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsDownloadWorkflowRunLogsAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDownloadWorkflowRunLogs'][0])
    {
        $returnType = '';
        $request = $this->actionsDownloadWorkflowRunLogsRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsDownloadWorkflowRunLogs'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsDownloadWorkflowRunLogs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsDownloadWorkflowRunLogsRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsDownloadWorkflowRunLogs'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsDownloadWorkflowRunLogs'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsDownloadWorkflowRunLogs'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsDownloadWorkflowRunLogs'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsEnableSelectedRepositoryGithubActionsOrganization
     *
     * Enable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsEnableSelectedRepositoryGithubActionsOrganization($org, $repository_id, string $contentType = self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'][0])
    {
        $this->actionsEnableSelectedRepositoryGithubActionsOrganizationWithHttpInfo($org, $repository_id, $contentType);
    }

    /**
     * Operation actionsEnableSelectedRepositoryGithubActionsOrganizationWithHttpInfo
     *
     * Enable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsEnableSelectedRepositoryGithubActionsOrganizationWithHttpInfo($org, $repository_id, string $contentType = self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'][0])
    {
        $request = $this->actionsEnableSelectedRepositoryGithubActionsOrganizationRequest($org, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsEnableSelectedRepositoryGithubActionsOrganizationAsync
     *
     * Enable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsEnableSelectedRepositoryGithubActionsOrganizationAsync($org, $repository_id, string $contentType = self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'][0])
    {
        return $this->actionsEnableSelectedRepositoryGithubActionsOrganizationAsyncWithHttpInfo($org, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsEnableSelectedRepositoryGithubActionsOrganizationAsyncWithHttpInfo
     *
     * Enable a selected repository for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsEnableSelectedRepositoryGithubActionsOrganizationAsyncWithHttpInfo($org, $repository_id, string $contentType = self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'][0])
    {
        $returnType = '';
        $request = $this->actionsEnableSelectedRepositoryGithubActionsOrganizationRequest($org, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsEnableSelectedRepositoryGithubActionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsEnableSelectedRepositoryGithubActionsOrganizationRequest($org, $repository_id, string $contentType = self::contentTypes['actionsEnableSelectedRepositoryGithubActionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsEnableSelectedRepositoryGithubActionsOrganization'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsEnableSelectedRepositoryGithubActionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsEnableWorkflow
     *
     * Enable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsEnableWorkflow($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsEnableWorkflow'][0])
    {
        $this->actionsEnableWorkflowWithHttpInfo($owner, $repo, $workflow_id, $contentType);
    }

    /**
     * Operation actionsEnableWorkflowWithHttpInfo
     *
     * Enable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsEnableWorkflowWithHttpInfo($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsEnableWorkflow'][0])
    {
        $request = $this->actionsEnableWorkflowRequest($owner, $repo, $workflow_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsEnableWorkflowAsync
     *
     * Enable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsEnableWorkflowAsync($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsEnableWorkflow'][0])
    {
        return $this->actionsEnableWorkflowAsyncWithHttpInfo($owner, $repo, $workflow_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsEnableWorkflowAsyncWithHttpInfo
     *
     * Enable a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsEnableWorkflowAsyncWithHttpInfo($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsEnableWorkflow'][0])
    {
        $returnType = '';
        $request = $this->actionsEnableWorkflowRequest($owner, $repo, $workflow_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsEnableWorkflow'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsEnableWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsEnableWorkflowRequest($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsEnableWorkflow'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsEnableWorkflow'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsEnableWorkflow'
            );
        }

        // verify the required parameter 'workflow_id' is set
        if ($workflow_id === null || (is_array($workflow_id) && count($workflow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workflow_id when calling actionsEnableWorkflow'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($workflow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow_id' . '}',
                ObjectSerializer::toPathValue($workflow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsForceCancelWorkflowRun
     *
     * Force cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsForceCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsForceCancelWorkflowRun($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsForceCancelWorkflowRun'][0])
    {
        list($response) = $this->actionsForceCancelWorkflowRunWithHttpInfo($owner, $repo, $run_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsForceCancelWorkflowRunWithHttpInfo
     *
     * Force cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsForceCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsForceCancelWorkflowRunWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsForceCancelWorkflowRun'][0])
    {
        $request = $this->actionsForceCancelWorkflowRunRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsForceCancelWorkflowRunAsync
     *
     * Force cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsForceCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsForceCancelWorkflowRunAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsForceCancelWorkflowRun'][0])
    {
        return $this->actionsForceCancelWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsForceCancelWorkflowRunAsyncWithHttpInfo
     *
     * Force cancel a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsForceCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsForceCancelWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsForceCancelWorkflowRun'][0])
    {
        $returnType = 'object';
        $request = $this->actionsForceCancelWorkflowRunRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsForceCancelWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsForceCancelWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsForceCancelWorkflowRunRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsForceCancelWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsForceCancelWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsForceCancelWorkflowRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsForceCancelWorkflowRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForEnterprise
     *
     * Create configuration for a just-in-time runner for an Enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsGenerateRunnerJitconfigForEnterprise($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'][0])
    {
        list($response) = $this->actionsGenerateRunnerJitconfigForEnterpriseWithHttpInfo($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForEnterpriseWithHttpInfo
     *
     * Create configuration for a just-in-time runner for an Enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGenerateRunnerJitconfigForEnterpriseWithHttpInfo($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'][0])
    {
        $request = $this->actionsGenerateRunnerJitconfigForEnterpriseRequest($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForEnterpriseAsync
     *
     * Create configuration for a just-in-time runner for an Enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGenerateRunnerJitconfigForEnterpriseAsync($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'][0])
    {
        return $this->actionsGenerateRunnerJitconfigForEnterpriseAsyncWithHttpInfo($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForEnterpriseAsyncWithHttpInfo
     *
     * Create configuration for a just-in-time runner for an Enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGenerateRunnerJitconfigForEnterpriseAsyncWithHttpInfo($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response';
        $request = $this->actionsGenerateRunnerJitconfigForEnterpriseRequest($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGenerateRunnerJitconfigForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGenerateRunnerJitconfigForEnterpriseRequest($enterprise, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling actionsGenerateRunnerJitconfigForEnterprise'
            );
        }

        // verify the required parameter 'actions_generate_runner_jitconfig_for_enterprise_request' is set
        if ($actions_generate_runner_jitconfig_for_enterprise_request === null || (is_array($actions_generate_runner_jitconfig_for_enterprise_request) && count($actions_generate_runner_jitconfig_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_generate_runner_jitconfig_for_enterprise_request when calling actionsGenerateRunnerJitconfigForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/generate-jitconfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_generate_runner_jitconfig_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_generate_runner_jitconfig_for_enterprise_request));
            } else {
                $httpBody = $actions_generate_runner_jitconfig_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForOrg
     *
     * Create configuration for a just-in-time runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsGenerateRunnerJitconfigForOrg($org, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForOrg'][0])
    {
        list($response) = $this->actionsGenerateRunnerJitconfigForOrgWithHttpInfo($org, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForOrgWithHttpInfo
     *
     * Create configuration for a just-in-time runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGenerateRunnerJitconfigForOrgWithHttpInfo($org, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForOrg'][0])
    {
        $request = $this->actionsGenerateRunnerJitconfigForOrgRequest($org, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForOrgAsync
     *
     * Create configuration for a just-in-time runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGenerateRunnerJitconfigForOrgAsync($org, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForOrg'][0])
    {
        return $this->actionsGenerateRunnerJitconfigForOrgAsyncWithHttpInfo($org, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForOrgAsyncWithHttpInfo
     *
     * Create configuration for a just-in-time runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGenerateRunnerJitconfigForOrgAsyncWithHttpInfo($org, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response';
        $request = $this->actionsGenerateRunnerJitconfigForOrgRequest($org, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGenerateRunnerJitconfigForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGenerateRunnerJitconfigForOrgRequest($org, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGenerateRunnerJitconfigForOrg'
            );
        }

        // verify the required parameter 'actions_generate_runner_jitconfig_for_enterprise_request' is set
        if ($actions_generate_runner_jitconfig_for_enterprise_request === null || (is_array($actions_generate_runner_jitconfig_for_enterprise_request) && count($actions_generate_runner_jitconfig_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_generate_runner_jitconfig_for_enterprise_request when calling actionsGenerateRunnerJitconfigForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/generate-jitconfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_generate_runner_jitconfig_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_generate_runner_jitconfig_for_enterprise_request));
            } else {
                $httpBody = $actions_generate_runner_jitconfig_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForRepo
     *
     * Create configuration for a just-in-time runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsGenerateRunnerJitconfigForRepo($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForRepo'][0])
    {
        list($response) = $this->actionsGenerateRunnerJitconfigForRepoWithHttpInfo($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForRepoWithHttpInfo
     *
     * Create configuration for a just-in-time runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGenerateRunnerJitconfigForRepoWithHttpInfo($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForRepo'][0])
    {
        $request = $this->actionsGenerateRunnerJitconfigForRepoRequest($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForRepoAsync
     *
     * Create configuration for a just-in-time runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGenerateRunnerJitconfigForRepoAsync($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForRepo'][0])
    {
        return $this->actionsGenerateRunnerJitconfigForRepoAsyncWithHttpInfo($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGenerateRunnerJitconfigForRepoAsyncWithHttpInfo
     *
     * Create configuration for a just-in-time runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGenerateRunnerJitconfigForRepoAsyncWithHttpInfo($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterprise201Response';
        $request = $this->actionsGenerateRunnerJitconfigForRepoRequest($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGenerateRunnerJitconfigForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGenerateRunnerJitconfigForEnterpriseRequest $actions_generate_runner_jitconfig_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGenerateRunnerJitconfigForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGenerateRunnerJitconfigForRepoRequest($owner, $repo, $actions_generate_runner_jitconfig_for_enterprise_request, string $contentType = self::contentTypes['actionsGenerateRunnerJitconfigForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGenerateRunnerJitconfigForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGenerateRunnerJitconfigForRepo'
            );
        }

        // verify the required parameter 'actions_generate_runner_jitconfig_for_enterprise_request' is set
        if ($actions_generate_runner_jitconfig_for_enterprise_request === null || (is_array($actions_generate_runner_jitconfig_for_enterprise_request) && count($actions_generate_runner_jitconfig_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_generate_runner_jitconfig_for_enterprise_request when calling actionsGenerateRunnerJitconfigForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/generate-jitconfig';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_generate_runner_jitconfig_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_generate_runner_jitconfig_for_enterprise_request));
            } else {
                $httpBody = $actions_generate_runner_jitconfig_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheList
     *
     * List GitHub Actions caches for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $key An explicit key or prefix for identifying the cache (optional)
     * @param  string $sort The property to sort the results by. &#x60;created_at&#x60; means when the cache was created. &#x60;last_accessed_at&#x60; means when the cache was last accessed. &#x60;size_in_bytes&#x60; is the size of the cache in bytes. (optional, default to 'last_accessed_at')
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheList'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList
     */
    public function actionsGetActionsCacheList($owner, $repo, $per_page = 30, $page = 1, $ref = null, $key = null, $sort = 'last_accessed_at', $direction = 'desc', string $contentType = self::contentTypes['actionsGetActionsCacheList'][0])
    {
        list($response) = $this->actionsGetActionsCacheListWithHttpInfo($owner, $repo, $per_page, $page, $ref, $key, $sort, $direction, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheListWithHttpInfo
     *
     * List GitHub Actions caches for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $key An explicit key or prefix for identifying the cache (optional)
     * @param  string $sort The property to sort the results by. &#x60;created_at&#x60; means when the cache was created. &#x60;last_accessed_at&#x60; means when the cache was last accessed. &#x60;size_in_bytes&#x60; is the size of the cache in bytes. (optional, default to 'last_accessed_at')
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheList'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheListWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, $ref = null, $key = null, $sort = 'last_accessed_at', $direction = 'desc', string $contentType = self::contentTypes['actionsGetActionsCacheList'][0])
    {
        $request = $this->actionsGetActionsCacheListRequest($owner, $repo, $per_page, $page, $ref, $key, $sort, $direction, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheListAsync
     *
     * List GitHub Actions caches for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $key An explicit key or prefix for identifying the cache (optional)
     * @param  string $sort The property to sort the results by. &#x60;created_at&#x60; means when the cache was created. &#x60;last_accessed_at&#x60; means when the cache was last accessed. &#x60;size_in_bytes&#x60; is the size of the cache in bytes. (optional, default to 'last_accessed_at')
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheListAsync($owner, $repo, $per_page = 30, $page = 1, $ref = null, $key = null, $sort = 'last_accessed_at', $direction = 'desc', string $contentType = self::contentTypes['actionsGetActionsCacheList'][0])
    {
        return $this->actionsGetActionsCacheListAsyncWithHttpInfo($owner, $repo, $per_page, $page, $ref, $key, $sort, $direction, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheListAsyncWithHttpInfo
     *
     * List GitHub Actions caches for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $key An explicit key or prefix for identifying the cache (optional)
     * @param  string $sort The property to sort the results by. &#x60;created_at&#x60; means when the cache was created. &#x60;last_accessed_at&#x60; means when the cache was last accessed. &#x60;size_in_bytes&#x60; is the size of the cache in bytes. (optional, default to 'last_accessed_at')
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheListAsyncWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, $ref = null, $key = null, $sort = 'last_accessed_at', $direction = 'desc', string $contentType = self::contentTypes['actionsGetActionsCacheList'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheList';
        $request = $this->actionsGetActionsCacheListRequest($owner, $repo, $per_page, $page, $ref, $key, $sort, $direction, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheList'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $ref The full Git reference for narrowing down the cache. The &#x60;ref&#x60; for a branch should be formatted as &#x60;refs/heads/&lt;branch name&gt;&#x60;. To reference a pull request use &#x60;refs/pull/&lt;number&gt;/merge&#x60;. (optional)
     * @param  string $key An explicit key or prefix for identifying the cache (optional)
     * @param  string $sort The property to sort the results by. &#x60;created_at&#x60; means when the cache was created. &#x60;last_accessed_at&#x60; means when the cache was last accessed. &#x60;size_in_bytes&#x60; is the size of the cache in bytes. (optional, default to 'last_accessed_at')
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheListRequest($owner, $repo, $per_page = 30, $page = 1, $ref = null, $key = null, $sort = 'last_accessed_at', $direction = 'desc', string $contentType = self::contentTypes['actionsGetActionsCacheList'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetActionsCacheList'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetActionsCacheList'
            );
        }








        $resourcePath = '/repos/{owner}/{repo}/actions/caches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ref,
            'ref', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $key,
            'key', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheUsage
     *
     * Get GitHub Actions cache usage for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsage'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository
     */
    public function actionsGetActionsCacheUsage($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsage'][0])
    {
        list($response) = $this->actionsGetActionsCacheUsageWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheUsageWithHttpInfo
     *
     * Get GitHub Actions cache usage for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsage'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheUsageWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsage'][0])
    {
        $request = $this->actionsGetActionsCacheUsageRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheUsageAsync
     *
     * Get GitHub Actions cache usage for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsage'][0])
    {
        return $this->actionsGetActionsCacheUsageAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheUsageAsyncWithHttpInfo
     *
     * Get GitHub Actions cache usage for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsage'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageByRepository';
        $request = $this->actionsGetActionsCacheUsageRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheUsage'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheUsageRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsage'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetActionsCacheUsage'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetActionsCacheUsage'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/cache/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheUsageByRepoForOrg
     *
     * List repositories with GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response
     */
    public function actionsGetActionsCacheUsageByRepoForOrg($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'][0])
    {
        list($response) = $this->actionsGetActionsCacheUsageByRepoForOrgWithHttpInfo($org, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheUsageByRepoForOrgWithHttpInfo
     *
     * List repositories with GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheUsageByRepoForOrgWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'][0])
    {
        $request = $this->actionsGetActionsCacheUsageByRepoForOrgRequest($org, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheUsageByRepoForOrgAsync
     *
     * List repositories with GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageByRepoForOrgAsync($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'][0])
    {
        return $this->actionsGetActionsCacheUsageByRepoForOrgAsyncWithHttpInfo($org, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheUsageByRepoForOrgAsyncWithHttpInfo
     *
     * List repositories with GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageByRepoForOrgAsyncWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetActionsCacheUsageByRepoForOrg200Response';
        $request = $this->actionsGetActionsCacheUsageByRepoForOrgRequest($org, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheUsageByRepoForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheUsageByRepoForOrgRequest($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsGetActionsCacheUsageByRepoForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetActionsCacheUsageByRepoForOrg'
            );
        }




        $resourcePath = '/orgs/{org}/actions/cache/usage-by-repository';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheUsageForEnterprise
     *
     * Get GitHub Actions cache usage for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise
     */
    public function actionsGetActionsCacheUsageForEnterprise($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForEnterprise'][0])
    {
        list($response) = $this->actionsGetActionsCacheUsageForEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheUsageForEnterpriseWithHttpInfo
     *
     * Get GitHub Actions cache usage for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheUsageForEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForEnterprise'][0])
    {
        $request = $this->actionsGetActionsCacheUsageForEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheUsageForEnterpriseAsync
     *
     * Get GitHub Actions cache usage for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageForEnterpriseAsync($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForEnterprise'][0])
    {
        return $this->actionsGetActionsCacheUsageForEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheUsageForEnterpriseAsyncWithHttpInfo
     *
     * Get GitHub Actions cache usage for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageForEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise';
        $request = $this->actionsGetActionsCacheUsageForEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheUsageForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheUsageForEnterpriseRequest($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling actionsGetActionsCacheUsageForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/cache/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheUsageForOrg
     *
     * Get GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise
     */
    public function actionsGetActionsCacheUsageForOrg($org, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForOrg'][0])
    {
        list($response) = $this->actionsGetActionsCacheUsageForOrgWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheUsageForOrgWithHttpInfo
     *
     * Get GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheUsageForOrgWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForOrg'][0])
    {
        $request = $this->actionsGetActionsCacheUsageForOrgRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheUsageForOrgAsync
     *
     * Get GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageForOrgAsync($org, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForOrg'][0])
    {
        return $this->actionsGetActionsCacheUsageForOrgAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheUsageForOrgAsyncWithHttpInfo
     *
     * Get GitHub Actions cache usage for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsageForOrgAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsageOrgEnterprise';
        $request = $this->actionsGetActionsCacheUsageForOrgRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheUsageForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsageForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheUsageForOrgRequest($org, string $contentType = self::contentTypes['actionsGetActionsCacheUsageForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetActionsCacheUsageForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/cache/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicy
     *
     * Get GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository
     */
    public function actionsGetActionsCacheUsagePolicy($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicy'][0])
    {
        list($response) = $this->actionsGetActionsCacheUsagePolicyWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyWithHttpInfo
     *
     * Get GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheUsagePolicyWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicy'][0])
    {
        $request = $this->actionsGetActionsCacheUsagePolicyRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyAsync
     *
     * Get GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsagePolicyAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicy'][0])
    {
        return $this->actionsGetActionsCacheUsagePolicyAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyAsyncWithHttpInfo
     *
     * Get GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsagePolicyAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository';
        $request = $this->actionsGetActionsCacheUsagePolicyRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheUsagePolicy'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheUsagePolicyRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicy'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetActionsCacheUsagePolicy'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetActionsCacheUsagePolicy'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/cache/usage-policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyForEnterprise
     *
     * Get GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise
     */
    public function actionsGetActionsCacheUsagePolicyForEnterprise($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'][0])
    {
        list($response) = $this->actionsGetActionsCacheUsagePolicyForEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyForEnterpriseWithHttpInfo
     *
     * Get GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetActionsCacheUsagePolicyForEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'][0])
    {
        $request = $this->actionsGetActionsCacheUsagePolicyForEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyForEnterpriseAsync
     *
     * Get GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsagePolicyForEnterpriseAsync($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'][0])
    {
        return $this->actionsGetActionsCacheUsagePolicyForEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetActionsCacheUsagePolicyForEnterpriseAsyncWithHttpInfo
     *
     * Get GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetActionsCacheUsagePolicyForEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise';
        $request = $this->actionsGetActionsCacheUsagePolicyForEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetActionsCacheUsagePolicyForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetActionsCacheUsagePolicyForEnterpriseRequest($enterprise, string $contentType = self::contentTypes['actionsGetActionsCacheUsagePolicyForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling actionsGetActionsCacheUsagePolicyForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/cache/usage-policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetAllowedActionsOrganization
     *
     * Get allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions
     */
    public function actionsGetAllowedActionsOrganization($org, string $contentType = self::contentTypes['actionsGetAllowedActionsOrganization'][0])
    {
        list($response) = $this->actionsGetAllowedActionsOrganizationWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetAllowedActionsOrganizationWithHttpInfo
     *
     * Get allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetAllowedActionsOrganizationWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetAllowedActionsOrganization'][0])
    {
        $request = $this->actionsGetAllowedActionsOrganizationRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetAllowedActionsOrganizationAsync
     *
     * Get allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetAllowedActionsOrganizationAsync($org, string $contentType = self::contentTypes['actionsGetAllowedActionsOrganization'][0])
    {
        return $this->actionsGetAllowedActionsOrganizationAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetAllowedActionsOrganizationAsyncWithHttpInfo
     *
     * Get allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetAllowedActionsOrganizationAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetAllowedActionsOrganization'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions';
        $request = $this->actionsGetAllowedActionsOrganizationRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetAllowedActionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetAllowedActionsOrganizationRequest($org, string $contentType = self::contentTypes['actionsGetAllowedActionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetAllowedActionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions/selected-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetAllowedActionsRepository
     *
     * Get allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions
     */
    public function actionsGetAllowedActionsRepository($owner, $repo, string $contentType = self::contentTypes['actionsGetAllowedActionsRepository'][0])
    {
        list($response) = $this->actionsGetAllowedActionsRepositoryWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetAllowedActionsRepositoryWithHttpInfo
     *
     * Get allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetAllowedActionsRepositoryWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetAllowedActionsRepository'][0])
    {
        $request = $this->actionsGetAllowedActionsRepositoryRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetAllowedActionsRepositoryAsync
     *
     * Get allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetAllowedActionsRepositoryAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetAllowedActionsRepository'][0])
    {
        return $this->actionsGetAllowedActionsRepositoryAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetAllowedActionsRepositoryAsyncWithHttpInfo
     *
     * Get allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetAllowedActionsRepositoryAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetAllowedActionsRepository'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions';
        $request = $this->actionsGetAllowedActionsRepositoryRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetAllowedActionsRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetAllowedActionsRepositoryRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetAllowedActionsRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetAllowedActionsRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetAllowedActionsRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions/selected-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetArtifact
     *
     * Get an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetArtifact'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact
     */
    public function actionsGetArtifact($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsGetArtifact'][0])
    {
        list($response) = $this->actionsGetArtifactWithHttpInfo($owner, $repo, $artifact_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetArtifactWithHttpInfo
     *
     * Get an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetArtifact'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetArtifactWithHttpInfo($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsGetArtifact'][0])
    {
        $request = $this->actionsGetArtifactRequest($owner, $repo, $artifact_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetArtifactAsync
     *
     * Get an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetArtifactAsync($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsGetArtifact'][0])
    {
        return $this->actionsGetArtifactAsyncWithHttpInfo($owner, $repo, $artifact_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetArtifactAsyncWithHttpInfo
     *
     * Get an artifact
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetArtifactAsyncWithHttpInfo($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsGetArtifact'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Artifact';
        $request = $this->actionsGetArtifactRequest($owner, $repo, $artifact_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetArtifact'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $artifact_id The unique identifier of the artifact. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetArtifact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetArtifactRequest($owner, $repo, $artifact_id, string $contentType = self::contentTypes['actionsGetArtifact'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetArtifact'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetArtifact'
            );
        }

        // verify the required parameter 'artifact_id' is set
        if ($artifact_id === null || (is_array($artifact_id) && count($artifact_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_id when calling actionsGetArtifact'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($artifact_id !== null) {
            $resourcePath = str_replace(
                '{' . 'artifact_id' . '}',
                ObjectSerializer::toPathValue($artifact_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetCustomOidcSubClaimForRepo
     *
     * Get the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsGetCustomOidcSubClaimForRepo($owner, $repo, string $contentType = self::contentTypes['actionsGetCustomOidcSubClaimForRepo'][0])
    {
        list($response) = $this->actionsGetCustomOidcSubClaimForRepoWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetCustomOidcSubClaimForRepoWithHttpInfo
     *
     * Get the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetCustomOidcSubClaimForRepoWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetCustomOidcSubClaimForRepo'][0])
    {
        $request = $this->actionsGetCustomOidcSubClaimForRepoRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetCustomOidcSubClaimForRepoAsync
     *
     * Get the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetCustomOidcSubClaimForRepoAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetCustomOidcSubClaimForRepo'][0])
    {
        return $this->actionsGetCustomOidcSubClaimForRepoAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetCustomOidcSubClaimForRepoAsyncWithHttpInfo
     *
     * Get the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetCustomOidcSubClaimForRepoAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetCustomOidcSubClaimForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OidcCustomSubRepo';
        $request = $this->actionsGetCustomOidcSubClaimForRepoRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetCustomOidcSubClaimForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetCustomOidcSubClaimForRepoRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetCustomOidcSubClaimForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetCustomOidcSubClaimForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetCustomOidcSubClaimForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/oidc/customization/sub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/scim+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetEnvironmentPublicKey
     *
     * Get an environment public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentPublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey
     */
    public function actionsGetEnvironmentPublicKey($owner, $repo, $environment_name, string $contentType = self::contentTypes['actionsGetEnvironmentPublicKey'][0])
    {
        list($response) = $this->actionsGetEnvironmentPublicKeyWithHttpInfo($owner, $repo, $environment_name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetEnvironmentPublicKeyWithHttpInfo
     *
     * Get an environment public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentPublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetEnvironmentPublicKeyWithHttpInfo($owner, $repo, $environment_name, string $contentType = self::contentTypes['actionsGetEnvironmentPublicKey'][0])
    {
        $request = $this->actionsGetEnvironmentPublicKeyRequest($owner, $repo, $environment_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetEnvironmentPublicKeyAsync
     *
     * Get an environment public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetEnvironmentPublicKeyAsync($owner, $repo, $environment_name, string $contentType = self::contentTypes['actionsGetEnvironmentPublicKey'][0])
    {
        return $this->actionsGetEnvironmentPublicKeyAsyncWithHttpInfo($owner, $repo, $environment_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetEnvironmentPublicKeyAsyncWithHttpInfo
     *
     * Get an environment public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetEnvironmentPublicKeyAsyncWithHttpInfo($owner, $repo, $environment_name, string $contentType = self::contentTypes['actionsGetEnvironmentPublicKey'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey';
        $request = $this->actionsGetEnvironmentPublicKeyRequest($owner, $repo, $environment_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetEnvironmentPublicKey'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetEnvironmentPublicKeyRequest($owner, $repo, $environment_name, string $contentType = self::contentTypes['actionsGetEnvironmentPublicKey'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetEnvironmentPublicKey'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetEnvironmentPublicKey'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsGetEnvironmentPublicKey'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetEnvironmentSecret
     *
     * Get an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret
     */
    public function actionsGetEnvironmentSecret($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsGetEnvironmentSecret'][0])
    {
        list($response) = $this->actionsGetEnvironmentSecretWithHttpInfo($owner, $repo, $environment_name, $secret_name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetEnvironmentSecretWithHttpInfo
     *
     * Get an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetEnvironmentSecretWithHttpInfo($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsGetEnvironmentSecret'][0])
    {
        $request = $this->actionsGetEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetEnvironmentSecretAsync
     *
     * Get an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetEnvironmentSecretAsync($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsGetEnvironmentSecret'][0])
    {
        return $this->actionsGetEnvironmentSecretAsyncWithHttpInfo($owner, $repo, $environment_name, $secret_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetEnvironmentSecretAsyncWithHttpInfo
     *
     * Get an environment secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetEnvironmentSecretAsyncWithHttpInfo($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsGetEnvironmentSecret'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret';
        $request = $this->actionsGetEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetEnvironmentSecret'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetEnvironmentSecretRequest($owner, $repo, $environment_name, $secret_name, string $contentType = self::contentTypes['actionsGetEnvironmentSecret'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetEnvironmentSecret'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetEnvironmentSecret'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsGetEnvironmentSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsGetEnvironmentSecret'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetEnvironmentVariable
     *
     * Get an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable
     */
    public function actionsGetEnvironmentVariable($owner, $repo, $environment_name, $name, string $contentType = self::contentTypes['actionsGetEnvironmentVariable'][0])
    {
        list($response) = $this->actionsGetEnvironmentVariableWithHttpInfo($owner, $repo, $environment_name, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetEnvironmentVariableWithHttpInfo
     *
     * Get an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetEnvironmentVariableWithHttpInfo($owner, $repo, $environment_name, $name, string $contentType = self::contentTypes['actionsGetEnvironmentVariable'][0])
    {
        $request = $this->actionsGetEnvironmentVariableRequest($owner, $repo, $environment_name, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetEnvironmentVariableAsync
     *
     * Get an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetEnvironmentVariableAsync($owner, $repo, $environment_name, $name, string $contentType = self::contentTypes['actionsGetEnvironmentVariable'][0])
    {
        return $this->actionsGetEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $environment_name, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetEnvironmentVariableAsyncWithHttpInfo
     *
     * Get an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $environment_name, $name, string $contentType = self::contentTypes['actionsGetEnvironmentVariable'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable';
        $request = $this->actionsGetEnvironmentVariableRequest($owner, $repo, $environment_name, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetEnvironmentVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetEnvironmentVariableRequest($owner, $repo, $environment_name, $name, string $contentType = self::contentTypes['actionsGetEnvironmentVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetEnvironmentVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetEnvironmentVariable'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsGetEnvironmentVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsGetEnvironmentVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise
     *
     * Get default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise($enterprise, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        list($response) = $this->actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseWithHttpInfo
     *
     * Get default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        $request = $this->actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseAsync
     *
     * Get default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseAsync($enterprise, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        return $this->actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseAsyncWithHttpInfo
     *
     * Get default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions';
        $request = $this->actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest($enterprise, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsOrganization
     *
     * Get default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsOrganization($org, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        list($response) = $this->actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWithHttpInfo
     *
     * Get default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        $request = $this->actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationAsync
     *
     * Get default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationAsync($org, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        return $this->actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationAsyncWithHttpInfo
     *
     * Get default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions';
        $request = $this->actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest($org, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions/workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsRepository
     *
     * Get default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsRepository($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        list($response) = $this->actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWithHttpInfo
     *
     * Get default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        $request = $this->actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryAsync
     *
     * Get default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        return $this->actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryAsyncWithHttpInfo
     *
     * Get default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsGetDefaultWorkflowPermissions';
        $request = $this->actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetGithubActionsDefaultWorkflowPermissionsRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetGithubActionsDefaultWorkflowPermissionsRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetGithubActionsDefaultWorkflowPermissionsRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions/workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetGithubActionsPermissionsOrganization
     *
     * Get GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions
     */
    public function actionsGetGithubActionsPermissionsOrganization($org, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsOrganization'][0])
    {
        list($response) = $this->actionsGetGithubActionsPermissionsOrganizationWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetGithubActionsPermissionsOrganizationWithHttpInfo
     *
     * Get GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetGithubActionsPermissionsOrganizationWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsOrganization'][0])
    {
        $request = $this->actionsGetGithubActionsPermissionsOrganizationRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetGithubActionsPermissionsOrganizationAsync
     *
     * Get GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsPermissionsOrganizationAsync($org, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsOrganization'][0])
    {
        return $this->actionsGetGithubActionsPermissionsOrganizationAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetGithubActionsPermissionsOrganizationAsyncWithHttpInfo
     *
     * Get GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsPermissionsOrganizationAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsOrganization'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOrganizationPermissions';
        $request = $this->actionsGetGithubActionsPermissionsOrganizationRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetGithubActionsPermissionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetGithubActionsPermissionsOrganizationRequest($org, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetGithubActionsPermissionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetGithubActionsPermissionsRepository
     *
     * Get GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions
     */
    public function actionsGetGithubActionsPermissionsRepository($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsRepository'][0])
    {
        list($response) = $this->actionsGetGithubActionsPermissionsRepositoryWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetGithubActionsPermissionsRepositoryWithHttpInfo
     *
     * Get GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetGithubActionsPermissionsRepositoryWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsRepository'][0])
    {
        $request = $this->actionsGetGithubActionsPermissionsRepositoryRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetGithubActionsPermissionsRepositoryAsync
     *
     * Get GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsPermissionsRepositoryAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsRepository'][0])
    {
        return $this->actionsGetGithubActionsPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetGithubActionsPermissionsRepositoryAsyncWithHttpInfo
     *
     * Get GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetGithubActionsPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsRepository'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsRepositoryPermissions';
        $request = $this->actionsGetGithubActionsPermissionsRepositoryRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetGithubActionsPermissionsRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetGithubActionsPermissionsRepositoryRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetGithubActionsPermissionsRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetGithubActionsPermissionsRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetGithubActionsPermissionsRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetJobForWorkflowRun
     *
     * Get a job for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job
     */
    public function actionsGetJobForWorkflowRun($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsGetJobForWorkflowRun'][0])
    {
        list($response) = $this->actionsGetJobForWorkflowRunWithHttpInfo($owner, $repo, $job_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetJobForWorkflowRunWithHttpInfo
     *
     * Get a job for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetJobForWorkflowRunWithHttpInfo($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsGetJobForWorkflowRun'][0])
    {
        $request = $this->actionsGetJobForWorkflowRunRequest($owner, $repo, $job_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetJobForWorkflowRunAsync
     *
     * Get a job for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetJobForWorkflowRunAsync($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsGetJobForWorkflowRun'][0])
    {
        return $this->actionsGetJobForWorkflowRunAsyncWithHttpInfo($owner, $repo, $job_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetJobForWorkflowRunAsyncWithHttpInfo
     *
     * Get a job for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetJobForWorkflowRunAsyncWithHttpInfo($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsGetJobForWorkflowRun'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Job';
        $request = $this->actionsGetJobForWorkflowRunRequest($owner, $repo, $job_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetJobForWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetJobForWorkflowRunRequest($owner, $repo, $job_id, string $contentType = self::contentTypes['actionsGetJobForWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetJobForWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetJobForWorkflowRun'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling actionsGetJobForWorkflowRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/jobs/{job_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'job_id' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetOrgPublicKey
     *
     * Get an organization public key
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgPublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey
     */
    public function actionsGetOrgPublicKey($org, string $contentType = self::contentTypes['actionsGetOrgPublicKey'][0])
    {
        list($response) = $this->actionsGetOrgPublicKeyWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetOrgPublicKeyWithHttpInfo
     *
     * Get an organization public key
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgPublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetOrgPublicKeyWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetOrgPublicKey'][0])
    {
        $request = $this->actionsGetOrgPublicKeyRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetOrgPublicKeyAsync
     *
     * Get an organization public key
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetOrgPublicKeyAsync($org, string $contentType = self::contentTypes['actionsGetOrgPublicKey'][0])
    {
        return $this->actionsGetOrgPublicKeyAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetOrgPublicKeyAsyncWithHttpInfo
     *
     * Get an organization public key
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetOrgPublicKeyAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsGetOrgPublicKey'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey';
        $request = $this->actionsGetOrgPublicKeyRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetOrgPublicKey'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetOrgPublicKeyRequest($org, string $contentType = self::contentTypes['actionsGetOrgPublicKey'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetOrgPublicKey'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/public-key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetOrgSecret
     *
     * Get an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret
     */
    public function actionsGetOrgSecret($org, $secret_name, string $contentType = self::contentTypes['actionsGetOrgSecret'][0])
    {
        list($response) = $this->actionsGetOrgSecretWithHttpInfo($org, $secret_name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetOrgSecretWithHttpInfo
     *
     * Get an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetOrgSecretWithHttpInfo($org, $secret_name, string $contentType = self::contentTypes['actionsGetOrgSecret'][0])
    {
        $request = $this->actionsGetOrgSecretRequest($org, $secret_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetOrgSecretAsync
     *
     * Get an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetOrgSecretAsync($org, $secret_name, string $contentType = self::contentTypes['actionsGetOrgSecret'][0])
    {
        return $this->actionsGetOrgSecretAsyncWithHttpInfo($org, $secret_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetOrgSecretAsyncWithHttpInfo
     *
     * Get an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetOrgSecretAsyncWithHttpInfo($org, $secret_name, string $contentType = self::contentTypes['actionsGetOrgSecret'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsSecret';
        $request = $this->actionsGetOrgSecretRequest($org, $secret_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetOrgSecretRequest($org, $secret_name, string $contentType = self::contentTypes['actionsGetOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsGetOrgSecret'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetOrgVariable
     *
     * Get an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable
     */
    public function actionsGetOrgVariable($org, $name, string $contentType = self::contentTypes['actionsGetOrgVariable'][0])
    {
        list($response) = $this->actionsGetOrgVariableWithHttpInfo($org, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetOrgVariableWithHttpInfo
     *
     * Get an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetOrgVariableWithHttpInfo($org, $name, string $contentType = self::contentTypes['actionsGetOrgVariable'][0])
    {
        $request = $this->actionsGetOrgVariableRequest($org, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetOrgVariableAsync
     *
     * Get an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetOrgVariableAsync($org, $name, string $contentType = self::contentTypes['actionsGetOrgVariable'][0])
    {
        return $this->actionsGetOrgVariableAsyncWithHttpInfo($org, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetOrgVariableAsyncWithHttpInfo
     *
     * Get an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetOrgVariableAsyncWithHttpInfo($org, $name, string $contentType = self::contentTypes['actionsGetOrgVariable'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationActionsVariable';
        $request = $this->actionsGetOrgVariableRequest($org, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetOrgVariableRequest($org, $name, string $contentType = self::contentTypes['actionsGetOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsGetOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetPendingDeploymentsForRun
     *
     * Get pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]
     */
    public function actionsGetPendingDeploymentsForRun($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetPendingDeploymentsForRun'][0])
    {
        list($response) = $this->actionsGetPendingDeploymentsForRunWithHttpInfo($owner, $repo, $run_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetPendingDeploymentsForRunWithHttpInfo
     *
     * Get pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetPendingDeploymentsForRunWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetPendingDeploymentsForRun'][0])
    {
        $request = $this->actionsGetPendingDeploymentsForRunRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetPendingDeploymentsForRunAsync
     *
     * Get pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetPendingDeploymentsForRunAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetPendingDeploymentsForRun'][0])
    {
        return $this->actionsGetPendingDeploymentsForRunAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetPendingDeploymentsForRunAsyncWithHttpInfo
     *
     * Get pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetPendingDeploymentsForRunAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetPendingDeploymentsForRun'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PendingDeployment[]';
        $request = $this->actionsGetPendingDeploymentsForRunRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetPendingDeploymentsForRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetPendingDeploymentsForRunRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetPendingDeploymentsForRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetPendingDeploymentsForRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetPendingDeploymentsForRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsGetPendingDeploymentsForRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetRepoPublicKey
     *
     * Get a repository public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoPublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey
     */
    public function actionsGetRepoPublicKey($owner, $repo, string $contentType = self::contentTypes['actionsGetRepoPublicKey'][0])
    {
        list($response) = $this->actionsGetRepoPublicKeyWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetRepoPublicKeyWithHttpInfo
     *
     * Get a repository public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoPublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetRepoPublicKeyWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetRepoPublicKey'][0])
    {
        $request = $this->actionsGetRepoPublicKeyRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetRepoPublicKeyAsync
     *
     * Get a repository public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetRepoPublicKeyAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetRepoPublicKey'][0])
    {
        return $this->actionsGetRepoPublicKeyAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetRepoPublicKeyAsyncWithHttpInfo
     *
     * Get a repository public key
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetRepoPublicKeyAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetRepoPublicKey'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsPublicKey';
        $request = $this->actionsGetRepoPublicKeyRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetRepoPublicKey'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoPublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetRepoPublicKeyRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetRepoPublicKey'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetRepoPublicKey'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetRepoPublicKey'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/secrets/public-key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetRepoSecret
     *
     * Get a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret
     */
    public function actionsGetRepoSecret($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsGetRepoSecret'][0])
    {
        list($response) = $this->actionsGetRepoSecretWithHttpInfo($owner, $repo, $secret_name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetRepoSecretWithHttpInfo
     *
     * Get a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetRepoSecretWithHttpInfo($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsGetRepoSecret'][0])
    {
        $request = $this->actionsGetRepoSecretRequest($owner, $repo, $secret_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetRepoSecretAsync
     *
     * Get a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetRepoSecretAsync($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsGetRepoSecret'][0])
    {
        return $this->actionsGetRepoSecretAsyncWithHttpInfo($owner, $repo, $secret_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetRepoSecretAsyncWithHttpInfo
     *
     * Get a repository secret
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetRepoSecretAsyncWithHttpInfo($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsGetRepoSecret'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSecret';
        $request = $this->actionsGetRepoSecretRequest($owner, $repo, $secret_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetRepoSecret'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetRepoSecretRequest($owner, $repo, $secret_name, string $contentType = self::contentTypes['actionsGetRepoSecret'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetRepoSecret'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetRepoSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsGetRepoSecret'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/secrets/{secret_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetRepoVariable
     *
     * Get a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable
     */
    public function actionsGetRepoVariable($owner, $repo, $name, string $contentType = self::contentTypes['actionsGetRepoVariable'][0])
    {
        list($response) = $this->actionsGetRepoVariableWithHttpInfo($owner, $repo, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetRepoVariableWithHttpInfo
     *
     * Get a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetRepoVariableWithHttpInfo($owner, $repo, $name, string $contentType = self::contentTypes['actionsGetRepoVariable'][0])
    {
        $request = $this->actionsGetRepoVariableRequest($owner, $repo, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetRepoVariableAsync
     *
     * Get a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetRepoVariableAsync($owner, $repo, $name, string $contentType = self::contentTypes['actionsGetRepoVariable'][0])
    {
        return $this->actionsGetRepoVariableAsyncWithHttpInfo($owner, $repo, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetRepoVariableAsyncWithHttpInfo
     *
     * Get a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetRepoVariableAsyncWithHttpInfo($owner, $repo, $name, string $contentType = self::contentTypes['actionsGetRepoVariable'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsVariable';
        $request = $this->actionsGetRepoVariableRequest($owner, $repo, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetRepoVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetRepoVariableRequest($owner, $repo, $name, string $contentType = self::contentTypes['actionsGetRepoVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetRepoVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetRepoVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsGetRepoVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetReviewsForRun
     *
     * Get the review history for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetReviewsForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]
     */
    public function actionsGetReviewsForRun($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetReviewsForRun'][0])
    {
        list($response) = $this->actionsGetReviewsForRunWithHttpInfo($owner, $repo, $run_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetReviewsForRunWithHttpInfo
     *
     * Get the review history for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetReviewsForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[], HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetReviewsForRunWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetReviewsForRun'][0])
    {
        $request = $this->actionsGetReviewsForRunRequest($owner, $repo, $run_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetReviewsForRunAsync
     *
     * Get the review history for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetReviewsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetReviewsForRunAsync($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetReviewsForRun'][0])
    {
        return $this->actionsGetReviewsForRunAsyncWithHttpInfo($owner, $repo, $run_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetReviewsForRunAsyncWithHttpInfo
     *
     * Get the review history for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetReviewsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetReviewsForRunAsyncWithHttpInfo($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetReviewsForRun'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnvironmentApprovals[]';
        $request = $this->actionsGetReviewsForRunRequest($owner, $repo, $run_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetReviewsForRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetReviewsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetReviewsForRunRequest($owner, $repo, $run_id, string $contentType = self::contentTypes['actionsGetReviewsForRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetReviewsForRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetReviewsForRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsGetReviewsForRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/approvals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetSelfHostedRunnerForOrg
     *
     * Get a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner
     */
    public function actionsGetSelfHostedRunnerForOrg($org, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForOrg'][0])
    {
        list($response) = $this->actionsGetSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetSelfHostedRunnerForOrgWithHttpInfo
     *
     * Get a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForOrg'][0])
    {
        $request = $this->actionsGetSelfHostedRunnerForOrgRequest($org, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetSelfHostedRunnerForOrgAsync
     *
     * Get a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetSelfHostedRunnerForOrgAsync($org, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForOrg'][0])
    {
        return $this->actionsGetSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetSelfHostedRunnerForOrgAsyncWithHttpInfo
     *
     * Get a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner';
        $request = $this->actionsGetSelfHostedRunnerForOrgRequest($org, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetSelfHostedRunnerForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetSelfHostedRunnerForOrgRequest($org, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsGetSelfHostedRunnerForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetSelfHostedRunnerForRepo
     *
     * Get a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner
     */
    public function actionsGetSelfHostedRunnerForRepo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForRepo'][0])
    {
        list($response) = $this->actionsGetSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetSelfHostedRunnerForRepoWithHttpInfo
     *
     * Get a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForRepo'][0])
    {
        $request = $this->actionsGetSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetSelfHostedRunnerForRepoAsync
     *
     * Get a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetSelfHostedRunnerForRepoAsync($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForRepo'][0])
    {
        return $this->actionsGetSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetSelfHostedRunnerForRepoAsyncWithHttpInfo
     *
     * Get a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner';
        $request = $this->actionsGetSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetSelfHostedRunnerForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsGetSelfHostedRunnerForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetSelfHostedRunnerGroupForOrg
     *
     * Get a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg
     */
    public function actionsGetSelfHostedRunnerGroupForOrg($org, $runner_group_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'][0])
    {
        list($response) = $this->actionsGetSelfHostedRunnerGroupForOrgWithHttpInfo($org, $runner_group_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetSelfHostedRunnerGroupForOrgWithHttpInfo
     *
     * Get a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetSelfHostedRunnerGroupForOrgWithHttpInfo($org, $runner_group_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'][0])
    {
        $request = $this->actionsGetSelfHostedRunnerGroupForOrgRequest($org, $runner_group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetSelfHostedRunnerGroupForOrgAsync
     *
     * Get a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetSelfHostedRunnerGroupForOrgAsync($org, $runner_group_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'][0])
    {
        return $this->actionsGetSelfHostedRunnerGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetSelfHostedRunnerGroupForOrgAsyncWithHttpInfo
     *
     * Get a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetSelfHostedRunnerGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg';
        $request = $this->actionsGetSelfHostedRunnerGroupForOrgRequest($org, $runner_group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetSelfHostedRunnerGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetSelfHostedRunnerGroupForOrgRequest($org, $runner_group_id, string $contentType = self::contentTypes['actionsGetSelfHostedRunnerGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsGetSelfHostedRunnerGroupForOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsGetSelfHostedRunnerGroupForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetWorkflow
     *
     * Get a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow
     */
    public function actionsGetWorkflow($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsGetWorkflow'][0])
    {
        list($response) = $this->actionsGetWorkflowWithHttpInfo($owner, $repo, $workflow_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetWorkflowWithHttpInfo
     *
     * Get a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetWorkflowWithHttpInfo($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsGetWorkflow'][0])
    {
        $request = $this->actionsGetWorkflowRequest($owner, $repo, $workflow_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetWorkflowAsync
     *
     * Get a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowAsync($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsGetWorkflow'][0])
    {
        return $this->actionsGetWorkflowAsyncWithHttpInfo($owner, $repo, $workflow_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetWorkflowAsyncWithHttpInfo
     *
     * Get a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowAsyncWithHttpInfo($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsGetWorkflow'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Workflow';
        $request = $this->actionsGetWorkflowRequest($owner, $repo, $workflow_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetWorkflow'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetWorkflowRequest($owner, $repo, $workflow_id, string $contentType = self::contentTypes['actionsGetWorkflow'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetWorkflow'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetWorkflow'
            );
        }

        // verify the required parameter 'workflow_id' is set
        if ($workflow_id === null || (is_array($workflow_id) && count($workflow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workflow_id when calling actionsGetWorkflow'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/workflows/{workflow_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($workflow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow_id' . '}',
                ObjectSerializer::toPathValue($workflow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetWorkflowAccessToRepository
     *
     * Get the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository
     */
    public function actionsGetWorkflowAccessToRepository($owner, $repo, string $contentType = self::contentTypes['actionsGetWorkflowAccessToRepository'][0])
    {
        list($response) = $this->actionsGetWorkflowAccessToRepositoryWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetWorkflowAccessToRepositoryWithHttpInfo
     *
     * Get the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetWorkflowAccessToRepositoryWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetWorkflowAccessToRepository'][0])
    {
        $request = $this->actionsGetWorkflowAccessToRepositoryRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetWorkflowAccessToRepositoryAsync
     *
     * Get the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowAccessToRepositoryAsync($owner, $repo, string $contentType = self::contentTypes['actionsGetWorkflowAccessToRepository'][0])
    {
        return $this->actionsGetWorkflowAccessToRepositoryAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetWorkflowAccessToRepositoryAsyncWithHttpInfo
     *
     * Get the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowAccessToRepositoryAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsGetWorkflowAccessToRepository'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository';
        $request = $this->actionsGetWorkflowAccessToRepositoryRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetWorkflowAccessToRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetWorkflowAccessToRepositoryRequest($owner, $repo, string $contentType = self::contentTypes['actionsGetWorkflowAccessToRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetWorkflowAccessToRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetWorkflowAccessToRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions/access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetWorkflowRun
     *
     * Get a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun
     */
    public function actionsGetWorkflowRun($owner, $repo, $run_id, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRun'][0])
    {
        list($response) = $this->actionsGetWorkflowRunWithHttpInfo($owner, $repo, $run_id, $exclude_pull_requests, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetWorkflowRunWithHttpInfo
     *
     * Get a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetWorkflowRunWithHttpInfo($owner, $repo, $run_id, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRun'][0])
    {
        $request = $this->actionsGetWorkflowRunRequest($owner, $repo, $run_id, $exclude_pull_requests, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetWorkflowRunAsync
     *
     * Get a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowRunAsync($owner, $repo, $run_id, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRun'][0])
    {
        return $this->actionsGetWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $exclude_pull_requests, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetWorkflowRunAsyncWithHttpInfo
     *
     * Get a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRun'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun';
        $request = $this->actionsGetWorkflowRunRequest($owner, $repo, $run_id, $exclude_pull_requests, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetWorkflowRunRequest($owner, $repo, $run_id, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetWorkflowRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsGetWorkflowRun'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_pull_requests,
            'exclude_pull_requests', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsGetWorkflowRunAttempt
     *
     * Get a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun
     */
    public function actionsGetWorkflowRunAttempt($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRunAttempt'][0])
    {
        list($response) = $this->actionsGetWorkflowRunAttemptWithHttpInfo($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests, $contentType);
        return $response;
    }

    /**
     * Operation actionsGetWorkflowRunAttemptWithHttpInfo
     *
     * Get a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsGetWorkflowRunAttemptWithHttpInfo($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRunAttempt'][0])
    {
        $request = $this->actionsGetWorkflowRunAttemptRequest($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsGetWorkflowRunAttemptAsync
     *
     * Get a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowRunAttemptAsync($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRunAttempt'][0])
    {
        return $this->actionsGetWorkflowRunAttemptAsyncWithHttpInfo($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsGetWorkflowRunAttemptAsyncWithHttpInfo
     *
     * Get a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsGetWorkflowRunAttemptAsyncWithHttpInfo($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRunAttempt'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\WorkflowRun';
        $request = $this->actionsGetWorkflowRunAttemptRequest($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsGetWorkflowRunAttempt'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsGetWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsGetWorkflowRunAttemptRequest($owner, $repo, $run_id, $attempt_number, $exclude_pull_requests = false, string $contentType = self::contentTypes['actionsGetWorkflowRunAttempt'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsGetWorkflowRunAttempt'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsGetWorkflowRunAttempt'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsGetWorkflowRunAttempt'
            );
        }

        // verify the required parameter 'attempt_number' is set
        if ($attempt_number === null || (is_array($attempt_number) && count($attempt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attempt_number when calling actionsGetWorkflowRunAttempt'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_pull_requests,
            'exclude_pull_requests', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }
        // path params
        if ($attempt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'attempt_number' . '}',
                ObjectSerializer::toPathValue($attempt_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListArtifactsForRepo
     *
     * List artifacts for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListArtifactsForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response
     */
    public function actionsListArtifactsForRepo($owner, $repo, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListArtifactsForRepo'][0])
    {
        list($response) = $this->actionsListArtifactsForRepoWithHttpInfo($owner, $repo, $per_page, $page, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsListArtifactsForRepoWithHttpInfo
     *
     * List artifacts for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListArtifactsForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListArtifactsForRepoWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListArtifactsForRepo'][0])
    {
        $request = $this->actionsListArtifactsForRepoRequest($owner, $repo, $per_page, $page, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListArtifactsForRepoAsync
     *
     * List artifacts for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListArtifactsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListArtifactsForRepoAsync($owner, $repo, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListArtifactsForRepo'][0])
    {
        return $this->actionsListArtifactsForRepoAsyncWithHttpInfo($owner, $repo, $per_page, $page, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListArtifactsForRepoAsyncWithHttpInfo
     *
     * List artifacts for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListArtifactsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListArtifactsForRepoAsyncWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListArtifactsForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response';
        $request = $this->actionsListArtifactsForRepoRequest($owner, $repo, $per_page, $page, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListArtifactsForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListArtifactsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListArtifactsForRepoRequest($owner, $repo, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListArtifactsForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListArtifactsForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListArtifactsForRepo'
            );
        }





        $resourcePath = '/repos/{owner}/{repo}/actions/artifacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListEnvironmentSecrets
     *
     * List environment secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response
     */
    public function actionsListEnvironmentSecrets($owner, $repo, $environment_name, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentSecrets'][0])
    {
        list($response) = $this->actionsListEnvironmentSecretsWithHttpInfo($owner, $repo, $environment_name, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListEnvironmentSecretsWithHttpInfo
     *
     * List environment secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListEnvironmentSecretsWithHttpInfo($owner, $repo, $environment_name, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentSecrets'][0])
    {
        $request = $this->actionsListEnvironmentSecretsRequest($owner, $repo, $environment_name, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListEnvironmentSecretsAsync
     *
     * List environment secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListEnvironmentSecretsAsync($owner, $repo, $environment_name, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentSecrets'][0])
    {
        return $this->actionsListEnvironmentSecretsAsyncWithHttpInfo($owner, $repo, $environment_name, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListEnvironmentSecretsAsyncWithHttpInfo
     *
     * List environment secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListEnvironmentSecretsAsyncWithHttpInfo($owner, $repo, $environment_name, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentSecrets'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response';
        $request = $this->actionsListEnvironmentSecretsRequest($owner, $repo, $environment_name, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListEnvironmentSecrets'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListEnvironmentSecretsRequest($owner, $repo, $environment_name, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentSecrets'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListEnvironmentSecrets'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListEnvironmentSecrets'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsListEnvironmentSecrets'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListEnvironmentVariables
     *
     * List environment variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response
     */
    public function actionsListEnvironmentVariables($owner, $repo, $environment_name, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentVariables'][0])
    {
        list($response) = $this->actionsListEnvironmentVariablesWithHttpInfo($owner, $repo, $environment_name, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListEnvironmentVariablesWithHttpInfo
     *
     * List environment variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListEnvironmentVariablesWithHttpInfo($owner, $repo, $environment_name, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentVariables'][0])
    {
        $request = $this->actionsListEnvironmentVariablesRequest($owner, $repo, $environment_name, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListEnvironmentVariablesAsync
     *
     * List environment variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListEnvironmentVariablesAsync($owner, $repo, $environment_name, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentVariables'][0])
    {
        return $this->actionsListEnvironmentVariablesAsyncWithHttpInfo($owner, $repo, $environment_name, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListEnvironmentVariablesAsyncWithHttpInfo
     *
     * List environment variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListEnvironmentVariablesAsyncWithHttpInfo($owner, $repo, $environment_name, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentVariables'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response';
        $request = $this->actionsListEnvironmentVariablesRequest($owner, $repo, $environment_name, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListEnvironmentVariables'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListEnvironmentVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListEnvironmentVariablesRequest($owner, $repo, $environment_name, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListEnvironmentVariables'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListEnvironmentVariables'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListEnvironmentVariables'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsListEnvironmentVariables'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListJobsForWorkflowRun
     *
     * List jobs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $filter Filters jobs by their &#x60;completed_at&#x60; timestamp. &#x60;latest&#x60; returns jobs from the most recent execution of the workflow run. &#x60;all&#x60; returns all jobs for a workflow run, including from old executions of the workflow run. (optional, default to 'latest')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response
     */
    public function actionsListJobsForWorkflowRun($owner, $repo, $run_id, $filter = 'latest', $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRun'][0])
    {
        list($response) = $this->actionsListJobsForWorkflowRunWithHttpInfo($owner, $repo, $run_id, $filter, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListJobsForWorkflowRunWithHttpInfo
     *
     * List jobs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $filter Filters jobs by their &#x60;completed_at&#x60; timestamp. &#x60;latest&#x60; returns jobs from the most recent execution of the workflow run. &#x60;all&#x60; returns all jobs for a workflow run, including from old executions of the workflow run. (optional, default to 'latest')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListJobsForWorkflowRunWithHttpInfo($owner, $repo, $run_id, $filter = 'latest', $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRun'][0])
    {
        $request = $this->actionsListJobsForWorkflowRunRequest($owner, $repo, $run_id, $filter, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListJobsForWorkflowRunAsync
     *
     * List jobs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $filter Filters jobs by their &#x60;completed_at&#x60; timestamp. &#x60;latest&#x60; returns jobs from the most recent execution of the workflow run. &#x60;all&#x60; returns all jobs for a workflow run, including from old executions of the workflow run. (optional, default to 'latest')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListJobsForWorkflowRunAsync($owner, $repo, $run_id, $filter = 'latest', $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRun'][0])
    {
        return $this->actionsListJobsForWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $filter, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListJobsForWorkflowRunAsyncWithHttpInfo
     *
     * List jobs for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $filter Filters jobs by their &#x60;completed_at&#x60; timestamp. &#x60;latest&#x60; returns jobs from the most recent execution of the workflow run. &#x60;all&#x60; returns all jobs for a workflow run, including from old executions of the workflow run. (optional, default to 'latest')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListJobsForWorkflowRunAsyncWithHttpInfo($owner, $repo, $run_id, $filter = 'latest', $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRun'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response';
        $request = $this->actionsListJobsForWorkflowRunRequest($owner, $repo, $run_id, $filter, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListJobsForWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  string $filter Filters jobs by their &#x60;completed_at&#x60; timestamp. &#x60;latest&#x60; returns jobs from the most recent execution of the workflow run. &#x60;all&#x60; returns all jobs for a workflow run, including from old executions of the workflow run. (optional, default to 'latest')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListJobsForWorkflowRunRequest($owner, $repo, $run_id, $filter = 'latest', $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListJobsForWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListJobsForWorkflowRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsListJobsForWorkflowRun'
            );
        }





        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/jobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListJobsForWorkflowRunAttempt
     *
     * List jobs for a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsListJobsForWorkflowRunAttempt($owner, $repo, $run_id, $attempt_number, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRunAttempt'][0])
    {
        list($response) = $this->actionsListJobsForWorkflowRunAttemptWithHttpInfo($owner, $repo, $run_id, $attempt_number, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListJobsForWorkflowRunAttemptWithHttpInfo
     *
     * List jobs for a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListJobsForWorkflowRunAttemptWithHttpInfo($owner, $repo, $run_id, $attempt_number, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRunAttempt'][0])
    {
        $request = $this->actionsListJobsForWorkflowRunAttemptRequest($owner, $repo, $run_id, $attempt_number, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListJobsForWorkflowRunAttemptAsync
     *
     * List jobs for a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListJobsForWorkflowRunAttemptAsync($owner, $repo, $run_id, $attempt_number, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRunAttempt'][0])
    {
        return $this->actionsListJobsForWorkflowRunAttemptAsyncWithHttpInfo($owner, $repo, $run_id, $attempt_number, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListJobsForWorkflowRunAttemptAsyncWithHttpInfo
     *
     * List jobs for a workflow run attempt
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListJobsForWorkflowRunAttemptAsyncWithHttpInfo($owner, $repo, $run_id, $attempt_number, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRunAttempt'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListJobsForWorkflowRunAttempt200Response';
        $request = $this->actionsListJobsForWorkflowRunAttemptRequest($owner, $repo, $run_id, $attempt_number, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListJobsForWorkflowRunAttempt'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $attempt_number The attempt number of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListJobsForWorkflowRunAttempt'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListJobsForWorkflowRunAttemptRequest($owner, $repo, $run_id, $attempt_number, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListJobsForWorkflowRunAttempt'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListJobsForWorkflowRunAttempt'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListJobsForWorkflowRunAttempt'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsListJobsForWorkflowRunAttempt'
            );
        }

        // verify the required parameter 'attempt_number' is set
        if ($attempt_number === null || (is_array($attempt_number) && count($attempt_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attempt_number when calling actionsListJobsForWorkflowRunAttempt'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }
        // path params
        if ($attempt_number !== null) {
            $resourcePath = str_replace(
                '{' . 'attempt_number' . '}',
                ObjectSerializer::toPathValue($attempt_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForOrg
     *
     * List labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsListLabelsForSelfHostedRunnerForOrg($org, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'][0])
    {
        list($response) = $this->actionsListLabelsForSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForOrgWithHttpInfo
     *
     * List labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListLabelsForSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'][0])
    {
        $request = $this->actionsListLabelsForSelfHostedRunnerForOrgRequest($org, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForOrgAsync
     *
     * List labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListLabelsForSelfHostedRunnerForOrgAsync($org, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'][0])
    {
        return $this->actionsListLabelsForSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForOrgAsyncWithHttpInfo
     *
     * List labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListLabelsForSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsListLabelsForSelfHostedRunnerForOrgRequest($org, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListLabelsForSelfHostedRunnerForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListLabelsForSelfHostedRunnerForOrgRequest($org, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListLabelsForSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsListLabelsForSelfHostedRunnerForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForRepo
     *
     * List labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsListLabelsForSelfHostedRunnerForRepo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'][0])
    {
        list($response) = $this->actionsListLabelsForSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForRepoWithHttpInfo
     *
     * List labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListLabelsForSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'][0])
    {
        $request = $this->actionsListLabelsForSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForRepoAsync
     *
     * List labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListLabelsForSelfHostedRunnerForRepoAsync($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'][0])
    {
        return $this->actionsListLabelsForSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListLabelsForSelfHostedRunnerForRepoAsyncWithHttpInfo
     *
     * List labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListLabelsForSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsListLabelsForSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListLabelsForSelfHostedRunnerForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListLabelsForSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsListLabelsForSelfHostedRunnerForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListLabelsForSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListLabelsForSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsListLabelsForSelfHostedRunnerForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListOrgSecrets
     *
     * List organization secrets
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response
     */
    public function actionsListOrgSecrets($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListOrgSecrets'][0])
    {
        list($response) = $this->actionsListOrgSecretsWithHttpInfo($org, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListOrgSecretsWithHttpInfo
     *
     * List organization secrets
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListOrgSecretsWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListOrgSecrets'][0])
    {
        $request = $this->actionsListOrgSecretsRequest($org, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListOrgSecretsAsync
     *
     * List organization secrets
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListOrgSecretsAsync($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListOrgSecrets'][0])
    {
        return $this->actionsListOrgSecretsAsyncWithHttpInfo($org, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListOrgSecretsAsyncWithHttpInfo
     *
     * List organization secrets
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListOrgSecretsAsyncWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListOrgSecrets'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgSecrets200Response';
        $request = $this->actionsListOrgSecretsRequest($org, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListOrgSecrets'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListOrgSecretsRequest($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListOrgSecrets'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListOrgSecrets'
            );
        }




        $resourcePath = '/orgs/{org}/actions/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListOrgVariables
     *
     * List organization variables
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response
     */
    public function actionsListOrgVariables($org, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListOrgVariables'][0])
    {
        list($response) = $this->actionsListOrgVariablesWithHttpInfo($org, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListOrgVariablesWithHttpInfo
     *
     * List organization variables
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListOrgVariablesWithHttpInfo($org, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListOrgVariables'][0])
    {
        $request = $this->actionsListOrgVariablesRequest($org, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListOrgVariablesAsync
     *
     * List organization variables
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListOrgVariablesAsync($org, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListOrgVariables'][0])
    {
        return $this->actionsListOrgVariablesAsyncWithHttpInfo($org, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListOrgVariablesAsyncWithHttpInfo
     *
     * List organization variables
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListOrgVariablesAsyncWithHttpInfo($org, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListOrgVariables'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListOrgVariables200Response';
        $request = $this->actionsListOrgVariablesRequest($org, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListOrgVariables'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListOrgVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListOrgVariablesRequest($org, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListOrgVariables'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListOrgVariables'
            );
        }




        $resourcePath = '/orgs/{org}/actions/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRepoAccessToSelfHostedRunnerGroupInOrg
     *
     * List repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response
     */
    public function actionsListRepoAccessToSelfHostedRunnerGroupInOrg($org, $runner_group_id, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        list($response) = $this->actionsListRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo
     *
     * List repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $request = $this->actionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRepoAccessToSelfHostedRunnerGroupInOrgAsync
     *
     * List repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoAccessToSelfHostedRunnerGroupInOrgAsync($org, $runner_group_id, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        return $this->actionsListRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo
     *
     * List repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200Response';
        $request = $this->actionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRepoAccessToSelfHostedRunnerGroupInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsListRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }




        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRepoOrganizationSecrets
     *
     * List repository organization secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response
     */
    public function actionsListRepoOrganizationSecrets($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationSecrets'][0])
    {
        list($response) = $this->actionsListRepoOrganizationSecretsWithHttpInfo($owner, $repo, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRepoOrganizationSecretsWithHttpInfo
     *
     * List repository organization secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRepoOrganizationSecretsWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationSecrets'][0])
    {
        $request = $this->actionsListRepoOrganizationSecretsRequest($owner, $repo, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRepoOrganizationSecretsAsync
     *
     * List repository organization secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoOrganizationSecretsAsync($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationSecrets'][0])
    {
        return $this->actionsListRepoOrganizationSecretsAsyncWithHttpInfo($owner, $repo, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRepoOrganizationSecretsAsyncWithHttpInfo
     *
     * List repository organization secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoOrganizationSecretsAsyncWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationSecrets'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response';
        $request = $this->actionsListRepoOrganizationSecretsRequest($owner, $repo, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRepoOrganizationSecrets'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRepoOrganizationSecretsRequest($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationSecrets'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListRepoOrganizationSecrets'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListRepoOrganizationSecrets'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/actions/organization-secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRepoOrganizationVariables
     *
     * List repository organization variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response
     */
    public function actionsListRepoOrganizationVariables($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationVariables'][0])
    {
        list($response) = $this->actionsListRepoOrganizationVariablesWithHttpInfo($owner, $repo, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRepoOrganizationVariablesWithHttpInfo
     *
     * List repository organization variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRepoOrganizationVariablesWithHttpInfo($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationVariables'][0])
    {
        $request = $this->actionsListRepoOrganizationVariablesRequest($owner, $repo, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRepoOrganizationVariablesAsync
     *
     * List repository organization variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoOrganizationVariablesAsync($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationVariables'][0])
    {
        return $this->actionsListRepoOrganizationVariablesAsyncWithHttpInfo($owner, $repo, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRepoOrganizationVariablesAsyncWithHttpInfo
     *
     * List repository organization variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoOrganizationVariablesAsyncWithHttpInfo($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationVariables'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response';
        $request = $this->actionsListRepoOrganizationVariablesRequest($owner, $repo, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRepoOrganizationVariables'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoOrganizationVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRepoOrganizationVariablesRequest($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoOrganizationVariables'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListRepoOrganizationVariables'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListRepoOrganizationVariables'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/actions/organization-variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRepoSecrets
     *
     * List repository secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response
     */
    public function actionsListRepoSecrets($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoSecrets'][0])
    {
        list($response) = $this->actionsListRepoSecretsWithHttpInfo($owner, $repo, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRepoSecretsWithHttpInfo
     *
     * List repository secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoSecrets'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRepoSecretsWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoSecrets'][0])
    {
        $request = $this->actionsListRepoSecretsRequest($owner, $repo, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRepoSecretsAsync
     *
     * List repository secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoSecretsAsync($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoSecrets'][0])
    {
        return $this->actionsListRepoSecretsAsyncWithHttpInfo($owner, $repo, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRepoSecretsAsyncWithHttpInfo
     *
     * List repository secrets
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoSecretsAsyncWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoSecrets'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationSecrets200Response';
        $request = $this->actionsListRepoSecretsRequest($owner, $repo, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRepoSecrets'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoSecrets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRepoSecretsRequest($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoSecrets'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListRepoSecrets'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListRepoSecrets'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/actions/secrets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRepoVariables
     *
     * List repository variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response
     */
    public function actionsListRepoVariables($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoVariables'][0])
    {
        list($response) = $this->actionsListRepoVariablesWithHttpInfo($owner, $repo, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRepoVariablesWithHttpInfo
     *
     * List repository variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoVariables'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRepoVariablesWithHttpInfo($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoVariables'][0])
    {
        $request = $this->actionsListRepoVariablesRequest($owner, $repo, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRepoVariablesAsync
     *
     * List repository variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoVariablesAsync($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoVariables'][0])
    {
        return $this->actionsListRepoVariablesAsyncWithHttpInfo($owner, $repo, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRepoVariablesAsyncWithHttpInfo
     *
     * List repository variables
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoVariablesAsyncWithHttpInfo($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoVariables'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoOrganizationVariables200Response';
        $request = $this->actionsListRepoVariablesRequest($owner, $repo, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRepoVariables'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 30). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 10)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoVariables'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRepoVariablesRequest($owner, $repo, $per_page = 10, $page = 1, string $contentType = self::contentTypes['actionsListRepoVariables'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListRepoVariables'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListRepoVariables'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/actions/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRepoWorkflows
     *
     * List repository workflows
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoWorkflows'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response
     */
    public function actionsListRepoWorkflows($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoWorkflows'][0])
    {
        list($response) = $this->actionsListRepoWorkflowsWithHttpInfo($owner, $repo, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRepoWorkflowsWithHttpInfo
     *
     * List repository workflows
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoWorkflows'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRepoWorkflowsWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoWorkflows'][0])
    {
        $request = $this->actionsListRepoWorkflowsRequest($owner, $repo, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRepoWorkflowsAsync
     *
     * List repository workflows
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoWorkflowsAsync($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoWorkflows'][0])
    {
        return $this->actionsListRepoWorkflowsAsyncWithHttpInfo($owner, $repo, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRepoWorkflowsAsyncWithHttpInfo
     *
     * List repository workflows
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRepoWorkflowsAsyncWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoWorkflows'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListRepoWorkflows200Response';
        $request = $this->actionsListRepoWorkflowsRequest($owner, $repo, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRepoWorkflows'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRepoWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRepoWorkflowsRequest($owner, $repo, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListRepoWorkflows'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListRepoWorkflows'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListRepoWorkflows'
            );
        }




        $resourcePath = '/repos/{owner}/{repo}/actions/workflows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRunnerApplicationsForOrg
     *
     * List runner applications for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]
     */
    public function actionsListRunnerApplicationsForOrg($org, string $contentType = self::contentTypes['actionsListRunnerApplicationsForOrg'][0])
    {
        list($response) = $this->actionsListRunnerApplicationsForOrgWithHttpInfo($org, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRunnerApplicationsForOrgWithHttpInfo
     *
     * List runner applications for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[], HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRunnerApplicationsForOrgWithHttpInfo($org, string $contentType = self::contentTypes['actionsListRunnerApplicationsForOrg'][0])
    {
        $request = $this->actionsListRunnerApplicationsForOrgRequest($org, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRunnerApplicationsForOrgAsync
     *
     * List runner applications for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRunnerApplicationsForOrgAsync($org, string $contentType = self::contentTypes['actionsListRunnerApplicationsForOrg'][0])
    {
        return $this->actionsListRunnerApplicationsForOrgAsyncWithHttpInfo($org, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRunnerApplicationsForOrgAsyncWithHttpInfo
     *
     * List runner applications for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRunnerApplicationsForOrgAsyncWithHttpInfo($org, string $contentType = self::contentTypes['actionsListRunnerApplicationsForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]';
        $request = $this->actionsListRunnerApplicationsForOrgRequest($org, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRunnerApplicationsForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRunnerApplicationsForOrgRequest($org, string $contentType = self::contentTypes['actionsListRunnerApplicationsForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListRunnerApplicationsForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListRunnerApplicationsForRepo
     *
     * List runner applications for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]
     */
    public function actionsListRunnerApplicationsForRepo($owner, $repo, string $contentType = self::contentTypes['actionsListRunnerApplicationsForRepo'][0])
    {
        list($response) = $this->actionsListRunnerApplicationsForRepoWithHttpInfo($owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation actionsListRunnerApplicationsForRepoWithHttpInfo
     *
     * List runner applications for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[], HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListRunnerApplicationsForRepoWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsListRunnerApplicationsForRepo'][0])
    {
        $request = $this->actionsListRunnerApplicationsForRepoRequest($owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListRunnerApplicationsForRepoAsync
     *
     * List runner applications for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRunnerApplicationsForRepoAsync($owner, $repo, string $contentType = self::contentTypes['actionsListRunnerApplicationsForRepo'][0])
    {
        return $this->actionsListRunnerApplicationsForRepoAsyncWithHttpInfo($owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListRunnerApplicationsForRepoAsyncWithHttpInfo
     *
     * List runner applications for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListRunnerApplicationsForRepoAsyncWithHttpInfo($owner, $repo, string $contentType = self::contentTypes['actionsListRunnerApplicationsForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]';
        $request = $this->actionsListRunnerApplicationsForRepoRequest($owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListRunnerApplicationsForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListRunnerApplicationsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListRunnerApplicationsForRepoRequest($owner, $repo, string $contentType = self::contentTypes['actionsListRunnerApplicationsForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListRunnerApplicationsForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListRunnerApplicationsForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelectedReposForOrgSecret
     *
     * List selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response
     */
    public function actionsListSelectedReposForOrgSecret($org, $secret_name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgSecret'][0])
    {
        list($response) = $this->actionsListSelectedReposForOrgSecretWithHttpInfo($org, $secret_name, $page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelectedReposForOrgSecretWithHttpInfo
     *
     * List selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelectedReposForOrgSecretWithHttpInfo($org, $secret_name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgSecret'][0])
    {
        $request = $this->actionsListSelectedReposForOrgSecretRequest($org, $secret_name, $page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelectedReposForOrgSecretAsync
     *
     * List selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelectedReposForOrgSecretAsync($org, $secret_name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgSecret'][0])
    {
        return $this->actionsListSelectedReposForOrgSecretAsyncWithHttpInfo($org, $secret_name, $page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelectedReposForOrgSecretAsyncWithHttpInfo
     *
     * List selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelectedReposForOrgSecretAsyncWithHttpInfo($org, $secret_name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgSecret'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response';
        $request = $this->actionsListSelectedReposForOrgSecretRequest($org, $secret_name, $page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelectedReposForOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelectedReposForOrgSecretRequest($org, $secret_name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListSelectedReposForOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsListSelectedReposForOrgSecret'
            );
        }




        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelectedReposForOrgVariable
     *
     * List selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response
     */
    public function actionsListSelectedReposForOrgVariable($org, $name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgVariable'][0])
    {
        list($response) = $this->actionsListSelectedReposForOrgVariableWithHttpInfo($org, $name, $page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelectedReposForOrgVariableWithHttpInfo
     *
     * List selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelectedReposForOrgVariableWithHttpInfo($org, $name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgVariable'][0])
    {
        $request = $this->actionsListSelectedReposForOrgVariableRequest($org, $name, $page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelectedReposForOrgVariableAsync
     *
     * List selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelectedReposForOrgVariableAsync($org, $name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgVariable'][0])
    {
        return $this->actionsListSelectedReposForOrgVariableAsyncWithHttpInfo($org, $name, $page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelectedReposForOrgVariableAsyncWithHttpInfo
     *
     * List selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelectedReposForOrgVariableAsyncWithHttpInfo($org, $name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgVariable'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedReposForOrgSecret200Response';
        $request = $this->actionsListSelectedReposForOrgVariableRequest($org, $name, $page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelectedReposForOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelectedReposForOrgVariableRequest($org, $name, $page = 1, $per_page = 30, string $contentType = self::contentTypes['actionsListSelectedReposForOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListSelectedReposForOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsListSelectedReposForOrgVariable'
            );
        }




        $resourcePath = '/orgs/{org}/actions/variables/{name}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelectedRepositoriesEnabledGithubActionsOrganization
     *
     * List selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response
     */
    public function actionsListSelectedRepositoriesEnabledGithubActionsOrganization($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        list($response) = $this->actionsListSelectedRepositoriesEnabledGithubActionsOrganizationWithHttpInfo($org, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelectedRepositoriesEnabledGithubActionsOrganizationWithHttpInfo
     *
     * List selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelectedRepositoriesEnabledGithubActionsOrganizationWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        $request = $this->actionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest($org, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelectedRepositoriesEnabledGithubActionsOrganizationAsync
     *
     * List selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelectedRepositoriesEnabledGithubActionsOrganizationAsync($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        return $this->actionsListSelectedRepositoriesEnabledGithubActionsOrganizationAsyncWithHttpInfo($org, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelectedRepositoriesEnabledGithubActionsOrganizationAsyncWithHttpInfo
     *
     * List selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelectedRepositoriesEnabledGithubActionsOrganizationAsyncWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200Response';
        $request = $this->actionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest($org, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelectedRepositoriesEnabledGithubActionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListSelectedRepositoriesEnabledGithubActionsOrganization'
            );
        }




        $resourcePath = '/orgs/{org}/actions/permissions/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelfHostedRunnerGroupsForOrg
     *
     * List self-hosted runner groups for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_repository Only return runner groups that are allowed to be used by this repository. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response
     */
    public function actionsListSelfHostedRunnerGroupsForOrg($org, $per_page = 30, $page = 1, $visible_to_repository = null, string $contentType = self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'][0])
    {
        list($response) = $this->actionsListSelfHostedRunnerGroupsForOrgWithHttpInfo($org, $per_page, $page, $visible_to_repository, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelfHostedRunnerGroupsForOrgWithHttpInfo
     *
     * List self-hosted runner groups for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_repository Only return runner groups that are allowed to be used by this repository. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelfHostedRunnerGroupsForOrgWithHttpInfo($org, $per_page = 30, $page = 1, $visible_to_repository = null, string $contentType = self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'][0])
    {
        $request = $this->actionsListSelfHostedRunnerGroupsForOrgRequest($org, $per_page, $page, $visible_to_repository, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelfHostedRunnerGroupsForOrgAsync
     *
     * List self-hosted runner groups for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_repository Only return runner groups that are allowed to be used by this repository. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnerGroupsForOrgAsync($org, $per_page = 30, $page = 1, $visible_to_repository = null, string $contentType = self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'][0])
    {
        return $this->actionsListSelfHostedRunnerGroupsForOrgAsyncWithHttpInfo($org, $per_page, $page, $visible_to_repository, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelfHostedRunnerGroupsForOrgAsyncWithHttpInfo
     *
     * List self-hosted runner groups for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_repository Only return runner groups that are allowed to be used by this repository. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnerGroupsForOrgAsyncWithHttpInfo($org, $per_page = 30, $page = 1, $visible_to_repository = null, string $contentType = self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnerGroupsForOrg200Response';
        $request = $this->actionsListSelfHostedRunnerGroupsForOrgRequest($org, $per_page, $page, $visible_to_repository, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelfHostedRunnerGroupsForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_repository Only return runner groups that are allowed to be used by this repository. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelfHostedRunnerGroupsForOrgRequest($org, $per_page = 30, $page = 1, $visible_to_repository = null, string $contentType = self::contentTypes['actionsListSelfHostedRunnerGroupsForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListSelfHostedRunnerGroupsForOrg'
            );
        }





        $resourcePath = '/orgs/{org}/actions/runner-groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visible_to_repository,
            'visible_to_repository', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelfHostedRunnersForOrg
     *
     * List self-hosted runners for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response
     */
    public function actionsListSelfHostedRunnersForOrg($org, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForOrg'][0])
    {
        list($response) = $this->actionsListSelfHostedRunnersForOrgWithHttpInfo($org, $name, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelfHostedRunnersForOrgWithHttpInfo
     *
     * List self-hosted runners for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelfHostedRunnersForOrgWithHttpInfo($org, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForOrg'][0])
    {
        $request = $this->actionsListSelfHostedRunnersForOrgRequest($org, $name, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelfHostedRunnersForOrgAsync
     *
     * List self-hosted runners for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnersForOrgAsync($org, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForOrg'][0])
    {
        return $this->actionsListSelfHostedRunnersForOrgAsyncWithHttpInfo($org, $name, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelfHostedRunnersForOrgAsyncWithHttpInfo
     *
     * List self-hosted runners for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnersForOrgAsyncWithHttpInfo($org, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response';
        $request = $this->actionsListSelfHostedRunnersForOrgRequest($org, $name, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelfHostedRunnersForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelfHostedRunnersForOrgRequest($org, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListSelfHostedRunnersForOrg'
            );
        }





        $resourcePath = '/orgs/{org}/actions/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelfHostedRunnersForRepo
     *
     * List self-hosted runners for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response
     */
    public function actionsListSelfHostedRunnersForRepo($owner, $repo, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForRepo'][0])
    {
        list($response) = $this->actionsListSelfHostedRunnersForRepoWithHttpInfo($owner, $repo, $name, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelfHostedRunnersForRepoWithHttpInfo
     *
     * List self-hosted runners for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelfHostedRunnersForRepoWithHttpInfo($owner, $repo, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForRepo'][0])
    {
        $request = $this->actionsListSelfHostedRunnersForRepoRequest($owner, $repo, $name, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelfHostedRunnersForRepoAsync
     *
     * List self-hosted runners for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnersForRepoAsync($owner, $repo, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForRepo'][0])
    {
        return $this->actionsListSelfHostedRunnersForRepoAsyncWithHttpInfo($owner, $repo, $name, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelfHostedRunnersForRepoAsyncWithHttpInfo
     *
     * List self-hosted runners for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnersForRepoAsyncWithHttpInfo($owner, $repo, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListSelfHostedRunnersForOrg200Response';
        $request = $this->actionsListSelfHostedRunnersForRepoRequest($owner, $repo, $name, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelfHostedRunnersForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelfHostedRunnersForRepoRequest($owner, $repo, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListSelfHostedRunnersForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListSelfHostedRunnersForRepo'
            );
        }





        $resourcePath = '/repos/{owner}/{repo}/actions/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListSelfHostedRunnersInGroupForOrg
     *
     * List self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response
     */
    public function actionsListSelfHostedRunnersInGroupForOrg($org, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'][0])
    {
        list($response) = $this->actionsListSelfHostedRunnersInGroupForOrgWithHttpInfo($org, $runner_group_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation actionsListSelfHostedRunnersInGroupForOrgWithHttpInfo
     *
     * List self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListSelfHostedRunnersInGroupForOrgWithHttpInfo($org, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'][0])
    {
        $request = $this->actionsListSelfHostedRunnersInGroupForOrgRequest($org, $runner_group_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListSelfHostedRunnersInGroupForOrgAsync
     *
     * List self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnersInGroupForOrgAsync($org, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'][0])
    {
        return $this->actionsListSelfHostedRunnersInGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListSelfHostedRunnersInGroupForOrgAsyncWithHttpInfo
     *
     * List self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListSelfHostedRunnersInGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response';
        $request = $this->actionsListSelfHostedRunnersInGroupForOrgRequest($org, $runner_group_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListSelfHostedRunnersInGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListSelfHostedRunnersInGroupForOrgRequest($org, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['actionsListSelfHostedRunnersInGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsListSelfHostedRunnersInGroupForOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsListSelfHostedRunnersInGroupForOrg'
            );
        }




        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListWorkflowRunArtifacts
     *
     * List workflow run artifacts
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunArtifacts'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response
     */
    public function actionsListWorkflowRunArtifacts($owner, $repo, $run_id, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListWorkflowRunArtifacts'][0])
    {
        list($response) = $this->actionsListWorkflowRunArtifactsWithHttpInfo($owner, $repo, $run_id, $per_page, $page, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsListWorkflowRunArtifactsWithHttpInfo
     *
     * List workflow run artifacts
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunArtifacts'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListWorkflowRunArtifactsWithHttpInfo($owner, $repo, $run_id, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListWorkflowRunArtifacts'][0])
    {
        $request = $this->actionsListWorkflowRunArtifactsRequest($owner, $repo, $run_id, $per_page, $page, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListWorkflowRunArtifactsAsync
     *
     * List workflow run artifacts
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunArtifacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListWorkflowRunArtifactsAsync($owner, $repo, $run_id, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListWorkflowRunArtifacts'][0])
    {
        return $this->actionsListWorkflowRunArtifactsAsyncWithHttpInfo($owner, $repo, $run_id, $per_page, $page, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListWorkflowRunArtifactsAsyncWithHttpInfo
     *
     * List workflow run artifacts
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunArtifacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListWorkflowRunArtifactsAsyncWithHttpInfo($owner, $repo, $run_id, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListWorkflowRunArtifacts'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListArtifactsForRepo200Response';
        $request = $this->actionsListWorkflowRunArtifactsRequest($owner, $repo, $run_id, $per_page, $page, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListWorkflowRunArtifacts'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $name The name field of an artifact. When specified, only artifacts with this name will be returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunArtifacts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListWorkflowRunArtifactsRequest($owner, $repo, $run_id, $per_page = 30, $page = 1, $name = null, string $contentType = self::contentTypes['actionsListWorkflowRunArtifacts'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListWorkflowRunArtifacts'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListWorkflowRunArtifacts'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsListWorkflowRunArtifacts'
            );
        }





        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListWorkflowRuns
     *
     * List workflow runs for a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRuns'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response
     */
    public function actionsListWorkflowRuns($owner, $repo, $workflow_id, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRuns'][0])
    {
        list($response) = $this->actionsListWorkflowRunsWithHttpInfo($owner, $repo, $workflow_id, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType);
        return $response;
    }

    /**
     * Operation actionsListWorkflowRunsWithHttpInfo
     *
     * List workflow runs for a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRuns'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListWorkflowRunsWithHttpInfo($owner, $repo, $workflow_id, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRuns'][0])
    {
        $request = $this->actionsListWorkflowRunsRequest($owner, $repo, $workflow_id, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListWorkflowRunsAsync
     *
     * List workflow runs for a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRuns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListWorkflowRunsAsync($owner, $repo, $workflow_id, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRuns'][0])
    {
        return $this->actionsListWorkflowRunsAsyncWithHttpInfo($owner, $repo, $workflow_id, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListWorkflowRunsAsyncWithHttpInfo
     *
     * List workflow runs for a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRuns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListWorkflowRunsAsyncWithHttpInfo($owner, $repo, $workflow_id, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRuns'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response';
        $request = $this->actionsListWorkflowRunsRequest($owner, $repo, $workflow_id, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListWorkflowRuns'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  ActionsGetWorkflowWorkflowIdParameter $workflow_id The ID of the workflow. You can also pass the workflow file name as a string. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRuns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListWorkflowRunsRequest($owner, $repo, $workflow_id, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRuns'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListWorkflowRuns'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListWorkflowRuns'
            );
        }

        // verify the required parameter 'workflow_id' is set
        if ($workflow_id === null || (is_array($workflow_id) && count($workflow_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $workflow_id when calling actionsListWorkflowRuns'
            );
        }












        $resourcePath = '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $actor,
            'actor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $branch,
            'branch', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event,
            'event', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_pull_requests,
            'exclude_pull_requests', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $check_suite_id,
            'check_suite_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $head_sha,
            'head_sha', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($workflow_id !== null) {
            $resourcePath = str_replace(
                '{' . 'workflow_id' . '}',
                ObjectSerializer::toPathValue($workflow_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsListWorkflowRunsForRepo
     *
     * List workflow runs for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunsForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response
     */
    public function actionsListWorkflowRunsForRepo($owner, $repo, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRunsForRepo'][0])
    {
        list($response) = $this->actionsListWorkflowRunsForRepoWithHttpInfo($owner, $repo, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType);
        return $response;
    }

    /**
     * Operation actionsListWorkflowRunsForRepoWithHttpInfo
     *
     * List workflow runs for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunsForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsListWorkflowRunsForRepoWithHttpInfo($owner, $repo, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRunsForRepo'][0])
    {
        $request = $this->actionsListWorkflowRunsForRepoRequest($owner, $repo, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsListWorkflowRunsForRepoAsync
     *
     * List workflow runs for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListWorkflowRunsForRepoAsync($owner, $repo, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRunsForRepo'][0])
    {
        return $this->actionsListWorkflowRunsForRepoAsyncWithHttpInfo($owner, $repo, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsListWorkflowRunsForRepoAsyncWithHttpInfo
     *
     * List workflow runs for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsListWorkflowRunsForRepoAsyncWithHttpInfo($owner, $repo, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRunsForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsListWorkflowRunsForRepo200Response';
        $request = $this->actionsListWorkflowRunsForRepoRequest($owner, $repo, $actor, $branch, $event, $status, $per_page, $page, $created, $exclude_pull_requests, $check_suite_id, $head_sha, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsListWorkflowRunsForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $actor Returns someone&#39;s workflow runs. Use the login for the user who created the &#x60;push&#x60; associated with the check suite or workflow run. (optional)
     * @param  string $branch Returns workflow runs associated with a branch. Use the name of the branch of the &#x60;push&#x60;. (optional)
     * @param  string $event Returns workflow run triggered by the event you specify. For example, &#x60;push&#x60;, &#x60;pull_request&#x60; or &#x60;issue&#x60;. For more information, see \&quot;[Events that trigger workflows](https://docs.github.com/enterprise-server@3.12/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows).\&quot; (optional)
     * @param  string $status Returns workflow runs with the check run &#x60;status&#x60; or &#x60;conclusion&#x60; that you specify. For example, a conclusion can be &#x60;success&#x60; or a status can be &#x60;in_progress&#x60;. Only GitHub Actions can set a status of &#x60;waiting&#x60;, &#x60;pending&#x60;, or &#x60;requested&#x60;. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  \DateTime $created Returns workflow runs created within the given date-time range. For more information on the syntax, see \&quot;[Understanding the search syntax](https://docs.github.com/enterprise-server@3.12/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\&quot; (optional)
     * @param  bool $exclude_pull_requests If &#x60;true&#x60; pull requests are omitted from the response (empty array). (optional, default to false)
     * @param  int $check_suite_id Returns workflow runs with the &#x60;check_suite_id&#x60; that you specify. (optional)
     * @param  string $head_sha Only returns workflow runs that are associated with the specified &#x60;head_sha&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsListWorkflowRunsForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsListWorkflowRunsForRepoRequest($owner, $repo, $actor = null, $branch = null, $event = null, $status = null, $per_page = 30, $page = 1, $created = null, $exclude_pull_requests = false, $check_suite_id = null, $head_sha = null, string $contentType = self::contentTypes['actionsListWorkflowRunsForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsListWorkflowRunsForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsListWorkflowRunsForRepo'
            );
        }












        $resourcePath = '/repos/{owner}/{repo}/actions/runs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $actor,
            'actor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $branch,
            'branch', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event,
            'event', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created,
            'created', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_pull_requests,
            'exclude_pull_requests', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $check_suite_id,
            'check_suite_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $head_sha,
            'head_sha', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsReRunJobForWorkflowRun
     *
     * Re-run a job from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsReRunJobForWorkflowRun($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunJobForWorkflowRun'][0])
    {
        list($response) = $this->actionsReRunJobForWorkflowRunWithHttpInfo($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsReRunJobForWorkflowRunWithHttpInfo
     *
     * Re-run a job from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsReRunJobForWorkflowRunWithHttpInfo($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunJobForWorkflowRun'][0])
    {
        $request = $this->actionsReRunJobForWorkflowRunRequest($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsReRunJobForWorkflowRunAsync
     *
     * Re-run a job from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReRunJobForWorkflowRunAsync($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunJobForWorkflowRun'][0])
    {
        return $this->actionsReRunJobForWorkflowRunAsyncWithHttpInfo($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsReRunJobForWorkflowRunAsyncWithHttpInfo
     *
     * Re-run a job from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReRunJobForWorkflowRunAsyncWithHttpInfo($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunJobForWorkflowRun'][0])
    {
        $returnType = 'object';
        $request = $this->actionsReRunJobForWorkflowRunRequest($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsReRunJobForWorkflowRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $job_id The unique identifier of the job. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunJobForWorkflowRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsReRunJobForWorkflowRunRequest($owner, $repo, $job_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunJobForWorkflowRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsReRunJobForWorkflowRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsReRunJobForWorkflowRun'
            );
        }

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling actionsReRunJobForWorkflowRun'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{' . 'job_id' . '}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_re_run_job_for_workflow_run_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_re_run_job_for_workflow_run_request));
            } else {
                $httpBody = $actions_re_run_job_for_workflow_run_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsReRunWorkflow
     *
     * Re-run a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsReRunWorkflow($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflow'][0])
    {
        list($response) = $this->actionsReRunWorkflowWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsReRunWorkflowWithHttpInfo
     *
     * Re-run a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflow'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsReRunWorkflowWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflow'][0])
    {
        $request = $this->actionsReRunWorkflowRequest($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsReRunWorkflowAsync
     *
     * Re-run a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReRunWorkflowAsync($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflow'][0])
    {
        return $this->actionsReRunWorkflowAsyncWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsReRunWorkflowAsyncWithHttpInfo
     *
     * Re-run a workflow
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReRunWorkflowAsyncWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflow'][0])
    {
        $returnType = 'object';
        $request = $this->actionsReRunWorkflowRequest($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsReRunWorkflow'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflow'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsReRunWorkflowRequest($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflow'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsReRunWorkflow'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsReRunWorkflow'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsReRunWorkflow'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/rerun';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_re_run_job_for_workflow_run_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_re_run_job_for_workflow_run_request));
            } else {
                $httpBody = $actions_re_run_job_for_workflow_run_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsReRunWorkflowFailedJobs
     *
     * Re-run failed jobs from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflowFailedJobs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function actionsReRunWorkflowFailedJobs($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflowFailedJobs'][0])
    {
        list($response) = $this->actionsReRunWorkflowFailedJobsWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsReRunWorkflowFailedJobsWithHttpInfo
     *
     * Re-run failed jobs from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflowFailedJobs'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsReRunWorkflowFailedJobsWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflowFailedJobs'][0])
    {
        $request = $this->actionsReRunWorkflowFailedJobsRequest($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsReRunWorkflowFailedJobsAsync
     *
     * Re-run failed jobs from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflowFailedJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReRunWorkflowFailedJobsAsync($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflowFailedJobs'][0])
    {
        return $this->actionsReRunWorkflowFailedJobsAsyncWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsReRunWorkflowFailedJobsAsyncWithHttpInfo
     *
     * Re-run failed jobs from a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflowFailedJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReRunWorkflowFailedJobsAsyncWithHttpInfo($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflowFailedJobs'][0])
    {
        $returnType = 'object';
        $request = $this->actionsReRunWorkflowFailedJobsRequest($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsReRunWorkflowFailedJobs'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReRunJobForWorkflowRunRequest $actions_re_run_job_for_workflow_run_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReRunWorkflowFailedJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsReRunWorkflowFailedJobsRequest($owner, $repo, $run_id, $actions_re_run_job_for_workflow_run_request = null, string $contentType = self::contentTypes['actionsReRunWorkflowFailedJobs'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsReRunWorkflowFailedJobs'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsReRunWorkflowFailedJobs'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsReRunWorkflowFailedJobs'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_re_run_job_for_workflow_run_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_re_run_job_for_workflow_run_request));
            } else {
                $httpBody = $actions_re_run_job_for_workflow_run_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg
     *
     * Remove all custom labels from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg($org, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'][0])
    {
        list($response) = $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWithHttpInfo
     *
     * Remove all custom labels from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'][0])
    {
        $request = $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest($org, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgAsync
     *
     * Remove all custom labels from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgAsync($org, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'][0])
    {
        return $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgAsyncWithHttpInfo
     *
     * Remove all custom labels from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest($org, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest($org, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo
     *
     * Remove all custom labels from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'][0])
    {
        list($response) = $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWithHttpInfo
     *
     * Remove all custom labels from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'][0])
    {
        $request = $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoAsync
     *
     * Remove all custom labels from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoAsync($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'][0])
    {
        return $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoAsyncWithHttpInfo
     *
     * Remove all custom labels from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, string $contentType = self::contentTypes['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForOrg
     *
     * Remove a custom label from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForOrg($org, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'][0])
    {
        list($response) = $this->actionsRemoveCustomLabelFromSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForOrgWithHttpInfo
     *
     * Remove a custom label from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'][0])
    {
        $request = $this->actionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest($org, $runner_id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForOrgAsync
     *
     * Remove a custom label from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForOrgAsync($org, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'][0])
    {
        return $this->actionsRemoveCustomLabelFromSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForOrgAsyncWithHttpInfo
     *
     * Remove a custom label from a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest($org, $runner_id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest($org, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}/labels/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForRepo
     *
     * Remove a custom label from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForRepo($owner, $repo, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'][0])
    {
        list($response) = $this->actionsRemoveCustomLabelFromSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $name, $contentType);
        return $response;
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForRepoWithHttpInfo
     *
     * Remove a custom label from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'][0])
    {
        $request = $this->actionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForRepoAsync
     *
     * Remove a custom label from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForRepoAsync($owner, $repo, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'][0])
    {
        return $this->actionsRemoveCustomLabelFromSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveCustomLabelFromSelfHostedRunnerForRepoAsyncWithHttpInfo
     *
     * Remove a custom label from a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $name, string $contentType = self::contentTypes['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg
     *
     * Remove repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $this->actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $repository_id, $contentType);
    }

    /**
     * Operation actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo
     *
     * Remove repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $request = $this->actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgAsync
     *
     * Remove repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgAsync($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        return $this->actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo
     *
     * Remove repository access to a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $repository_id The unique identifier of the repository. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $repository_id, string $contentType = self::contentTypes['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgSecret
     *
     * Remove selected repository from an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsRemoveSelectedRepoFromOrgSecret($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'][0])
    {
        $this->actionsRemoveSelectedRepoFromOrgSecretWithHttpInfo($org, $secret_name, $repository_id, $contentType);
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgSecretWithHttpInfo
     *
     * Remove selected repository from an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveSelectedRepoFromOrgSecretWithHttpInfo($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'][0])
    {
        $request = $this->actionsRemoveSelectedRepoFromOrgSecretRequest($org, $secret_name, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgSecretAsync
     *
     * Remove selected repository from an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveSelectedRepoFromOrgSecretAsync($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'][0])
    {
        return $this->actionsRemoveSelectedRepoFromOrgSecretAsyncWithHttpInfo($org, $secret_name, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgSecretAsyncWithHttpInfo
     *
     * Remove selected repository from an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveSelectedRepoFromOrgSecretAsyncWithHttpInfo($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'][0])
    {
        $returnType = '';
        $request = $this->actionsRemoveSelectedRepoFromOrgSecretRequest($org, $secret_name, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveSelectedRepoFromOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveSelectedRepoFromOrgSecretRequest($org, $secret_name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsRemoveSelectedRepoFromOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsRemoveSelectedRepoFromOrgSecret'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsRemoveSelectedRepoFromOrgSecret'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgVariable
     *
     * Remove selected repository from an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsRemoveSelectedRepoFromOrgVariable($org, $name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'][0])
    {
        $this->actionsRemoveSelectedRepoFromOrgVariableWithHttpInfo($org, $name, $repository_id, $contentType);
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgVariableWithHttpInfo
     *
     * Remove selected repository from an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveSelectedRepoFromOrgVariableWithHttpInfo($org, $name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'][0])
    {
        $request = $this->actionsRemoveSelectedRepoFromOrgVariableRequest($org, $name, $repository_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgVariableAsync
     *
     * Remove selected repository from an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveSelectedRepoFromOrgVariableAsync($org, $name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'][0])
    {
        return $this->actionsRemoveSelectedRepoFromOrgVariableAsyncWithHttpInfo($org, $name, $repository_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveSelectedRepoFromOrgVariableAsyncWithHttpInfo
     *
     * Remove selected repository from an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveSelectedRepoFromOrgVariableAsyncWithHttpInfo($org, $name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsRemoveSelectedRepoFromOrgVariableRequest($org, $name, $repository_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveSelectedRepoFromOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  int $repository_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveSelectedRepoFromOrgVariableRequest($org, $name, $repository_id, string $contentType = self::contentTypes['actionsRemoveSelectedRepoFromOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsRemoveSelectedRepoFromOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsRemoveSelectedRepoFromOrgVariable'
            );
        }

        // verify the required parameter 'repository_id' is set
        if ($repository_id === null || (is_array($repository_id) && count($repository_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repository_id when calling actionsRemoveSelectedRepoFromOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables/{name}/repositories/{repository_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($repository_id !== null) {
            $resourcePath = str_replace(
                '{' . 'repository_id' . '}',
                ObjectSerializer::toPathValue($repository_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsRemoveSelfHostedRunnerFromGroupForOrg
     *
     * Remove a self-hosted runner from a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsRemoveSelfHostedRunnerFromGroupForOrg($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'][0])
    {
        $this->actionsRemoveSelfHostedRunnerFromGroupForOrgWithHttpInfo($org, $runner_group_id, $runner_id, $contentType);
    }

    /**
     * Operation actionsRemoveSelfHostedRunnerFromGroupForOrgWithHttpInfo
     *
     * Remove a self-hosted runner from a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsRemoveSelfHostedRunnerFromGroupForOrgWithHttpInfo($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'][0])
    {
        $request = $this->actionsRemoveSelfHostedRunnerFromGroupForOrgRequest($org, $runner_group_id, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsRemoveSelfHostedRunnerFromGroupForOrgAsync
     *
     * Remove a self-hosted runner from a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveSelfHostedRunnerFromGroupForOrgAsync($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'][0])
    {
        return $this->actionsRemoveSelfHostedRunnerFromGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsRemoveSelfHostedRunnerFromGroupForOrgAsyncWithHttpInfo
     *
     * Remove a self-hosted runner from a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsRemoveSelfHostedRunnerFromGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsRemoveSelfHostedRunnerFromGroupForOrgRequest($org, $runner_group_id, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsRemoveSelfHostedRunnerFromGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsRemoveSelfHostedRunnerFromGroupForOrgRequest($org, $runner_group_id, $runner_id, string $contentType = self::contentTypes['actionsRemoveSelfHostedRunnerFromGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsRemoveSelfHostedRunnerFromGroupForOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsRemoveSelfHostedRunnerFromGroupForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsRemoveSelfHostedRunnerFromGroupForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsReviewCustomGatesForRun
     *
     * Review custom deployment protection rules for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewCustomGatesForRunRequest $actions_review_custom_gates_for_run_request actions_review_custom_gates_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewCustomGatesForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsReviewCustomGatesForRun($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, string $contentType = self::contentTypes['actionsReviewCustomGatesForRun'][0])
    {
        $this->actionsReviewCustomGatesForRunWithHttpInfo($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, $contentType);
    }

    /**
     * Operation actionsReviewCustomGatesForRunWithHttpInfo
     *
     * Review custom deployment protection rules for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewCustomGatesForRunRequest $actions_review_custom_gates_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewCustomGatesForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsReviewCustomGatesForRunWithHttpInfo($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, string $contentType = self::contentTypes['actionsReviewCustomGatesForRun'][0])
    {
        $request = $this->actionsReviewCustomGatesForRunRequest($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsReviewCustomGatesForRunAsync
     *
     * Review custom deployment protection rules for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewCustomGatesForRunRequest $actions_review_custom_gates_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewCustomGatesForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReviewCustomGatesForRunAsync($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, string $contentType = self::contentTypes['actionsReviewCustomGatesForRun'][0])
    {
        return $this->actionsReviewCustomGatesForRunAsyncWithHttpInfo($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsReviewCustomGatesForRunAsyncWithHttpInfo
     *
     * Review custom deployment protection rules for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewCustomGatesForRunRequest $actions_review_custom_gates_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewCustomGatesForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReviewCustomGatesForRunAsyncWithHttpInfo($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, string $contentType = self::contentTypes['actionsReviewCustomGatesForRun'][0])
    {
        $returnType = '';
        $request = $this->actionsReviewCustomGatesForRunRequest($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsReviewCustomGatesForRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewCustomGatesForRunRequest $actions_review_custom_gates_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewCustomGatesForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsReviewCustomGatesForRunRequest($owner, $repo, $run_id, $actions_review_custom_gates_for_run_request, string $contentType = self::contentTypes['actionsReviewCustomGatesForRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsReviewCustomGatesForRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsReviewCustomGatesForRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsReviewCustomGatesForRun'
            );
        }

        // verify the required parameter 'actions_review_custom_gates_for_run_request' is set
        if ($actions_review_custom_gates_for_run_request === null || (is_array($actions_review_custom_gates_for_run_request) && count($actions_review_custom_gates_for_run_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_review_custom_gates_for_run_request when calling actionsReviewCustomGatesForRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_review_custom_gates_for_run_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_review_custom_gates_for_run_request));
            } else {
                $httpBody = $actions_review_custom_gates_for_run_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsReviewPendingDeploymentsForRun
     *
     * Review pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewPendingDeploymentsForRunRequest $actions_review_pending_deployments_for_run_request actions_review_pending_deployments_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]
     */
    public function actionsReviewPendingDeploymentsForRun($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, string $contentType = self::contentTypes['actionsReviewPendingDeploymentsForRun'][0])
    {
        list($response) = $this->actionsReviewPendingDeploymentsForRunWithHttpInfo($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsReviewPendingDeploymentsForRunWithHttpInfo
     *
     * Review pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewPendingDeploymentsForRunRequest $actions_review_pending_deployments_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsReviewPendingDeploymentsForRunWithHttpInfo($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, string $contentType = self::contentTypes['actionsReviewPendingDeploymentsForRun'][0])
    {
        $request = $this->actionsReviewPendingDeploymentsForRunRequest($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsReviewPendingDeploymentsForRunAsync
     *
     * Review pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewPendingDeploymentsForRunRequest $actions_review_pending_deployments_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReviewPendingDeploymentsForRunAsync($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, string $contentType = self::contentTypes['actionsReviewPendingDeploymentsForRun'][0])
    {
        return $this->actionsReviewPendingDeploymentsForRunAsyncWithHttpInfo($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsReviewPendingDeploymentsForRunAsyncWithHttpInfo
     *
     * Review pending deployments for a workflow run
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewPendingDeploymentsForRunRequest $actions_review_pending_deployments_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsReviewPendingDeploymentsForRunAsyncWithHttpInfo($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, string $contentType = self::contentTypes['actionsReviewPendingDeploymentsForRun'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Deployment[]';
        $request = $this->actionsReviewPendingDeploymentsForRunRequest($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsReviewPendingDeploymentsForRun'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $run_id The unique identifier of the workflow run. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsReviewPendingDeploymentsForRunRequest $actions_review_pending_deployments_for_run_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsReviewPendingDeploymentsForRun'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsReviewPendingDeploymentsForRunRequest($owner, $repo, $run_id, $actions_review_pending_deployments_for_run_request, string $contentType = self::contentTypes['actionsReviewPendingDeploymentsForRun'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsReviewPendingDeploymentsForRun'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsReviewPendingDeploymentsForRun'
            );
        }

        // verify the required parameter 'run_id' is set
        if ($run_id === null || (is_array($run_id) && count($run_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $run_id when calling actionsReviewPendingDeploymentsForRun'
            );
        }

        // verify the required parameter 'actions_review_pending_deployments_for_run_request' is set
        if ($actions_review_pending_deployments_for_run_request === null || (is_array($actions_review_pending_deployments_for_run_request) && count($actions_review_pending_deployments_for_run_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_review_pending_deployments_for_run_request when calling actionsReviewPendingDeploymentsForRun'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($run_id !== null) {
            $resourcePath = str_replace(
                '{' . 'run_id' . '}',
                ObjectSerializer::toPathValue($run_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_review_pending_deployments_for_run_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_review_pending_deployments_for_run_request));
            } else {
                $httpBody = $actions_review_pending_deployments_for_run_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicy
     *
     * Set GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository $actions_cache_usage_policy_for_repository actions_cache_usage_policy_for_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetActionsCacheUsagePolicy($owner, $repo, $actions_cache_usage_policy_for_repository, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicy'][0])
    {
        $this->actionsSetActionsCacheUsagePolicyWithHttpInfo($owner, $repo, $actions_cache_usage_policy_for_repository, $contentType);
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyWithHttpInfo
     *
     * Set GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository $actions_cache_usage_policy_for_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetActionsCacheUsagePolicyWithHttpInfo($owner, $repo, $actions_cache_usage_policy_for_repository, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicy'][0])
    {
        $request = $this->actionsSetActionsCacheUsagePolicyRequest($owner, $repo, $actions_cache_usage_policy_for_repository, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyAsync
     *
     * Set GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository $actions_cache_usage_policy_for_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetActionsCacheUsagePolicyAsync($owner, $repo, $actions_cache_usage_policy_for_repository, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicy'][0])
    {
        return $this->actionsSetActionsCacheUsagePolicyAsyncWithHttpInfo($owner, $repo, $actions_cache_usage_policy_for_repository, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyAsyncWithHttpInfo
     *
     * Set GitHub Actions cache usage policy for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository $actions_cache_usage_policy_for_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetActionsCacheUsagePolicyAsyncWithHttpInfo($owner, $repo, $actions_cache_usage_policy_for_repository, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicy'][0])
    {
        $returnType = '';
        $request = $this->actionsSetActionsCacheUsagePolicyRequest($owner, $repo, $actions_cache_usage_policy_for_repository, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetActionsCacheUsagePolicy'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyForRepository $actions_cache_usage_policy_for_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetActionsCacheUsagePolicyRequest($owner, $repo, $actions_cache_usage_policy_for_repository, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicy'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetActionsCacheUsagePolicy'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetActionsCacheUsagePolicy'
            );
        }

        // verify the required parameter 'actions_cache_usage_policy_for_repository' is set
        if ($actions_cache_usage_policy_for_repository === null || (is_array($actions_cache_usage_policy_for_repository) && count($actions_cache_usage_policy_for_repository) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_cache_usage_policy_for_repository when calling actionsSetActionsCacheUsagePolicy'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/cache/usage-policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_cache_usage_policy_for_repository)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_cache_usage_policy_for_repository));
            } else {
                $httpBody = $actions_cache_usage_policy_for_repository;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyForEnterprise
     *
     * Set GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise $actions_cache_usage_policy_enterprise actions_cache_usage_policy_enterprise (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetActionsCacheUsagePolicyForEnterprise($enterprise, $actions_cache_usage_policy_enterprise, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'][0])
    {
        $this->actionsSetActionsCacheUsagePolicyForEnterpriseWithHttpInfo($enterprise, $actions_cache_usage_policy_enterprise, $contentType);
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyForEnterpriseWithHttpInfo
     *
     * Set GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise $actions_cache_usage_policy_enterprise (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetActionsCacheUsagePolicyForEnterpriseWithHttpInfo($enterprise, $actions_cache_usage_policy_enterprise, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'][0])
    {
        $request = $this->actionsSetActionsCacheUsagePolicyForEnterpriseRequest($enterprise, $actions_cache_usage_policy_enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyForEnterpriseAsync
     *
     * Set GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise $actions_cache_usage_policy_enterprise (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetActionsCacheUsagePolicyForEnterpriseAsync($enterprise, $actions_cache_usage_policy_enterprise, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'][0])
    {
        return $this->actionsSetActionsCacheUsagePolicyForEnterpriseAsyncWithHttpInfo($enterprise, $actions_cache_usage_policy_enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetActionsCacheUsagePolicyForEnterpriseAsyncWithHttpInfo
     *
     * Set GitHub Actions cache usage policy for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise $actions_cache_usage_policy_enterprise (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetActionsCacheUsagePolicyForEnterpriseAsyncWithHttpInfo($enterprise, $actions_cache_usage_policy_enterprise, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'][0])
    {
        $returnType = '';
        $request = $this->actionsSetActionsCacheUsagePolicyForEnterpriseRequest($enterprise, $actions_cache_usage_policy_enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetActionsCacheUsagePolicyForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsCacheUsagePolicyEnterprise $actions_cache_usage_policy_enterprise (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetActionsCacheUsagePolicyForEnterpriseRequest($enterprise, $actions_cache_usage_policy_enterprise, string $contentType = self::contentTypes['actionsSetActionsCacheUsagePolicyForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling actionsSetActionsCacheUsagePolicyForEnterprise'
            );
        }

        // verify the required parameter 'actions_cache_usage_policy_enterprise' is set
        if ($actions_cache_usage_policy_enterprise === null || (is_array($actions_cache_usage_policy_enterprise) && count($actions_cache_usage_policy_enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_cache_usage_policy_enterprise when calling actionsSetActionsCacheUsagePolicyForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/cache/usage-policy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_cache_usage_policy_enterprise)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_cache_usage_policy_enterprise));
            } else {
                $httpBody = $actions_cache_usage_policy_enterprise;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetAllowedActionsOrganization
     *
     * Set allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetAllowedActionsOrganization($org, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsOrganization'][0])
    {
        $this->actionsSetAllowedActionsOrganizationWithHttpInfo($org, $selected_actions, $contentType);
    }

    /**
     * Operation actionsSetAllowedActionsOrganizationWithHttpInfo
     *
     * Set allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetAllowedActionsOrganizationWithHttpInfo($org, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsOrganization'][0])
    {
        $request = $this->actionsSetAllowedActionsOrganizationRequest($org, $selected_actions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetAllowedActionsOrganizationAsync
     *
     * Set allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetAllowedActionsOrganizationAsync($org, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsOrganization'][0])
    {
        return $this->actionsSetAllowedActionsOrganizationAsyncWithHttpInfo($org, $selected_actions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetAllowedActionsOrganizationAsyncWithHttpInfo
     *
     * Set allowed actions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetAllowedActionsOrganizationAsyncWithHttpInfo($org, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsOrganization'][0])
    {
        $returnType = '';
        $request = $this->actionsSetAllowedActionsOrganizationRequest($org, $selected_actions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetAllowedActionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetAllowedActionsOrganizationRequest($org, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetAllowedActionsOrganization'
            );
        }



        $resourcePath = '/orgs/{org}/actions/permissions/selected-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($selected_actions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($selected_actions));
            } else {
                $httpBody = $selected_actions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetAllowedActionsRepository
     *
     * Set allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetAllowedActionsRepository($owner, $repo, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsRepository'][0])
    {
        $this->actionsSetAllowedActionsRepositoryWithHttpInfo($owner, $repo, $selected_actions, $contentType);
    }

    /**
     * Operation actionsSetAllowedActionsRepositoryWithHttpInfo
     *
     * Set allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetAllowedActionsRepositoryWithHttpInfo($owner, $repo, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsRepository'][0])
    {
        $request = $this->actionsSetAllowedActionsRepositoryRequest($owner, $repo, $selected_actions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetAllowedActionsRepositoryAsync
     *
     * Set allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetAllowedActionsRepositoryAsync($owner, $repo, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsRepository'][0])
    {
        return $this->actionsSetAllowedActionsRepositoryAsyncWithHttpInfo($owner, $repo, $selected_actions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetAllowedActionsRepositoryAsyncWithHttpInfo
     *
     * Set allowed actions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetAllowedActionsRepositoryAsyncWithHttpInfo($owner, $repo, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsRepository'][0])
    {
        $returnType = '';
        $request = $this->actionsSetAllowedActionsRepositoryRequest($owner, $repo, $selected_actions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetAllowedActionsRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetAllowedActionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetAllowedActionsRepositoryRequest($owner, $repo, $selected_actions = null, string $contentType = self::contentTypes['actionsSetAllowedActionsRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetAllowedActionsRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetAllowedActionsRepository'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/actions/permissions/selected-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($selected_actions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($selected_actions));
            } else {
                $httpBody = $selected_actions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForOrg
     *
     * Set custom labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForOrg($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'][0])
    {
        list($response) = $this->actionsSetCustomLabelsForSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForOrgWithHttpInfo
     *
     * Set custom labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForOrgWithHttpInfo($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'][0])
    {
        $request = $this->actionsSetCustomLabelsForSelfHostedRunnerForOrgRequest($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForOrgAsync
     *
     * Set custom labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForOrgAsync($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'][0])
    {
        return $this->actionsSetCustomLabelsForSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForOrgAsyncWithHttpInfo
     *
     * Set custom labels for a self-hosted runner for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForOrgAsyncWithHttpInfo($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsSetCustomLabelsForSelfHostedRunnerForOrgRequest($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetCustomLabelsForSelfHostedRunnerForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForOrgRequest($org, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetCustomLabelsForSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsSetCustomLabelsForSelfHostedRunnerForOrg'
            );
        }

        // verify the required parameter 'enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request' is set
        if ($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request === null || (is_array($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request) && count($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request when calling actionsSetCustomLabelsForSelfHostedRunnerForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForRepo
     *
     * Set custom labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForRepo($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'][0])
    {
        list($response) = $this->actionsSetCustomLabelsForSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForRepoWithHttpInfo
     *
     * Set custom labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForRepoWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'][0])
    {
        $request = $this->actionsSetCustomLabelsForSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForRepoAsync
     *
     * Set custom labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForRepoAsync($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'][0])
    {
        return $this->actionsSetCustomLabelsForSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetCustomLabelsForSelfHostedRunnerForRepoAsyncWithHttpInfo
     *
     * Set custom labels for a self-hosted runner for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForRepoAsyncWithHttpInfo($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->actionsSetCustomLabelsForSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetCustomLabelsForSelfHostedRunnerForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetCustomLabelsForSelfHostedRunnerForRepoRequest($owner, $repo, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['actionsSetCustomLabelsForSelfHostedRunnerForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetCustomLabelsForSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetCustomLabelsForSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling actionsSetCustomLabelsForSelfHostedRunnerForRepo'
            );
        }

        // verify the required parameter 'enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request' is set
        if ($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request === null || (is_array($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request) && count($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request when calling actionsSetCustomLabelsForSelfHostedRunnerForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetCustomOidcSubClaimForRepo
     *
     * Set the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOIDCSubjectCustomizationForARepository $actions_oidc_subject_customization_for_a_repository actions_oidc_subject_customization_for_a_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function actionsSetCustomOidcSubClaimForRepo($owner, $repo, $actions_oidc_subject_customization_for_a_repository, string $contentType = self::contentTypes['actionsSetCustomOidcSubClaimForRepo'][0])
    {
        list($response) = $this->actionsSetCustomOidcSubClaimForRepoWithHttpInfo($owner, $repo, $actions_oidc_subject_customization_for_a_repository, $contentType);
        return $response;
    }

    /**
     * Operation actionsSetCustomOidcSubClaimForRepoWithHttpInfo
     *
     * Set the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOIDCSubjectCustomizationForARepository $actions_oidc_subject_customization_for_a_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetCustomOidcSubClaimForRepoWithHttpInfo($owner, $repo, $actions_oidc_subject_customization_for_a_repository, string $contentType = self::contentTypes['actionsSetCustomOidcSubClaimForRepo'][0])
    {
        $request = $this->actionsSetCustomOidcSubClaimForRepoRequest($owner, $repo, $actions_oidc_subject_customization_for_a_repository, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetCustomOidcSubClaimForRepoAsync
     *
     * Set the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOIDCSubjectCustomizationForARepository $actions_oidc_subject_customization_for_a_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetCustomOidcSubClaimForRepoAsync($owner, $repo, $actions_oidc_subject_customization_for_a_repository, string $contentType = self::contentTypes['actionsSetCustomOidcSubClaimForRepo'][0])
    {
        return $this->actionsSetCustomOidcSubClaimForRepoAsyncWithHttpInfo($owner, $repo, $actions_oidc_subject_customization_for_a_repository, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetCustomOidcSubClaimForRepoAsyncWithHttpInfo
     *
     * Set the customization template for an OIDC subject claim for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOIDCSubjectCustomizationForARepository $actions_oidc_subject_customization_for_a_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetCustomOidcSubClaimForRepoAsyncWithHttpInfo($owner, $repo, $actions_oidc_subject_customization_for_a_repository, string $contentType = self::contentTypes['actionsSetCustomOidcSubClaimForRepo'][0])
    {
        $returnType = 'object';
        $request = $this->actionsSetCustomOidcSubClaimForRepoRequest($owner, $repo, $actions_oidc_subject_customization_for_a_repository, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetCustomOidcSubClaimForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsOIDCSubjectCustomizationForARepository $actions_oidc_subject_customization_for_a_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetCustomOidcSubClaimForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetCustomOidcSubClaimForRepoRequest($owner, $repo, $actions_oidc_subject_customization_for_a_repository, string $contentType = self::contentTypes['actionsSetCustomOidcSubClaimForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetCustomOidcSubClaimForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetCustomOidcSubClaimForRepo'
            );
        }

        // verify the required parameter 'actions_oidc_subject_customization_for_a_repository' is set
        if ($actions_oidc_subject_customization_for_a_repository === null || (is_array($actions_oidc_subject_customization_for_a_repository) && count($actions_oidc_subject_customization_for_a_repository) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_oidc_subject_customization_for_a_repository when calling actionsSetCustomOidcSubClaimForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/oidc/customization/sub';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/scim+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_oidc_subject_customization_for_a_repository)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_oidc_subject_customization_for_a_repository));
            } else {
                $httpBody = $actions_oidc_subject_customization_for_a_repository;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise
     *
     * Set default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise($enterprise, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        $this->actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseWithHttpInfo($enterprise, $actions_set_default_workflow_permissions, $contentType);
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseWithHttpInfo
     *
     * Set default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseWithHttpInfo($enterprise, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        $request = $this->actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest($enterprise, $actions_set_default_workflow_permissions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseAsync
     *
     * Set default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseAsync($enterprise, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        return $this->actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseAsyncWithHttpInfo($enterprise, $actions_set_default_workflow_permissions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseAsyncWithHttpInfo
     *
     * Set default workflow permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseAsyncWithHttpInfo($enterprise, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {
        $returnType = '';
        $request = $this->actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest($enterprise, $actions_set_default_workflow_permissions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest($enterprise, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'
            );
        }

        // verify the required parameter 'actions_set_default_workflow_permissions' is set
        if ($actions_set_default_workflow_permissions === null || (is_array($actions_set_default_workflow_permissions) && count($actions_set_default_workflow_permissions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_default_workflow_permissions when calling actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_default_workflow_permissions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_default_workflow_permissions));
            } else {
                $httpBody = $actions_set_default_workflow_permissions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsOrganization
     *
     * Set default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions actions_set_default_workflow_permissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsOrganization($org, $actions_set_default_workflow_permissions = null, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        $this->actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWithHttpInfo($org, $actions_set_default_workflow_permissions, $contentType);
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWithHttpInfo
     *
     * Set default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWithHttpInfo($org, $actions_set_default_workflow_permissions = null, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        $request = $this->actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest($org, $actions_set_default_workflow_permissions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationAsync
     *
     * Set default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationAsync($org, $actions_set_default_workflow_permissions = null, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        return $this->actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationAsyncWithHttpInfo($org, $actions_set_default_workflow_permissions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationAsyncWithHttpInfo
     *
     * Set default workflow permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationAsyncWithHttpInfo($org, $actions_set_default_workflow_permissions = null, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {
        $returnType = '';
        $request = $this->actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest($org, $actions_set_default_workflow_permissions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest($org, $actions_set_default_workflow_permissions = null, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'
            );
        }



        $resourcePath = '/orgs/{org}/actions/permissions/workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_default_workflow_permissions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_default_workflow_permissions));
            } else {
                $httpBody = $actions_set_default_workflow_permissions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsRepository
     *
     * Set default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsRepository($owner, $repo, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        $this->actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWithHttpInfo($owner, $repo, $actions_set_default_workflow_permissions, $contentType);
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWithHttpInfo
     *
     * Set default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWithHttpInfo($owner, $repo, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        $request = $this->actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest($owner, $repo, $actions_set_default_workflow_permissions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryAsync
     *
     * Set default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryAsync($owner, $repo, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        return $this->actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, $actions_set_default_workflow_permissions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryAsyncWithHttpInfo
     *
     * Set default workflow permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {
        $returnType = '';
        $request = $this->actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest($owner, $repo, $actions_set_default_workflow_permissions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetGithubActionsDefaultWorkflowPermissionsRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetDefaultWorkflowPermissions $actions_set_default_workflow_permissions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest($owner, $repo, $actions_set_default_workflow_permissions, string $contentType = self::contentTypes['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetGithubActionsDefaultWorkflowPermissionsRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetGithubActionsDefaultWorkflowPermissionsRepository'
            );
        }

        // verify the required parameter 'actions_set_default_workflow_permissions' is set
        if ($actions_set_default_workflow_permissions === null || (is_array($actions_set_default_workflow_permissions) && count($actions_set_default_workflow_permissions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_default_workflow_permissions when calling actionsSetGithubActionsDefaultWorkflowPermissionsRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions/workflow';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_default_workflow_permissions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_default_workflow_permissions));
            } else {
                $httpBody = $actions_set_default_workflow_permissions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetGithubActionsPermissionsOrganization
     *
     * Set GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsOrganizationRequest $actions_set_github_actions_permissions_organization_request actions_set_github_actions_permissions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetGithubActionsPermissionsOrganization($org, $actions_set_github_actions_permissions_organization_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsOrganization'][0])
    {
        $this->actionsSetGithubActionsPermissionsOrganizationWithHttpInfo($org, $actions_set_github_actions_permissions_organization_request, $contentType);
    }

    /**
     * Operation actionsSetGithubActionsPermissionsOrganizationWithHttpInfo
     *
     * Set GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsOrganizationRequest $actions_set_github_actions_permissions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetGithubActionsPermissionsOrganizationWithHttpInfo($org, $actions_set_github_actions_permissions_organization_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsOrganization'][0])
    {
        $request = $this->actionsSetGithubActionsPermissionsOrganizationRequest($org, $actions_set_github_actions_permissions_organization_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetGithubActionsPermissionsOrganizationAsync
     *
     * Set GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsOrganizationRequest $actions_set_github_actions_permissions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsPermissionsOrganizationAsync($org, $actions_set_github_actions_permissions_organization_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsOrganization'][0])
    {
        return $this->actionsSetGithubActionsPermissionsOrganizationAsyncWithHttpInfo($org, $actions_set_github_actions_permissions_organization_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetGithubActionsPermissionsOrganizationAsyncWithHttpInfo
     *
     * Set GitHub Actions permissions for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsOrganizationRequest $actions_set_github_actions_permissions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsPermissionsOrganizationAsyncWithHttpInfo($org, $actions_set_github_actions_permissions_organization_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsOrganization'][0])
    {
        $returnType = '';
        $request = $this->actionsSetGithubActionsPermissionsOrganizationRequest($org, $actions_set_github_actions_permissions_organization_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetGithubActionsPermissionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsOrganizationRequest $actions_set_github_actions_permissions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetGithubActionsPermissionsOrganizationRequest($org, $actions_set_github_actions_permissions_organization_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetGithubActionsPermissionsOrganization'
            );
        }

        // verify the required parameter 'actions_set_github_actions_permissions_organization_request' is set
        if ($actions_set_github_actions_permissions_organization_request === null || (is_array($actions_set_github_actions_permissions_organization_request) && count($actions_set_github_actions_permissions_organization_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_github_actions_permissions_organization_request when calling actionsSetGithubActionsPermissionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_github_actions_permissions_organization_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_github_actions_permissions_organization_request));
            } else {
                $httpBody = $actions_set_github_actions_permissions_organization_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetGithubActionsPermissionsRepository
     *
     * Set GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsRepositoryRequest $actions_set_github_actions_permissions_repository_request actions_set_github_actions_permissions_repository_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetGithubActionsPermissionsRepository($owner, $repo, $actions_set_github_actions_permissions_repository_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsRepository'][0])
    {
        $this->actionsSetGithubActionsPermissionsRepositoryWithHttpInfo($owner, $repo, $actions_set_github_actions_permissions_repository_request, $contentType);
    }

    /**
     * Operation actionsSetGithubActionsPermissionsRepositoryWithHttpInfo
     *
     * Set GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsRepositoryRequest $actions_set_github_actions_permissions_repository_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetGithubActionsPermissionsRepositoryWithHttpInfo($owner, $repo, $actions_set_github_actions_permissions_repository_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsRepository'][0])
    {
        $request = $this->actionsSetGithubActionsPermissionsRepositoryRequest($owner, $repo, $actions_set_github_actions_permissions_repository_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetGithubActionsPermissionsRepositoryAsync
     *
     * Set GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsRepositoryRequest $actions_set_github_actions_permissions_repository_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsPermissionsRepositoryAsync($owner, $repo, $actions_set_github_actions_permissions_repository_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsRepository'][0])
    {
        return $this->actionsSetGithubActionsPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, $actions_set_github_actions_permissions_repository_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetGithubActionsPermissionsRepositoryAsyncWithHttpInfo
     *
     * Set GitHub Actions permissions for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsRepositoryRequest $actions_set_github_actions_permissions_repository_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetGithubActionsPermissionsRepositoryAsyncWithHttpInfo($owner, $repo, $actions_set_github_actions_permissions_repository_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsRepository'][0])
    {
        $returnType = '';
        $request = $this->actionsSetGithubActionsPermissionsRepositoryRequest($owner, $repo, $actions_set_github_actions_permissions_repository_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetGithubActionsPermissionsRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetGithubActionsPermissionsRepositoryRequest $actions_set_github_actions_permissions_repository_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetGithubActionsPermissionsRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetGithubActionsPermissionsRepositoryRequest($owner, $repo, $actions_set_github_actions_permissions_repository_request, string $contentType = self::contentTypes['actionsSetGithubActionsPermissionsRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetGithubActionsPermissionsRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetGithubActionsPermissionsRepository'
            );
        }

        // verify the required parameter 'actions_set_github_actions_permissions_repository_request' is set
        if ($actions_set_github_actions_permissions_repository_request === null || (is_array($actions_set_github_actions_permissions_repository_request) && count($actions_set_github_actions_permissions_repository_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_github_actions_permissions_repository_request when calling actionsSetGithubActionsPermissionsRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_github_actions_permissions_repository_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_github_actions_permissions_repository_request));
            } else {
                $httpBody = $actions_set_github_actions_permissions_repository_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetRepoAccessToSelfHostedRunnerGroupInOrg
     *
     * Set repository access for a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest $actions_set_repo_access_to_self_hosted_runner_group_in_org_request actions_set_repo_access_to_self_hosted_runner_group_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetRepoAccessToSelfHostedRunnerGroupInOrg($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, string $contentType = self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $this->actionsSetRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, $contentType);
    }

    /**
     * Operation actionsSetRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo
     *
     * Set repository access for a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest $actions_set_repo_access_to_self_hosted_runner_group_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetRepoAccessToSelfHostedRunnerGroupInOrgWithHttpInfo($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, string $contentType = self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $request = $this->actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetRepoAccessToSelfHostedRunnerGroupInOrgAsync
     *
     * Set repository access for a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest $actions_set_repo_access_to_self_hosted_runner_group_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetRepoAccessToSelfHostedRunnerGroupInOrgAsync($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, string $contentType = self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        return $this->actionsSetRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo
     *
     * Set repository access for a self-hosted runner group in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest $actions_set_repo_access_to_self_hosted_runner_group_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetRepoAccessToSelfHostedRunnerGroupInOrgAsyncWithHttpInfo($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, string $contentType = self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest $actions_set_repo_access_to_self_hosted_runner_group_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest($org, $runner_group_id, $actions_set_repo_access_to_self_hosted_runner_group_in_org_request, string $contentType = self::contentTypes['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }

        // verify the required parameter 'actions_set_repo_access_to_self_hosted_runner_group_in_org_request' is set
        if ($actions_set_repo_access_to_self_hosted_runner_group_in_org_request === null || (is_array($actions_set_repo_access_to_self_hosted_runner_group_in_org_request) && count($actions_set_repo_access_to_self_hosted_runner_group_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_repo_access_to_self_hosted_runner_group_in_org_request when calling actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_repo_access_to_self_hosted_runner_group_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_repo_access_to_self_hosted_runner_group_in_org_request));
            } else {
                $httpBody = $actions_set_repo_access_to_self_hosted_runner_group_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetSelectedReposForOrgSecret
     *
     * Set selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgSecretRequest $actions_set_selected_repos_for_org_secret_request actions_set_selected_repos_for_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetSelectedReposForOrgSecret($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgSecret'][0])
    {
        $this->actionsSetSelectedReposForOrgSecretWithHttpInfo($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, $contentType);
    }

    /**
     * Operation actionsSetSelectedReposForOrgSecretWithHttpInfo
     *
     * Set selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgSecretRequest $actions_set_selected_repos_for_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetSelectedReposForOrgSecretWithHttpInfo($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgSecret'][0])
    {
        $request = $this->actionsSetSelectedReposForOrgSecretRequest($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetSelectedReposForOrgSecretAsync
     *
     * Set selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgSecretRequest $actions_set_selected_repos_for_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelectedReposForOrgSecretAsync($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgSecret'][0])
    {
        return $this->actionsSetSelectedReposForOrgSecretAsyncWithHttpInfo($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetSelectedReposForOrgSecretAsyncWithHttpInfo
     *
     * Set selected repositories for an organization secret
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgSecretRequest $actions_set_selected_repos_for_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelectedReposForOrgSecretAsyncWithHttpInfo($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgSecret'][0])
    {
        $returnType = '';
        $request = $this->actionsSetSelectedReposForOrgSecretRequest($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetSelectedReposForOrgSecret'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $secret_name The name of the secret. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgSecretRequest $actions_set_selected_repos_for_org_secret_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgSecret'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetSelectedReposForOrgSecretRequest($org, $secret_name, $actions_set_selected_repos_for_org_secret_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgSecret'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetSelectedReposForOrgSecret'
            );
        }

        // verify the required parameter 'secret_name' is set
        if ($secret_name === null || (is_array($secret_name) && count($secret_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $secret_name when calling actionsSetSelectedReposForOrgSecret'
            );
        }

        // verify the required parameter 'actions_set_selected_repos_for_org_secret_request' is set
        if ($actions_set_selected_repos_for_org_secret_request === null || (is_array($actions_set_selected_repos_for_org_secret_request) && count($actions_set_selected_repos_for_org_secret_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_selected_repos_for_org_secret_request when calling actionsSetSelectedReposForOrgSecret'
            );
        }


        $resourcePath = '/orgs/{org}/actions/secrets/{secret_name}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($secret_name !== null) {
            $resourcePath = str_replace(
                '{' . 'secret_name' . '}',
                ObjectSerializer::toPathValue($secret_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_selected_repos_for_org_secret_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_selected_repos_for_org_secret_request));
            } else {
                $httpBody = $actions_set_selected_repos_for_org_secret_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetSelectedReposForOrgVariable
     *
     * Set selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgVariableRequest $actions_set_selected_repos_for_org_variable_request actions_set_selected_repos_for_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetSelectedReposForOrgVariable($org, $name, $actions_set_selected_repos_for_org_variable_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgVariable'][0])
    {
        $this->actionsSetSelectedReposForOrgVariableWithHttpInfo($org, $name, $actions_set_selected_repos_for_org_variable_request, $contentType);
    }

    /**
     * Operation actionsSetSelectedReposForOrgVariableWithHttpInfo
     *
     * Set selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgVariableRequest $actions_set_selected_repos_for_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetSelectedReposForOrgVariableWithHttpInfo($org, $name, $actions_set_selected_repos_for_org_variable_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgVariable'][0])
    {
        $request = $this->actionsSetSelectedReposForOrgVariableRequest($org, $name, $actions_set_selected_repos_for_org_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetSelectedReposForOrgVariableAsync
     *
     * Set selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgVariableRequest $actions_set_selected_repos_for_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelectedReposForOrgVariableAsync($org, $name, $actions_set_selected_repos_for_org_variable_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgVariable'][0])
    {
        return $this->actionsSetSelectedReposForOrgVariableAsyncWithHttpInfo($org, $name, $actions_set_selected_repos_for_org_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetSelectedReposForOrgVariableAsyncWithHttpInfo
     *
     * Set selected repositories for an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgVariableRequest $actions_set_selected_repos_for_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelectedReposForOrgVariableAsyncWithHttpInfo($org, $name, $actions_set_selected_repos_for_org_variable_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsSetSelectedReposForOrgVariableRequest($org, $name, $actions_set_selected_repos_for_org_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetSelectedReposForOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedReposForOrgVariableRequest $actions_set_selected_repos_for_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedReposForOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetSelectedReposForOrgVariableRequest($org, $name, $actions_set_selected_repos_for_org_variable_request, string $contentType = self::contentTypes['actionsSetSelectedReposForOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetSelectedReposForOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsSetSelectedReposForOrgVariable'
            );
        }

        // verify the required parameter 'actions_set_selected_repos_for_org_variable_request' is set
        if ($actions_set_selected_repos_for_org_variable_request === null || (is_array($actions_set_selected_repos_for_org_variable_request) && count($actions_set_selected_repos_for_org_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_selected_repos_for_org_variable_request when calling actionsSetSelectedReposForOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables/{name}/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_selected_repos_for_org_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_selected_repos_for_org_variable_request));
            } else {
                $httpBody = $actions_set_selected_repos_for_org_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetSelectedRepositoriesEnabledGithubActionsOrganization
     *
     * Set selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest $actions_set_selected_repositories_enabled_github_actions_organization_request actions_set_selected_repositories_enabled_github_actions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetSelectedRepositoriesEnabledGithubActionsOrganization($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, string $contentType = self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        $this->actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWithHttpInfo($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, $contentType);
    }

    /**
     * Operation actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWithHttpInfo
     *
     * Set selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest $actions_set_selected_repositories_enabled_github_actions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWithHttpInfo($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, string $contentType = self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        $request = $this->actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationAsync
     *
     * Set selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest $actions_set_selected_repositories_enabled_github_actions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationAsync($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, string $contentType = self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        return $this->actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationAsyncWithHttpInfo($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationAsyncWithHttpInfo
     *
     * Set selected repositories enabled for GitHub Actions in an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest $actions_set_selected_repositories_enabled_github_actions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationAsyncWithHttpInfo($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, string $contentType = self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {
        $returnType = '';
        $request = $this->actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest $actions_set_selected_repositories_enabled_github_actions_organization_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest($org, $actions_set_selected_repositories_enabled_github_actions_organization_request, string $contentType = self::contentTypes['actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'
            );
        }

        // verify the required parameter 'actions_set_selected_repositories_enabled_github_actions_organization_request' is set
        if ($actions_set_selected_repositories_enabled_github_actions_organization_request === null || (is_array($actions_set_selected_repositories_enabled_github_actions_organization_request) && count($actions_set_selected_repositories_enabled_github_actions_organization_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_set_selected_repositories_enabled_github_actions_organization_request when calling actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'
            );
        }


        $resourcePath = '/orgs/{org}/actions/permissions/repositories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_set_selected_repositories_enabled_github_actions_organization_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_set_selected_repositories_enabled_github_actions_organization_request));
            } else {
                $httpBody = $actions_set_selected_repositories_enabled_github_actions_organization_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetSelfHostedRunnersInGroupForOrg
     *
     * Set self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetSelfHostedRunnersInGroupForOrg($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'][0])
    {
        $this->actionsSetSelfHostedRunnersInGroupForOrgWithHttpInfo($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType);
    }

    /**
     * Operation actionsSetSelfHostedRunnersInGroupForOrgWithHttpInfo
     *
     * Set self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetSelfHostedRunnersInGroupForOrgWithHttpInfo($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'][0])
    {
        $request = $this->actionsSetSelfHostedRunnersInGroupForOrgRequest($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetSelfHostedRunnersInGroupForOrgAsync
     *
     * Set self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelfHostedRunnersInGroupForOrgAsync($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'][0])
    {
        return $this->actionsSetSelfHostedRunnersInGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetSelfHostedRunnersInGroupForOrgAsyncWithHttpInfo
     *
     * Set self-hosted runners in a group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetSelfHostedRunnersInGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'][0])
    {
        $returnType = '';
        $request = $this->actionsSetSelfHostedRunnersInGroupForOrgRequest($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetSelfHostedRunnersInGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetSelfHostedRunnersInGroupForOrgRequest($org, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['actionsSetSelfHostedRunnersInGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsSetSelfHostedRunnersInGroupForOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsSetSelfHostedRunnersInGroupForOrg'
            );
        }

        // verify the required parameter 'enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request' is set
        if ($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request === null || (is_array($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request) && count($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request when calling actionsSetSelfHostedRunnersInGroupForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsSetWorkflowAccessToRepository
     *
     * Set the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository $actions_workflow_access_to_repository actions_workflow_access_to_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsSetWorkflowAccessToRepository($owner, $repo, $actions_workflow_access_to_repository, string $contentType = self::contentTypes['actionsSetWorkflowAccessToRepository'][0])
    {
        $this->actionsSetWorkflowAccessToRepositoryWithHttpInfo($owner, $repo, $actions_workflow_access_to_repository, $contentType);
    }

    /**
     * Operation actionsSetWorkflowAccessToRepositoryWithHttpInfo
     *
     * Set the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository $actions_workflow_access_to_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsSetWorkflowAccessToRepositoryWithHttpInfo($owner, $repo, $actions_workflow_access_to_repository, string $contentType = self::contentTypes['actionsSetWorkflowAccessToRepository'][0])
    {
        $request = $this->actionsSetWorkflowAccessToRepositoryRequest($owner, $repo, $actions_workflow_access_to_repository, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsSetWorkflowAccessToRepositoryAsync
     *
     * Set the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository $actions_workflow_access_to_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetWorkflowAccessToRepositoryAsync($owner, $repo, $actions_workflow_access_to_repository, string $contentType = self::contentTypes['actionsSetWorkflowAccessToRepository'][0])
    {
        return $this->actionsSetWorkflowAccessToRepositoryAsyncWithHttpInfo($owner, $repo, $actions_workflow_access_to_repository, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsSetWorkflowAccessToRepositoryAsyncWithHttpInfo
     *
     * Set the level of access for workflows outside of the repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository $actions_workflow_access_to_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsSetWorkflowAccessToRepositoryAsyncWithHttpInfo($owner, $repo, $actions_workflow_access_to_repository, string $contentType = self::contentTypes['actionsSetWorkflowAccessToRepository'][0])
    {
        $returnType = '';
        $request = $this->actionsSetWorkflowAccessToRepositoryRequest($owner, $repo, $actions_workflow_access_to_repository, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsSetWorkflowAccessToRepository'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsWorkflowAccessToRepository $actions_workflow_access_to_repository (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsSetWorkflowAccessToRepository'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsSetWorkflowAccessToRepositoryRequest($owner, $repo, $actions_workflow_access_to_repository, string $contentType = self::contentTypes['actionsSetWorkflowAccessToRepository'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsSetWorkflowAccessToRepository'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsSetWorkflowAccessToRepository'
            );
        }

        // verify the required parameter 'actions_workflow_access_to_repository' is set
        if ($actions_workflow_access_to_repository === null || (is_array($actions_workflow_access_to_repository) && count($actions_workflow_access_to_repository) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_workflow_access_to_repository when calling actionsSetWorkflowAccessToRepository'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/permissions/access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_workflow_access_to_repository)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_workflow_access_to_repository));
            } else {
                $httpBody = $actions_workflow_access_to_repository;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsUpdateEnvironmentVariable
     *
     * Update an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsUpdateEnvironmentVariable($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateEnvironmentVariable'][0])
    {
        $this->actionsUpdateEnvironmentVariableWithHttpInfo($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, $contentType);
    }

    /**
     * Operation actionsUpdateEnvironmentVariableWithHttpInfo
     *
     * Update an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsUpdateEnvironmentVariableWithHttpInfo($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateEnvironmentVariable'][0])
    {
        $request = $this->actionsUpdateEnvironmentVariableRequest($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsUpdateEnvironmentVariableAsync
     *
     * Update an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateEnvironmentVariableAsync($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateEnvironmentVariable'][0])
    {
        return $this->actionsUpdateEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsUpdateEnvironmentVariableAsyncWithHttpInfo
     *
     * Update an environment variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateEnvironmentVariableAsyncWithHttpInfo($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateEnvironmentVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsUpdateEnvironmentVariableRequest($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsUpdateEnvironmentVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  string $environment_name The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with &#x60;%2F&#x60;. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateEnvironmentVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsUpdateEnvironmentVariableRequest($owner, $repo, $name, $environment_name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateEnvironmentVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsUpdateEnvironmentVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsUpdateEnvironmentVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsUpdateEnvironmentVariable'
            );
        }

        // verify the required parameter 'environment_name' is set
        if ($environment_name === null || (is_array($environment_name) && count($environment_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $environment_name when calling actionsUpdateEnvironmentVariable'
            );
        }

        // verify the required parameter 'actions_update_repo_variable_request' is set
        if ($actions_update_repo_variable_request === null || (is_array($actions_update_repo_variable_request) && count($actions_update_repo_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_update_repo_variable_request when calling actionsUpdateEnvironmentVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/environments/{environment_name}/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($environment_name !== null) {
            $resourcePath = str_replace(
                '{' . 'environment_name' . '}',
                ObjectSerializer::toPathValue($environment_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_update_repo_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_update_repo_variable_request));
            } else {
                $httpBody = $actions_update_repo_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsUpdateOrgVariable
     *
     * Update an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateOrgVariableRequest $actions_update_org_variable_request actions_update_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsUpdateOrgVariable($org, $name, $actions_update_org_variable_request, string $contentType = self::contentTypes['actionsUpdateOrgVariable'][0])
    {
        $this->actionsUpdateOrgVariableWithHttpInfo($org, $name, $actions_update_org_variable_request, $contentType);
    }

    /**
     * Operation actionsUpdateOrgVariableWithHttpInfo
     *
     * Update an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateOrgVariableRequest $actions_update_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateOrgVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsUpdateOrgVariableWithHttpInfo($org, $name, $actions_update_org_variable_request, string $contentType = self::contentTypes['actionsUpdateOrgVariable'][0])
    {
        $request = $this->actionsUpdateOrgVariableRequest($org, $name, $actions_update_org_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsUpdateOrgVariableAsync
     *
     * Update an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateOrgVariableRequest $actions_update_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateOrgVariableAsync($org, $name, $actions_update_org_variable_request, string $contentType = self::contentTypes['actionsUpdateOrgVariable'][0])
    {
        return $this->actionsUpdateOrgVariableAsyncWithHttpInfo($org, $name, $actions_update_org_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsUpdateOrgVariableAsyncWithHttpInfo
     *
     * Update an organization variable
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateOrgVariableRequest $actions_update_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateOrgVariableAsyncWithHttpInfo($org, $name, $actions_update_org_variable_request, string $contentType = self::contentTypes['actionsUpdateOrgVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsUpdateOrgVariableRequest($org, $name, $actions_update_org_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsUpdateOrgVariable'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateOrgVariableRequest $actions_update_org_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateOrgVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsUpdateOrgVariableRequest($org, $name, $actions_update_org_variable_request, string $contentType = self::contentTypes['actionsUpdateOrgVariable'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsUpdateOrgVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsUpdateOrgVariable'
            );
        }

        // verify the required parameter 'actions_update_org_variable_request' is set
        if ($actions_update_org_variable_request === null || (is_array($actions_update_org_variable_request) && count($actions_update_org_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_update_org_variable_request when calling actionsUpdateOrgVariable'
            );
        }


        $resourcePath = '/orgs/{org}/actions/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_update_org_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_update_org_variable_request));
            } else {
                $httpBody = $actions_update_org_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsUpdateRepoVariable
     *
     * Update a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function actionsUpdateRepoVariable($owner, $repo, $name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateRepoVariable'][0])
    {
        $this->actionsUpdateRepoVariableWithHttpInfo($owner, $repo, $name, $actions_update_repo_variable_request, $contentType);
    }

    /**
     * Operation actionsUpdateRepoVariableWithHttpInfo
     *
     * Update a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateRepoVariable'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsUpdateRepoVariableWithHttpInfo($owner, $repo, $name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateRepoVariable'][0])
    {
        $request = $this->actionsUpdateRepoVariableRequest($owner, $repo, $name, $actions_update_repo_variable_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation actionsUpdateRepoVariableAsync
     *
     * Update a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateRepoVariableAsync($owner, $repo, $name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateRepoVariable'][0])
    {
        return $this->actionsUpdateRepoVariableAsyncWithHttpInfo($owner, $repo, $name, $actions_update_repo_variable_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsUpdateRepoVariableAsyncWithHttpInfo
     *
     * Update a repository variable
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateRepoVariableAsyncWithHttpInfo($owner, $repo, $name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateRepoVariable'][0])
    {
        $returnType = '';
        $request = $this->actionsUpdateRepoVariableRequest($owner, $repo, $name, $actions_update_repo_variable_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsUpdateRepoVariable'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $name The name of the variable. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateRepoVariableRequest $actions_update_repo_variable_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateRepoVariable'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsUpdateRepoVariableRequest($owner, $repo, $name, $actions_update_repo_variable_request, string $contentType = self::contentTypes['actionsUpdateRepoVariable'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling actionsUpdateRepoVariable'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling actionsUpdateRepoVariable'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling actionsUpdateRepoVariable'
            );
        }

        // verify the required parameter 'actions_update_repo_variable_request' is set
        if ($actions_update_repo_variable_request === null || (is_array($actions_update_repo_variable_request) && count($actions_update_repo_variable_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_update_repo_variable_request when calling actionsUpdateRepoVariable'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/actions/variables/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_update_repo_variable_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_update_repo_variable_request));
            } else {
                $httpBody = $actions_update_repo_variable_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation actionsUpdateSelfHostedRunnerGroupForOrg
     *
     * Update a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateSelfHostedRunnerGroupForOrgRequest $actions_update_self_hosted_runner_group_for_org_request actions_update_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg
     */
    public function actionsUpdateSelfHostedRunnerGroupForOrg($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'][0])
    {
        list($response) = $this->actionsUpdateSelfHostedRunnerGroupForOrgWithHttpInfo($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, $contentType);
        return $response;
    }

    /**
     * Operation actionsUpdateSelfHostedRunnerGroupForOrgWithHttpInfo
     *
     * Update a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateSelfHostedRunnerGroupForOrgRequest $actions_update_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg, HTTP status code, HTTP response headers (array of strings)
     */
    public function actionsUpdateSelfHostedRunnerGroupForOrgWithHttpInfo($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'][0])
    {
        $request = $this->actionsUpdateSelfHostedRunnerGroupForOrgRequest($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation actionsUpdateSelfHostedRunnerGroupForOrgAsync
     *
     * Update a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateSelfHostedRunnerGroupForOrgRequest $actions_update_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateSelfHostedRunnerGroupForOrgAsync($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'][0])
    {
        return $this->actionsUpdateSelfHostedRunnerGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation actionsUpdateSelfHostedRunnerGroupForOrgAsyncWithHttpInfo
     *
     * Update a self-hosted runner group for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateSelfHostedRunnerGroupForOrgRequest $actions_update_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function actionsUpdateSelfHostedRunnerGroupForOrgAsyncWithHttpInfo($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsOrg';
        $request = $this->actionsUpdateSelfHostedRunnerGroupForOrgRequest($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'actionsUpdateSelfHostedRunnerGroupForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsUpdateSelfHostedRunnerGroupForOrgRequest $actions_update_self_hosted_runner_group_for_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function actionsUpdateSelfHostedRunnerGroupForOrgRequest($org, $runner_group_id, $actions_update_self_hosted_runner_group_for_org_request, string $contentType = self::contentTypes['actionsUpdateSelfHostedRunnerGroupForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling actionsUpdateSelfHostedRunnerGroupForOrg'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling actionsUpdateSelfHostedRunnerGroupForOrg'
            );
        }

        // verify the required parameter 'actions_update_self_hosted_runner_group_for_org_request' is set
        if ($actions_update_self_hosted_runner_group_for_org_request === null || (is_array($actions_update_self_hosted_runner_group_for_org_request) && count($actions_update_self_hosted_runner_group_for_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $actions_update_self_hosted_runner_group_for_org_request when calling actionsUpdateSelfHostedRunnerGroupForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/actions/runner-groups/{runner_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($actions_update_self_hosted_runner_group_for_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($actions_update_self_hosted_runner_group_for_org_request));
            } else {
                $httpBody = $actions_update_self_hosted_runner_group_for_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
