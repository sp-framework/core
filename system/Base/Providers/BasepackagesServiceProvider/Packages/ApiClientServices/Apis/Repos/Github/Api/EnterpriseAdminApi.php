<?php
/**
 * EnterpriseAdminApi
 * PHP version 7.4
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Configuration;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\HeaderSelector;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ObjectSerializer;

/**
 * EnterpriseAdminApi Class Doc Comment
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EnterpriseAdminApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'enterpriseAdminAddAuthorizedSshKey' => [
            'application/x-www-form-urlencoded',
        ],
        'enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminCreateEnterpriseServerLicense' => [
            'multipart/form-data',
        ],
        'enterpriseAdminCreateGlobalWebhook' => [
            'application/json',
        ],
        'enterpriseAdminCreateImpersonationOAuthToken' => [
            'application/json',
        ],
        'enterpriseAdminCreateOrg' => [
            'application/json',
        ],
        'enterpriseAdminCreatePreReceiveEnvironment' => [
            'application/json',
        ],
        'enterpriseAdminCreatePreReceiveHook' => [
            'application/json',
        ],
        'enterpriseAdminCreateRegistrationTokenForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminCreateRemoveTokenForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminCreateUser' => [
            'application/json',
        ],
        'enterpriseAdminDeleteGlobalWebhook' => [
            'application/json',
        ],
        'enterpriseAdminDeleteImpersonationOAuthToken' => [
            'application/json',
        ],
        'enterpriseAdminDeleteManageSsh' => [
            'application/json',
        ],
        'enterpriseAdminDeletePersonalAccessToken' => [
            'application/json',
        ],
        'enterpriseAdminDeletePreReceiveEnvironment' => [
            'application/json',
        ],
        'enterpriseAdminDeletePreReceiveHook' => [
            'application/json',
        ],
        'enterpriseAdminDeletePublicKey' => [
            'application/json',
        ],
        'enterpriseAdminDeleteScimGroupFromEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminDeleteSelfHostedRunnerFromEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminDeleteUser' => [
            'application/json',
        ],
        'enterpriseAdminDeleteUserFromEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminDemoteSiteAdministrator' => [
            'application/json',
        ],
        'enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminEnableOrDisableMaintenanceMode' => [
            'application/x-www-form-urlencoded',
        ],
        'enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminGetAllAuthorizedSshKeys' => [
            'application/json',
        ],
        'enterpriseAdminGetAllStats' => [
            'application/json',
        ],
        'enterpriseAdminGetAllowedActionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminGetAnnouncement' => [
            'application/json',
        ],
        'enterpriseAdminGetAuditLog' => [
            'application/json',
        ],
        'enterpriseAdminGetChecksSystemRequirements' => [
            'application/json',
        ],
        'enterpriseAdminGetCommentStats' => [
            'application/json',
        ],
        'enterpriseAdminGetConfigNodes' => [
            'application/json',
        ],
        'enterpriseAdminGetConfigurationStatus' => [
            'application/json',
        ],
        'enterpriseAdminGetDownloadStatusForPreReceiveEnvironment' => [
            'application/json',
        ],
        'enterpriseAdminGetGistStats' => [
            'application/json',
        ],
        'enterpriseAdminGetGithubActionsPermissionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminGetGlobalWebhook' => [
            'application/json',
        ],
        'enterpriseAdminGetHooksStats' => [
            'application/json',
        ],
        'enterpriseAdminGetIssueStats' => [
            'application/json',
        ],
        'enterpriseAdminGetLicenseInformation' => [
            'application/json',
        ],
        'enterpriseAdminGetMaintenanceStatus' => [
            'application/json',
        ],
        'enterpriseAdminGetManageMaintenance' => [
            'application/json',
        ],
        'enterpriseAdminGetManageSettings' => [
            'application/json',
        ],
        'enterpriseAdminGetManageSettings_0' => [
            'application/json',
        ],
        'enterpriseAdminGetManageSettings_1' => [
            'application/json',
        ],
        'enterpriseAdminGetManageSettings_2' => [
            'application/json',
        ],
        'enterpriseAdminGetManageSsh' => [
            'application/json',
        ],
        'enterpriseAdminGetMilestoneStats' => [
            'application/json',
        ],
        'enterpriseAdminGetOrgStats' => [
            'application/json',
        ],
        'enterpriseAdminGetPagesStats' => [
            'application/json',
        ],
        'enterpriseAdminGetPreReceiveEnvironment' => [
            'application/json',
        ],
        'enterpriseAdminGetPreReceiveHook' => [
            'application/json',
        ],
        'enterpriseAdminGetPreReceiveHookForOrg' => [
            'application/json',
        ],
        'enterpriseAdminGetPreReceiveHookForRepo' => [
            'application/json',
        ],
        'enterpriseAdminGetProvisioningInformationForEnterpriseGroup' => [
            'application/json',
        ],
        'enterpriseAdminGetProvisioningInformationForEnterpriseUser' => [
            'application/json',
        ],
        'enterpriseAdminGetPullRequestStats' => [
            'application/json',
        ],
        'enterpriseAdminGetReplicationStatus' => [
            'application/json',
        ],
        'enterpriseAdminGetRepoStats' => [
            'application/json',
        ],
        'enterpriseAdminGetSecurityProducts' => [
            'application/json',
        ],
        'enterpriseAdminGetSelfHostedRunnerForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminGetSelfHostedRunnerGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminGetSettings' => [
            'application/json',
        ],
        'enterpriseAdminGetUserStats' => [
            'application/json',
        ],
        'enterpriseAdminGetVersion' => [
            'application/json',
        ],
        'enterpriseAdminInitializeInstanceConfiguration' => [
            'multipart/form-data',
        ],
        'enterpriseAdminLicenseCheck' => [
            'application/json',
        ],
        'enterpriseAdminLicenseInfo' => [
            'application/json',
        ],
        'enterpriseAdminLicenseUpload' => [
            'application/octet-stream',
        ],
        'enterpriseAdminListGlobalWebhooks' => [
            'application/json',
        ],
        'enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListPersonalAccessTokens' => [
            'application/json',
        ],
        'enterpriseAdminListPreReceiveEnvironments' => [
            'application/json',
        ],
        'enterpriseAdminListPreReceiveHooks' => [
            'application/json',
        ],
        'enterpriseAdminListPreReceiveHooksForOrg' => [
            'application/json',
        ],
        'enterpriseAdminListPreReceiveHooksForRepo' => [
            'application/json',
        ],
        'enterpriseAdminListProvisionedGroupsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListProvisionedIdentitiesEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListPublicKeys' => [
            'application/json',
        ],
        'enterpriseAdminListRunnerApplicationsForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListSelfHostedRunnerGroupsForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListSelfHostedRunnersForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminListSelfHostedRunnersInGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminPingGlobalWebhook' => [
            'application/json',
        ],
        'enterpriseAdminPromoteUserToBeSiteAdministrator' => [
            'application/json',
        ],
        'enterpriseAdminProvisionEnterpriseGroup' => [
            'application/json',
        ],
        'enterpriseAdminProvisionEnterpriseUser' => [
            'application/json',
        ],
        'enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminRemoveAnnouncement' => [
            'application/json',
        ],
        'enterpriseAdminRemoveAuthorizedSshKey' => [
            'application/x-www-form-urlencoded',
        ],
        'enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminRemovePreReceiveHookEnforcementForOrg' => [
            'application/json',
        ],
        'enterpriseAdminRemovePreReceiveHookEnforcementForRepo' => [
            'application/json',
        ],
        'enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetAllowedActionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetAnnouncement' => [
            'application/json',
        ],
        'enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetGithubActionsPermissionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetInformationForProvisionedEnterpriseGroup' => [
            'application/json',
        ],
        'enterpriseAdminSetInformationForProvisionedEnterpriseUser' => [
            'application/json',
        ],
        'enterpriseAdminSetManageMaintenance' => [
            'application/json',
        ],
        'enterpriseAdminSetManageSettings' => [
            'application/json',
        ],
        'enterpriseAdminSetManageSsh' => [
            'application/json',
        ],
        'enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminSetSettings' => [
            'application/x-www-form-urlencoded',
        ],
        'enterpriseAdminStartConfigurationProcess' => [
            'application/json',
        ],
        'enterpriseAdminStartPreReceiveEnvironmentDownload' => [
            'application/json',
        ],
        'enterpriseAdminSuspendUser' => [
            'application/json',
        ],
        'enterpriseAdminSyncLdapMappingForTeam' => [
            'application/json',
        ],
        'enterpriseAdminSyncLdapMappingForUser' => [
            'application/json',
        ],
        'enterpriseAdminUnsuspendUser' => [
            'application/json',
        ],
        'enterpriseAdminUpdateAttributeForEnterpriseGroup' => [
            'application/json',
        ],
        'enterpriseAdminUpdateAttributeForEnterpriseUser' => [
            'application/json',
        ],
        'enterpriseAdminUpdateGlobalWebhook' => [
            'application/json',
        ],
        'enterpriseAdminUpdateLdapMappingForTeam' => [
            'application/json',
        ],
        'enterpriseAdminUpdateLdapMappingForUser' => [
            'application/json',
        ],
        'enterpriseAdminUpdateOrgName' => [
            'application/json',
        ],
        'enterpriseAdminUpdatePreReceiveEnvironment' => [
            'application/json',
        ],
        'enterpriseAdminUpdatePreReceiveHook' => [
            'application/json',
        ],
        'enterpriseAdminUpdatePreReceiveHookEnforcementForOrg' => [
            'application/json',
        ],
        'enterpriseAdminUpdatePreReceiveHookEnforcementForRepo' => [
            'application/json',
        ],
        'enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise' => [
            'application/json',
        ],
        'enterpriseAdminUpdateUsernameForUser' => [
            'application/json',
        ],
        'enterpriseAdminUpgradeLicense' => [
            'multipart/form-data',
        ],
        'secretScanningGetSecurityAnalysisSettingsForEnterprise' => [
            'application/json',
        ],
        'secretScanningPatchSecurityAnalysisSettingsForEnterprise' => [
            'application/json',
        ],
        'secretScanningPostSecurityProductEnablementForEnterprise' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation enterpriseAdminAddAuthorizedSshKey
     *
     * Add an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]
     */
    public function enterpriseAdminAddAuthorizedSshKey($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminAddAuthorizedSshKey'][0])
    {
        list($response) = $this->enterpriseAdminAddAuthorizedSshKeyWithHttpInfo($authorized_key, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminAddAuthorizedSshKeyWithHttpInfo
     *
     * Add an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminAddAuthorizedSshKeyWithHttpInfo($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminAddAuthorizedSshKey'][0])
    {
        $request = $this->enterpriseAdminAddAuthorizedSshKeyRequest($authorized_key, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminAddAuthorizedSshKeyAsync
     *
     * Add an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddAuthorizedSshKeyAsync($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminAddAuthorizedSshKey'][0])
    {
        return $this->enterpriseAdminAddAuthorizedSshKeyAsyncWithHttpInfo($authorized_key, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminAddAuthorizedSshKeyAsyncWithHttpInfo
     *
     * Add an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddAuthorizedSshKeyAsyncWithHttpInfo($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminAddAuthorizedSshKey'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]';
        $request = $this->enterpriseAdminAddAuthorizedSshKeyRequest($authorized_key, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminAddAuthorizedSshKey'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminAddAuthorizedSshKeyRequest($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminAddAuthorizedSshKey'][0])
    {

        // verify the required parameter 'authorized_key' is set
        if ($authorized_key === null || (is_array($authorized_key) && count($authorized_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorized_key when calling enterpriseAdminAddAuthorizedSshKey'
            );
        }


        $resourcePath = '/setup/api/settings/authorized-keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($authorized_key !== null) {
            $formParams['authorized_key'] = ObjectSerializer::toFormValue($authorized_key);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminAddAuthorizedSshKey();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminAddAuthorizedSshKey
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminAddAuthorizedSshKey(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise
     *
     * Add custom labels to a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseWithHttpInfo
     *
     * Add custom labels to a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'][0])
    {
        $request = $this->enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseAsync
     *
     * Add custom labels to a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseAsync($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'][0])
    {
        return $this->enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseAsyncWithHttpInfo
     *
     * Add custom labels to a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request' is set
        if ($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request === null || (is_array($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request) && count($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request when calling enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_add_custom_labels_to_self_hosted_runner_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise
     *
     * Add organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $this->enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $org_id, $contentType);
    }

    /**
     * Operation enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo
     *
     * Add organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $request = $this->enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $org_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync
     *
     * Add organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        return $this->enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $org_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo
     *
     * Add organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $org_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'org_id' is set
        if ($org_id === null || (is_array($org_id) && count($org_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_id when calling enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($org_id !== null) {
            $resourcePath = str_replace(
                '{' . 'org_id' . '}',
                ObjectSerializer::toPathValue($org_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise
     *
     * Add a self-hosted runner to a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'][0])
    {
        $this->enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $runner_id, $contentType);
    }

    /**
     * Operation enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseWithHttpInfo
     *
     * Add a self-hosted runner to a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest($enterprise, $runner_group_id, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseAsync
     *
     * Add a self-hosted runner to a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseAsync($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseAsyncWithHttpInfo
     *
     * Add a self-hosted runner to a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest($enterprise, $runner_group_id, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateEnterpriseServerLicense
     *
     * Create a GitHub license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password You **must** provide a password _only if_ you are uploading your license for the first time. If you previously set a password through the web interface, you don&#39;t need this parameter. (optional)
     * @param  string $settings An optional JSON string containing the installation settings. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminCreateEnterpriseServerLicense($license, $password = null, $settings = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'][0])
    {
        $this->enterpriseAdminCreateEnterpriseServerLicenseWithHttpInfo($license, $password, $settings, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation enterpriseAdminCreateEnterpriseServerLicenseWithHttpInfo
     *
     * Create a GitHub license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password You **must** provide a password _only if_ you are uploading your license for the first time. If you previously set a password through the web interface, you don&#39;t need this parameter. (optional)
     * @param  string $settings An optional JSON string containing the installation settings. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateEnterpriseServerLicenseWithHttpInfo($license, $password = null, $settings = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'][0])
    {
        $request = $this->enterpriseAdminCreateEnterpriseServerLicenseRequest($license, $password, $settings, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateEnterpriseServerLicenseAsync
     *
     * Create a GitHub license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password You **must** provide a password _only if_ you are uploading your license for the first time. If you previously set a password through the web interface, you don&#39;t need this parameter. (optional)
     * @param  string $settings An optional JSON string containing the installation settings. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateEnterpriseServerLicenseAsync($license, $password = null, $settings = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'][0])
    {
        return $this->enterpriseAdminCreateEnterpriseServerLicenseAsyncWithHttpInfo($license, $password, $settings, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateEnterpriseServerLicenseAsyncWithHttpInfo
     *
     * Create a GitHub license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password You **must** provide a password _only if_ you are uploading your license for the first time. If you previously set a password through the web interface, you don&#39;t need this parameter. (optional)
     * @param  string $settings An optional JSON string containing the installation settings. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateEnterpriseServerLicenseAsyncWithHttpInfo($license, $password = null, $settings = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminCreateEnterpriseServerLicenseRequest($license, $password, $settings, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateEnterpriseServerLicense'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password You **must** provide a password _only if_ you are uploading your license for the first time. If you previously set a password through the web interface, you don&#39;t need this parameter. (optional)
     * @param  string $settings An optional JSON string containing the installation settings. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateEnterpriseServerLicenseRequest($license, $password = null, $settings = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminCreateEnterpriseServerLicense'][0])
    {

        // verify the required parameter 'license' is set
        if ($license === null || (is_array($license) && count($license) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $license when calling enterpriseAdminCreateEnterpriseServerLicense'
            );
        }




        $resourcePath = '/setup/api/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($license !== null) {
            $formParams['license'] = ObjectSerializer::toFormValue($license);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }
        // form params
        if ($settings !== null) {
            $formParams['settings'] = ObjectSerializer::toFormValue($settings);
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminCreateEnterpriseServerLicense();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminCreateEnterpriseServerLicense
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminCreateEnterpriseServerLicense(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminCreateGlobalWebhook
     *
     * Create a global webhook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateGlobalWebhookRequest $enterprise_admin_create_global_webhook_request enterprise_admin_create_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook
     */
    public function enterpriseAdminCreateGlobalWebhook($enterprise_admin_create_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminCreateGlobalWebhook'][0])
    {
        list($response) = $this->enterpriseAdminCreateGlobalWebhookWithHttpInfo($enterprise_admin_create_global_webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateGlobalWebhookWithHttpInfo
     *
     * Create a global webhook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateGlobalWebhookRequest $enterprise_admin_create_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateGlobalWebhookWithHttpInfo($enterprise_admin_create_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminCreateGlobalWebhook'][0])
    {
        $request = $this->enterpriseAdminCreateGlobalWebhookRequest($enterprise_admin_create_global_webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateGlobalWebhookAsync
     *
     * Create a global webhook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateGlobalWebhookRequest $enterprise_admin_create_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateGlobalWebhookAsync($enterprise_admin_create_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminCreateGlobalWebhook'][0])
    {
        return $this->enterpriseAdminCreateGlobalWebhookAsyncWithHttpInfo($enterprise_admin_create_global_webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateGlobalWebhookAsyncWithHttpInfo
     *
     * Create a global webhook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateGlobalWebhookRequest $enterprise_admin_create_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateGlobalWebhookAsyncWithHttpInfo($enterprise_admin_create_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminCreateGlobalWebhook'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook';
        $request = $this->enterpriseAdminCreateGlobalWebhookRequest($enterprise_admin_create_global_webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateGlobalWebhook'
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateGlobalWebhookRequest $enterprise_admin_create_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateGlobalWebhookRequest($enterprise_admin_create_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminCreateGlobalWebhook'][0])
    {

        // verify the required parameter 'enterprise_admin_create_global_webhook_request' is set
        if ($enterprise_admin_create_global_webhook_request === null || (is_array($enterprise_admin_create_global_webhook_request) && count($enterprise_admin_create_global_webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_global_webhook_request when calling enterpriseAdminCreateGlobalWebhook'
            );
        }


        $resourcePath = '/admin/hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_global_webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_global_webhook_request));
            } else {
                $httpBody = $enterprise_admin_create_global_webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateImpersonationOAuthToken
     *
     * Create an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateImpersonationOAuthTokenRequest $enterprise_admin_create_impersonation_o_auth_token_request enterprise_admin_create_impersonation_o_auth_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization
     */
    public function enterpriseAdminCreateImpersonationOAuthToken($username, $enterprise_admin_create_impersonation_o_auth_token_request, string $contentType = self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'][0])
    {
        list($response) = $this->enterpriseAdminCreateImpersonationOAuthTokenWithHttpInfo($username, $enterprise_admin_create_impersonation_o_auth_token_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateImpersonationOAuthTokenWithHttpInfo
     *
     * Create an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateImpersonationOAuthTokenRequest $enterprise_admin_create_impersonation_o_auth_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateImpersonationOAuthTokenWithHttpInfo($username, $enterprise_admin_create_impersonation_o_auth_token_request, string $contentType = self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'][0])
    {
        $request = $this->enterpriseAdminCreateImpersonationOAuthTokenRequest($username, $enterprise_admin_create_impersonation_o_auth_token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateImpersonationOAuthTokenAsync
     *
     * Create an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateImpersonationOAuthTokenRequest $enterprise_admin_create_impersonation_o_auth_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateImpersonationOAuthTokenAsync($username, $enterprise_admin_create_impersonation_o_auth_token_request, string $contentType = self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'][0])
    {
        return $this->enterpriseAdminCreateImpersonationOAuthTokenAsyncWithHttpInfo($username, $enterprise_admin_create_impersonation_o_auth_token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateImpersonationOAuthTokenAsyncWithHttpInfo
     *
     * Create an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateImpersonationOAuthTokenRequest $enterprise_admin_create_impersonation_o_auth_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateImpersonationOAuthTokenAsyncWithHttpInfo($username, $enterprise_admin_create_impersonation_o_auth_token_request, string $contentType = self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization';
        $request = $this->enterpriseAdminCreateImpersonationOAuthTokenRequest($username, $enterprise_admin_create_impersonation_o_auth_token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateImpersonationOAuthToken'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateImpersonationOAuthTokenRequest $enterprise_admin_create_impersonation_o_auth_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateImpersonationOAuthTokenRequest($username, $enterprise_admin_create_impersonation_o_auth_token_request, string $contentType = self::contentTypes['enterpriseAdminCreateImpersonationOAuthToken'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminCreateImpersonationOAuthToken'
            );
        }

        // verify the required parameter 'enterprise_admin_create_impersonation_o_auth_token_request' is set
        if ($enterprise_admin_create_impersonation_o_auth_token_request === null || (is_array($enterprise_admin_create_impersonation_o_auth_token_request) && count($enterprise_admin_create_impersonation_o_auth_token_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_impersonation_o_auth_token_request when calling enterpriseAdminCreateImpersonationOAuthToken'
            );
        }


        $resourcePath = '/admin/users/{username}/authorizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_impersonation_o_auth_token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_impersonation_o_auth_token_request));
            } else {
                $httpBody = $enterprise_admin_create_impersonation_o_auth_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateOrg
     *
     * Create an organization
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateOrgRequest $enterprise_admin_create_org_request enterprise_admin_create_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple
     */
    public function enterpriseAdminCreateOrg($enterprise_admin_create_org_request, string $contentType = self::contentTypes['enterpriseAdminCreateOrg'][0])
    {
        list($response) = $this->enterpriseAdminCreateOrgWithHttpInfo($enterprise_admin_create_org_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateOrgWithHttpInfo
     *
     * Create an organization
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateOrgRequest $enterprise_admin_create_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateOrgWithHttpInfo($enterprise_admin_create_org_request, string $contentType = self::contentTypes['enterpriseAdminCreateOrg'][0])
    {
        $request = $this->enterpriseAdminCreateOrgRequest($enterprise_admin_create_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateOrgAsync
     *
     * Create an organization
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateOrgRequest $enterprise_admin_create_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateOrgAsync($enterprise_admin_create_org_request, string $contentType = self::contentTypes['enterpriseAdminCreateOrg'][0])
    {
        return $this->enterpriseAdminCreateOrgAsyncWithHttpInfo($enterprise_admin_create_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateOrgAsyncWithHttpInfo
     *
     * Create an organization
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateOrgRequest $enterprise_admin_create_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateOrgAsyncWithHttpInfo($enterprise_admin_create_org_request, string $contentType = self::contentTypes['enterpriseAdminCreateOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationSimple';
        $request = $this->enterpriseAdminCreateOrgRequest($enterprise_admin_create_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateOrg'
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateOrgRequest $enterprise_admin_create_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateOrgRequest($enterprise_admin_create_org_request, string $contentType = self::contentTypes['enterpriseAdminCreateOrg'][0])
    {

        // verify the required parameter 'enterprise_admin_create_org_request' is set
        if ($enterprise_admin_create_org_request === null || (is_array($enterprise_admin_create_org_request) && count($enterprise_admin_create_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_org_request when calling enterpriseAdminCreateOrg'
            );
        }


        $resourcePath = '/admin/organizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_org_request));
            } else {
                $httpBody = $enterprise_admin_create_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveEnvironment
     *
     * Create a pre-receive environment
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveEnvironmentRequest $enterprise_admin_create_pre_receive_environment_request enterprise_admin_create_pre_receive_environment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment
     */
    public function enterpriseAdminCreatePreReceiveEnvironment($enterprise_admin_create_pre_receive_environment_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'][0])
    {
        list($response) = $this->enterpriseAdminCreatePreReceiveEnvironmentWithHttpInfo($enterprise_admin_create_pre_receive_environment_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveEnvironmentWithHttpInfo
     *
     * Create a pre-receive environment
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveEnvironmentRequest $enterprise_admin_create_pre_receive_environment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreatePreReceiveEnvironmentWithHttpInfo($enterprise_admin_create_pre_receive_environment_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'][0])
    {
        $request = $this->enterpriseAdminCreatePreReceiveEnvironmentRequest($enterprise_admin_create_pre_receive_environment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveEnvironmentAsync
     *
     * Create a pre-receive environment
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveEnvironmentRequest $enterprise_admin_create_pre_receive_environment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreatePreReceiveEnvironmentAsync($enterprise_admin_create_pre_receive_environment_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'][0])
    {
        return $this->enterpriseAdminCreatePreReceiveEnvironmentAsyncWithHttpInfo($enterprise_admin_create_pre_receive_environment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveEnvironmentAsyncWithHttpInfo
     *
     * Create a pre-receive environment
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveEnvironmentRequest $enterprise_admin_create_pre_receive_environment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreatePreReceiveEnvironmentAsyncWithHttpInfo($enterprise_admin_create_pre_receive_environment_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment';
        $request = $this->enterpriseAdminCreatePreReceiveEnvironmentRequest($enterprise_admin_create_pre_receive_environment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreatePreReceiveEnvironment'
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveEnvironmentRequest $enterprise_admin_create_pre_receive_environment_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreatePreReceiveEnvironmentRequest($enterprise_admin_create_pre_receive_environment_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveEnvironment'][0])
    {

        // verify the required parameter 'enterprise_admin_create_pre_receive_environment_request' is set
        if ($enterprise_admin_create_pre_receive_environment_request === null || (is_array($enterprise_admin_create_pre_receive_environment_request) && count($enterprise_admin_create_pre_receive_environment_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_pre_receive_environment_request when calling enterpriseAdminCreatePreReceiveEnvironment'
            );
        }


        $resourcePath = '/admin/pre-receive-environments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_pre_receive_environment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_pre_receive_environment_request));
            } else {
                $httpBody = $enterprise_admin_create_pre_receive_environment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveHook
     *
     * Create a pre-receive hook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveHookRequest $enterprise_admin_create_pre_receive_hook_request enterprise_admin_create_pre_receive_hook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook
     */
    public function enterpriseAdminCreatePreReceiveHook($enterprise_admin_create_pre_receive_hook_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveHook'][0])
    {
        list($response) = $this->enterpriseAdminCreatePreReceiveHookWithHttpInfo($enterprise_admin_create_pre_receive_hook_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveHookWithHttpInfo
     *
     * Create a pre-receive hook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveHookRequest $enterprise_admin_create_pre_receive_hook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreatePreReceiveHookWithHttpInfo($enterprise_admin_create_pre_receive_hook_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveHook'][0])
    {
        $request = $this->enterpriseAdminCreatePreReceiveHookRequest($enterprise_admin_create_pre_receive_hook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveHookAsync
     *
     * Create a pre-receive hook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveHookRequest $enterprise_admin_create_pre_receive_hook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreatePreReceiveHookAsync($enterprise_admin_create_pre_receive_hook_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveHook'][0])
    {
        return $this->enterpriseAdminCreatePreReceiveHookAsyncWithHttpInfo($enterprise_admin_create_pre_receive_hook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreatePreReceiveHookAsyncWithHttpInfo
     *
     * Create a pre-receive hook
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveHookRequest $enterprise_admin_create_pre_receive_hook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreatePreReceiveHookAsyncWithHttpInfo($enterprise_admin_create_pre_receive_hook_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveHook'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook';
        $request = $this->enterpriseAdminCreatePreReceiveHookRequest($enterprise_admin_create_pre_receive_hook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreatePreReceiveHook'
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreatePreReceiveHookRequest $enterprise_admin_create_pre_receive_hook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreatePreReceiveHookRequest($enterprise_admin_create_pre_receive_hook_request, string $contentType = self::contentTypes['enterpriseAdminCreatePreReceiveHook'][0])
    {

        // verify the required parameter 'enterprise_admin_create_pre_receive_hook_request' is set
        if ($enterprise_admin_create_pre_receive_hook_request === null || (is_array($enterprise_admin_create_pre_receive_hook_request) && count($enterprise_admin_create_pre_receive_hook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_pre_receive_hook_request when calling enterpriseAdminCreatePreReceiveHook'
            );
        }


        $resourcePath = '/admin/pre-receive-hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_pre_receive_hook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_pre_receive_hook_request));
            } else {
                $httpBody = $enterprise_admin_create_pre_receive_hook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateRegistrationTokenForEnterprise
     *
     * Create a registration token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken
     */
    public function enterpriseAdminCreateRegistrationTokenForEnterprise($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminCreateRegistrationTokenForEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateRegistrationTokenForEnterpriseWithHttpInfo
     *
     * Create a registration token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateRegistrationTokenForEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'][0])
    {
        $request = $this->enterpriseAdminCreateRegistrationTokenForEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateRegistrationTokenForEnterpriseAsync
     *
     * Create a registration token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateRegistrationTokenForEnterpriseAsync($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'][0])
    {
        return $this->enterpriseAdminCreateRegistrationTokenForEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateRegistrationTokenForEnterpriseAsyncWithHttpInfo
     *
     * Create a registration token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateRegistrationTokenForEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
        $request = $this->enterpriseAdminCreateRegistrationTokenForEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateRegistrationTokenForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateRegistrationTokenForEnterpriseRequest($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRegistrationTokenForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminCreateRegistrationTokenForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/registration-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateRemoveTokenForEnterprise
     *
     * Create a remove token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken
     */
    public function enterpriseAdminCreateRemoveTokenForEnterprise($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminCreateRemoveTokenForEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateRemoveTokenForEnterpriseWithHttpInfo
     *
     * Create a remove token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateRemoveTokenForEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'][0])
    {
        $request = $this->enterpriseAdminCreateRemoveTokenForEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateRemoveTokenForEnterpriseAsync
     *
     * Create a remove token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateRemoveTokenForEnterpriseAsync($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'][0])
    {
        return $this->enterpriseAdminCreateRemoveTokenForEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateRemoveTokenForEnterpriseAsyncWithHttpInfo
     *
     * Create a remove token for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateRemoveTokenForEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuthenticationToken';
        $request = $this->enterpriseAdminCreateRemoveTokenForEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateRemoveTokenForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateRemoveTokenForEnterpriseRequest($enterprise, string $contentType = self::contentTypes['enterpriseAdminCreateRemoveTokenForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminCreateRemoveTokenForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/remove-token';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise
     *
     * Create a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request enterprise_admin_create_self_hosted_runner_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise
     */
    public function enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseWithHttpInfo($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseWithHttpInfo
     *
     * Create a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseWithHttpInfo($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseAsync
     *
     * Create a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseAsync($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo
     *
     * Create a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise';
        $request = $this->enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_create_self_hosted_runner_group_for_enterprise_request' is set
        if ($enterprise_admin_create_self_hosted_runner_group_for_enterprise_request === null || (is_array($enterprise_admin_create_self_hosted_runner_group_for_enterprise_request) && count($enterprise_admin_create_self_hosted_runner_group_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request when calling enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_self_hosted_runner_group_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_self_hosted_runner_group_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_create_self_hosted_runner_group_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminCreateUser
     *
     * Create a user
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateUserRequest $enterprise_admin_create_user_request enterprise_admin_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser
     */
    public function enterpriseAdminCreateUser($enterprise_admin_create_user_request, string $contentType = self::contentTypes['enterpriseAdminCreateUser'][0])
    {
        list($response) = $this->enterpriseAdminCreateUserWithHttpInfo($enterprise_admin_create_user_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminCreateUserWithHttpInfo
     *
     * Create a user
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateUserRequest $enterprise_admin_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminCreateUserWithHttpInfo($enterprise_admin_create_user_request, string $contentType = self::contentTypes['enterpriseAdminCreateUser'][0])
    {
        $request = $this->enterpriseAdminCreateUserRequest($enterprise_admin_create_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminCreateUserAsync
     *
     * Create a user
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateUserRequest $enterprise_admin_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateUserAsync($enterprise_admin_create_user_request, string $contentType = self::contentTypes['enterpriseAdminCreateUser'][0])
    {
        return $this->enterpriseAdminCreateUserAsyncWithHttpInfo($enterprise_admin_create_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminCreateUserAsyncWithHttpInfo
     *
     * Create a user
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateUserRequest $enterprise_admin_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminCreateUserAsyncWithHttpInfo($enterprise_admin_create_user_request, string $contentType = self::contentTypes['enterpriseAdminCreateUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser';
        $request = $this->enterpriseAdminCreateUserRequest($enterprise_admin_create_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminCreateUser'
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminCreateUserRequest $enterprise_admin_create_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminCreateUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminCreateUserRequest($enterprise_admin_create_user_request, string $contentType = self::contentTypes['enterpriseAdminCreateUser'][0])
    {

        // verify the required parameter 'enterprise_admin_create_user_request' is set
        if ($enterprise_admin_create_user_request === null || (is_array($enterprise_admin_create_user_request) && count($enterprise_admin_create_user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_create_user_request when calling enterpriseAdminCreateUser'
            );
        }


        $resourcePath = '/admin/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_create_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_create_user_request));
            } else {
                $httpBody = $enterprise_admin_create_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteGlobalWebhook
     *
     * Delete a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteGlobalWebhook($hook_id, string $contentType = self::contentTypes['enterpriseAdminDeleteGlobalWebhook'][0])
    {
        $this->enterpriseAdminDeleteGlobalWebhookWithHttpInfo($hook_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteGlobalWebhookWithHttpInfo
     *
     * Delete a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteGlobalWebhookWithHttpInfo($hook_id, string $contentType = self::contentTypes['enterpriseAdminDeleteGlobalWebhook'][0])
    {
        $request = $this->enterpriseAdminDeleteGlobalWebhookRequest($hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteGlobalWebhookAsync
     *
     * Delete a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteGlobalWebhookAsync($hook_id, string $contentType = self::contentTypes['enterpriseAdminDeleteGlobalWebhook'][0])
    {
        return $this->enterpriseAdminDeleteGlobalWebhookAsyncWithHttpInfo($hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteGlobalWebhookAsyncWithHttpInfo
     *
     * Delete a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteGlobalWebhookAsyncWithHttpInfo($hook_id, string $contentType = self::contentTypes['enterpriseAdminDeleteGlobalWebhook'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteGlobalWebhookRequest($hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteGlobalWebhook'
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteGlobalWebhookRequest($hook_id, string $contentType = self::contentTypes['enterpriseAdminDeleteGlobalWebhook'][0])
    {

        // verify the required parameter 'hook_id' is set
        if ($hook_id === null || (is_array($hook_id) && count($hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hook_id when calling enterpriseAdminDeleteGlobalWebhook'
            );
        }


        $resourcePath = '/admin/hooks/{hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'hook_id' . '}',
                ObjectSerializer::toPathValue($hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteImpersonationOAuthToken
     *
     * Delete an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteImpersonationOAuthToken($username, string $contentType = self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'][0])
    {
        $this->enterpriseAdminDeleteImpersonationOAuthTokenWithHttpInfo($username, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteImpersonationOAuthTokenWithHttpInfo
     *
     * Delete an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteImpersonationOAuthTokenWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'][0])
    {
        $request = $this->enterpriseAdminDeleteImpersonationOAuthTokenRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteImpersonationOAuthTokenAsync
     *
     * Delete an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteImpersonationOAuthTokenAsync($username, string $contentType = self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'][0])
    {
        return $this->enterpriseAdminDeleteImpersonationOAuthTokenAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteImpersonationOAuthTokenAsyncWithHttpInfo
     *
     * Delete an impersonation OAuth token
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteImpersonationOAuthTokenAsyncWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteImpersonationOAuthTokenRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteImpersonationOAuthToken'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteImpersonationOAuthTokenRequest($username, string $contentType = self::contentTypes['enterpriseAdminDeleteImpersonationOAuthToken'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminDeleteImpersonationOAuthToken'
            );
        }


        $resourcePath = '/admin/users/{username}/authorizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteManageSsh
     *
     * Delete a SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshRequest $ghes_delete_ssh_request ghes_delete_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteManageSsh'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]
     */
    public function enterpriseAdminDeleteManageSsh($ghes_delete_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminDeleteManageSsh'][0])
    {
        list($response) = $this->enterpriseAdminDeleteManageSshWithHttpInfo($ghes_delete_ssh_request, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminDeleteManageSshWithHttpInfo
     *
     * Delete a SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshRequest $ghes_delete_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteManageSsh'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteManageSshWithHttpInfo($ghes_delete_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminDeleteManageSsh'][0])
    {
        $request = $this->enterpriseAdminDeleteManageSshRequest($ghes_delete_ssh_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteManageSshAsync
     *
     * Delete a SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshRequest $ghes_delete_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteManageSshAsync($ghes_delete_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminDeleteManageSsh'][0])
    {
        return $this->enterpriseAdminDeleteManageSshAsyncWithHttpInfo($ghes_delete_ssh_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteManageSshAsyncWithHttpInfo
     *
     * Delete a SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshRequest $ghes_delete_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteManageSshAsyncWithHttpInfo($ghes_delete_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminDeleteManageSsh'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshResponseInner[]';
        $request = $this->enterpriseAdminDeleteManageSshRequest($ghes_delete_ssh_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteManageSsh'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesDeleteSshRequest $ghes_delete_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteManageSshRequest($ghes_delete_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminDeleteManageSsh'][0])
    {

        // verify the required parameter 'ghes_delete_ssh_request' is set
        if ($ghes_delete_ssh_request === null || (is_array($ghes_delete_ssh_request) && count($ghes_delete_ssh_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ghes_delete_ssh_request when calling enterpriseAdminDeleteManageSsh'
            );
        }


        $resourcePath = '/manage/v1/access/ssh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ghes_delete_ssh_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ghes_delete_ssh_request));
            } else {
                $httpBody = $ghes_delete_ssh_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminDeleteManageSsh();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminDeleteManageSsh
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminDeleteManageSsh(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminDeletePersonalAccessToken
     *
     * Delete a personal access token
     *
     * @param  int $token_id The unique identifier of the token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeletePersonalAccessToken($token_id, string $contentType = self::contentTypes['enterpriseAdminDeletePersonalAccessToken'][0])
    {
        $this->enterpriseAdminDeletePersonalAccessTokenWithHttpInfo($token_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDeletePersonalAccessTokenWithHttpInfo
     *
     * Delete a personal access token
     *
     * @param  int $token_id The unique identifier of the token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeletePersonalAccessTokenWithHttpInfo($token_id, string $contentType = self::contentTypes['enterpriseAdminDeletePersonalAccessToken'][0])
    {
        $request = $this->enterpriseAdminDeletePersonalAccessTokenRequest($token_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeletePersonalAccessTokenAsync
     *
     * Delete a personal access token
     *
     * @param  int $token_id The unique identifier of the token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePersonalAccessTokenAsync($token_id, string $contentType = self::contentTypes['enterpriseAdminDeletePersonalAccessToken'][0])
    {
        return $this->enterpriseAdminDeletePersonalAccessTokenAsyncWithHttpInfo($token_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeletePersonalAccessTokenAsyncWithHttpInfo
     *
     * Delete a personal access token
     *
     * @param  int $token_id The unique identifier of the token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePersonalAccessTokenAsyncWithHttpInfo($token_id, string $contentType = self::contentTypes['enterpriseAdminDeletePersonalAccessToken'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeletePersonalAccessTokenRequest($token_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeletePersonalAccessToken'
     *
     * @param  int $token_id The unique identifier of the token. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePersonalAccessToken'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeletePersonalAccessTokenRequest($token_id, string $contentType = self::contentTypes['enterpriseAdminDeletePersonalAccessToken'][0])
    {

        // verify the required parameter 'token_id' is set
        if ($token_id === null || (is_array($token_id) && count($token_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token_id when calling enterpriseAdminDeletePersonalAccessToken'
            );
        }


        $resourcePath = '/admin/tokens/{token_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($token_id !== null) {
            $resourcePath = str_replace(
                '{' . 'token_id' . '}',
                ObjectSerializer::toPathValue($token_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveEnvironment
     *
     * Delete a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeletePreReceiveEnvironment($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'][0])
    {
        $this->enterpriseAdminDeletePreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveEnvironmentWithHttpInfo
     *
     * Delete a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeletePreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'][0])
    {
        $request = $this->enterpriseAdminDeletePreReceiveEnvironmentRequest($pre_receive_environment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveEnvironmentAsync
     *
     * Delete a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePreReceiveEnvironmentAsync($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'][0])
    {
        return $this->enterpriseAdminDeletePreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveEnvironmentAsyncWithHttpInfo
     *
     * Delete a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeletePreReceiveEnvironmentRequest($pre_receive_environment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeletePreReceiveEnvironment'
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeletePreReceiveEnvironmentRequest($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveEnvironment'][0])
    {

        // verify the required parameter 'pre_receive_environment_id' is set
        if ($pre_receive_environment_id === null || (is_array($pre_receive_environment_id) && count($pre_receive_environment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_environment_id when calling enterpriseAdminDeletePreReceiveEnvironment'
            );
        }


        $resourcePath = '/admin/pre-receive-environments/{pre_receive_environment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_environment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_environment_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_environment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveHook
     *
     * Delete a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeletePreReceiveHook($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveHook'][0])
    {
        $this->enterpriseAdminDeletePreReceiveHookWithHttpInfo($pre_receive_hook_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveHookWithHttpInfo
     *
     * Delete a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeletePreReceiveHookWithHttpInfo($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveHook'][0])
    {
        $request = $this->enterpriseAdminDeletePreReceiveHookRequest($pre_receive_hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveHookAsync
     *
     * Delete a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePreReceiveHookAsync($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveHook'][0])
    {
        return $this->enterpriseAdminDeletePreReceiveHookAsyncWithHttpInfo($pre_receive_hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeletePreReceiveHookAsyncWithHttpInfo
     *
     * Delete a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePreReceiveHookAsyncWithHttpInfo($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveHook'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeletePreReceiveHookRequest($pre_receive_hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeletePreReceiveHook'
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeletePreReceiveHookRequest($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminDeletePreReceiveHook'][0])
    {

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminDeletePreReceiveHook'
            );
        }


        $resourcePath = '/admin/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeletePublicKey
     *
     * Delete a public key
     *
     * @param  string $key_ids The unique identifier of the key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeletePublicKey($key_ids, string $contentType = self::contentTypes['enterpriseAdminDeletePublicKey'][0])
    {
        $this->enterpriseAdminDeletePublicKeyWithHttpInfo($key_ids, $contentType);
    }

    /**
     * Operation enterpriseAdminDeletePublicKeyWithHttpInfo
     *
     * Delete a public key
     *
     * @param  string $key_ids The unique identifier of the key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePublicKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeletePublicKeyWithHttpInfo($key_ids, string $contentType = self::contentTypes['enterpriseAdminDeletePublicKey'][0])
    {
        $request = $this->enterpriseAdminDeletePublicKeyRequest($key_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeletePublicKeyAsync
     *
     * Delete a public key
     *
     * @param  string $key_ids The unique identifier of the key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePublicKeyAsync($key_ids, string $contentType = self::contentTypes['enterpriseAdminDeletePublicKey'][0])
    {
        return $this->enterpriseAdminDeletePublicKeyAsyncWithHttpInfo($key_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeletePublicKeyAsyncWithHttpInfo
     *
     * Delete a public key
     *
     * @param  string $key_ids The unique identifier of the key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeletePublicKeyAsyncWithHttpInfo($key_ids, string $contentType = self::contentTypes['enterpriseAdminDeletePublicKey'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeletePublicKeyRequest($key_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeletePublicKey'
     *
     * @param  string $key_ids The unique identifier of the key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeletePublicKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeletePublicKeyRequest($key_ids, string $contentType = self::contentTypes['enterpriseAdminDeletePublicKey'][0])
    {

        // verify the required parameter 'key_ids' is set
        if ($key_ids === null || (is_array($key_ids) && count($key_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key_ids when calling enterpriseAdminDeletePublicKey'
            );
        }


        $resourcePath = '/admin/keys/{key_ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($key_ids !== null) {
            $resourcePath = str_replace(
                '{' . 'key_ids' . '}',
                ObjectSerializer::toPathValue($key_ids),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteScimGroupFromEnterprise
     *
     * Delete a SCIM group from an enterprise
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteScimGroupFromEnterprise($scim_group_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'][0])
    {
        $this->enterpriseAdminDeleteScimGroupFromEnterpriseWithHttpInfo($scim_group_id, $enterprise, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteScimGroupFromEnterpriseWithHttpInfo
     *
     * Delete a SCIM group from an enterprise
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteScimGroupFromEnterpriseWithHttpInfo($scim_group_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'][0])
    {
        $request = $this->enterpriseAdminDeleteScimGroupFromEnterpriseRequest($scim_group_id, $enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteScimGroupFromEnterpriseAsync
     *
     * Delete a SCIM group from an enterprise
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteScimGroupFromEnterpriseAsync($scim_group_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'][0])
    {
        return $this->enterpriseAdminDeleteScimGroupFromEnterpriseAsyncWithHttpInfo($scim_group_id, $enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteScimGroupFromEnterpriseAsyncWithHttpInfo
     *
     * Delete a SCIM group from an enterprise
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteScimGroupFromEnterpriseAsyncWithHttpInfo($scim_group_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteScimGroupFromEnterpriseRequest($scim_group_id, $enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteScimGroupFromEnterprise'
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteScimGroupFromEnterpriseRequest($scim_group_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteScimGroupFromEnterprise'][0])
    {

        // verify the required parameter 'scim_group_id' is set
        if ($scim_group_id === null || (is_array($scim_group_id) && count($scim_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_group_id when calling enterpriseAdminDeleteScimGroupFromEnterprise'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminDeleteScimGroupFromEnterprise'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_group_id' . '}',
                ObjectSerializer::toPathValue($scim_group_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/scim+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerFromEnterprise
     *
     * Delete a self-hosted runner from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteSelfHostedRunnerFromEnterprise($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'][0])
    {
        $this->enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseWithHttpInfo($enterprise, $runner_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseWithHttpInfo
     *
     * Delete a self-hosted runner from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'][0])
    {
        $request = $this->enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest($enterprise, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseAsync
     *
     * Delete a self-hosted runner from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseAsync($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'][0])
    {
        return $this->enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseAsyncWithHttpInfo
     *
     * Delete a self-hosted runner from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest($enterprise, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise
     *
     * Delete a self-hosted runner group from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'][0])
    {
        $this->enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseWithHttpInfo($enterprise, $runner_group_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseWithHttpInfo
     *
     * Delete a self-hosted runner group from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseWithHttpInfo($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'][0])
    {
        $request = $this->enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest($enterprise, $runner_group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseAsync
     *
     * Delete a self-hosted runner group from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseAsync($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'][0])
    {
        return $this->enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseAsyncWithHttpInfo
     *
     * Delete a self-hosted runner group from an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest($enterprise, $runner_group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteUser
     *
     * Delete a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteUser($username, string $contentType = self::contentTypes['enterpriseAdminDeleteUser'][0])
    {
        $this->enterpriseAdminDeleteUserWithHttpInfo($username, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteUserWithHttpInfo
     *
     * Delete a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteUserWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminDeleteUser'][0])
    {
        $request = $this->enterpriseAdminDeleteUserRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteUserAsync
     *
     * Delete a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteUserAsync($username, string $contentType = self::contentTypes['enterpriseAdminDeleteUser'][0])
    {
        return $this->enterpriseAdminDeleteUserAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteUserAsyncWithHttpInfo
     *
     * Delete a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteUserAsyncWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminDeleteUser'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteUserRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteUser'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteUserRequest($username, string $contentType = self::contentTypes['enterpriseAdminDeleteUser'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminDeleteUser'
            );
        }


        $resourcePath = '/admin/users/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDeleteUserFromEnterprise
     *
     * Delete a SCIM user from an enterprise
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDeleteUserFromEnterprise($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'][0])
    {
        $this->enterpriseAdminDeleteUserFromEnterpriseWithHttpInfo($scim_user_id, $enterprise, $contentType);
    }

    /**
     * Operation enterpriseAdminDeleteUserFromEnterpriseWithHttpInfo
     *
     * Delete a SCIM user from an enterprise
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDeleteUserFromEnterpriseWithHttpInfo($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'][0])
    {
        $request = $this->enterpriseAdminDeleteUserFromEnterpriseRequest($scim_user_id, $enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDeleteUserFromEnterpriseAsync
     *
     * Delete a SCIM user from an enterprise
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteUserFromEnterpriseAsync($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'][0])
    {
        return $this->enterpriseAdminDeleteUserFromEnterpriseAsyncWithHttpInfo($scim_user_id, $enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDeleteUserFromEnterpriseAsyncWithHttpInfo
     *
     * Delete a SCIM user from an enterprise
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDeleteUserFromEnterpriseAsyncWithHttpInfo($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDeleteUserFromEnterpriseRequest($scim_user_id, $enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDeleteUserFromEnterprise'
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDeleteUserFromEnterpriseRequest($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminDeleteUserFromEnterprise'][0])
    {

        // verify the required parameter 'scim_user_id' is set
        if ($scim_user_id === null || (is_array($scim_user_id) && count($scim_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_user_id when calling enterpriseAdminDeleteUserFromEnterprise'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminDeleteUserFromEnterprise'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_user_id' . '}',
                ObjectSerializer::toPathValue($scim_user_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/scim+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDemoteSiteAdministrator
     *
     * Demote a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDemoteSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDemoteSiteAdministrator($username, string $contentType = self::contentTypes['enterpriseAdminDemoteSiteAdministrator'][0])
    {
        $this->enterpriseAdminDemoteSiteAdministratorWithHttpInfo($username, $contentType);
    }

    /**
     * Operation enterpriseAdminDemoteSiteAdministratorWithHttpInfo
     *
     * Demote a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDemoteSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDemoteSiteAdministratorWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminDemoteSiteAdministrator'][0])
    {
        $request = $this->enterpriseAdminDemoteSiteAdministratorRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDemoteSiteAdministratorAsync
     *
     * Demote a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDemoteSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDemoteSiteAdministratorAsync($username, string $contentType = self::contentTypes['enterpriseAdminDemoteSiteAdministrator'][0])
    {
        return $this->enterpriseAdminDemoteSiteAdministratorAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDemoteSiteAdministratorAsyncWithHttpInfo
     *
     * Demote a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDemoteSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDemoteSiteAdministratorAsyncWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminDemoteSiteAdministrator'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDemoteSiteAdministratorRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDemoteSiteAdministrator'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDemoteSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDemoteSiteAdministratorRequest($username, string $contentType = self::contentTypes['enterpriseAdminDemoteSiteAdministrator'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminDemoteSiteAdministrator'
            );
        }


        $resourcePath = '/users/{username}/site_admin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise
     *
     * Disable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        $this->enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseWithHttpInfo($enterprise, $org_id, $contentType);
    }

    /**
     * Operation enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseWithHttpInfo
     *
     * Disable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseWithHttpInfo($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest($enterprise, $org_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseAsync
     *
     * Disable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseAsync($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        return $this->enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $org_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseAsyncWithHttpInfo
     *
     * Disable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest($enterprise, $org_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'
            );
        }

        // verify the required parameter 'org_id' is set
        if ($org_id === null || (is_array($org_id) && count($org_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_id when calling enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/organizations/{org_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($org_id !== null) {
            $resourcePath = str_replace(
                '{' . 'org_id' . '}',
                ObjectSerializer::toPathValue($org_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminEnableOrDisableMaintenanceMode
     *
     * Enable or disable maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $maintenance A JSON string with the attributes &#x60;enabled&#x60; and &#x60;when&#x60;.  The possible values for &#x60;enabled&#x60; are &#x60;true&#x60; and &#x60;false&#x60;. When it&#39;s &#x60;false&#x60;, the attribute &#x60;when&#x60; is ignored and the maintenance mode is turned off. &#x60;when&#x60; defines the time period when the maintenance was enabled.  The possible values for &#x60;when&#x60; are &#x60;now&#x60; or any date parseable by [mojombo/chronic](https://github.com/mojombo/chronic). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus
     */
    public function enterpriseAdminEnableOrDisableMaintenanceMode($maintenance, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'][0])
    {
        list($response) = $this->enterpriseAdminEnableOrDisableMaintenanceModeWithHttpInfo($maintenance, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminEnableOrDisableMaintenanceModeWithHttpInfo
     *
     * Enable or disable maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $maintenance A JSON string with the attributes &#x60;enabled&#x60; and &#x60;when&#x60;.  The possible values for &#x60;enabled&#x60; are &#x60;true&#x60; and &#x60;false&#x60;. When it&#39;s &#x60;false&#x60;, the attribute &#x60;when&#x60; is ignored and the maintenance mode is turned off. &#x60;when&#x60; defines the time period when the maintenance was enabled.  The possible values for &#x60;when&#x60; are &#x60;now&#x60; or any date parseable by [mojombo/chronic](https://github.com/mojombo/chronic). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminEnableOrDisableMaintenanceModeWithHttpInfo($maintenance, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'][0])
    {
        $request = $this->enterpriseAdminEnableOrDisableMaintenanceModeRequest($maintenance, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminEnableOrDisableMaintenanceModeAsync
     *
     * Enable or disable maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $maintenance A JSON string with the attributes &#x60;enabled&#x60; and &#x60;when&#x60;.  The possible values for &#x60;enabled&#x60; are &#x60;true&#x60; and &#x60;false&#x60;. When it&#39;s &#x60;false&#x60;, the attribute &#x60;when&#x60; is ignored and the maintenance mode is turned off. &#x60;when&#x60; defines the time period when the maintenance was enabled.  The possible values for &#x60;when&#x60; are &#x60;now&#x60; or any date parseable by [mojombo/chronic](https://github.com/mojombo/chronic). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminEnableOrDisableMaintenanceModeAsync($maintenance, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'][0])
    {
        return $this->enterpriseAdminEnableOrDisableMaintenanceModeAsyncWithHttpInfo($maintenance, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminEnableOrDisableMaintenanceModeAsyncWithHttpInfo
     *
     * Enable or disable maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $maintenance A JSON string with the attributes &#x60;enabled&#x60; and &#x60;when&#x60;.  The possible values for &#x60;enabled&#x60; are &#x60;true&#x60; and &#x60;false&#x60;. When it&#39;s &#x60;false&#x60;, the attribute &#x60;when&#x60; is ignored and the maintenance mode is turned off. &#x60;when&#x60; defines the time period when the maintenance was enabled.  The possible values for &#x60;when&#x60; are &#x60;now&#x60; or any date parseable by [mojombo/chronic](https://github.com/mojombo/chronic). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminEnableOrDisableMaintenanceModeAsyncWithHttpInfo($maintenance, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus';
        $request = $this->enterpriseAdminEnableOrDisableMaintenanceModeRequest($maintenance, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminEnableOrDisableMaintenanceMode'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $maintenance A JSON string with the attributes &#x60;enabled&#x60; and &#x60;when&#x60;.  The possible values for &#x60;enabled&#x60; are &#x60;true&#x60; and &#x60;false&#x60;. When it&#39;s &#x60;false&#x60;, the attribute &#x60;when&#x60; is ignored and the maintenance mode is turned off. &#x60;when&#x60; defines the time period when the maintenance was enabled.  The possible values for &#x60;when&#x60; are &#x60;now&#x60; or any date parseable by [mojombo/chronic](https://github.com/mojombo/chronic). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminEnableOrDisableMaintenanceModeRequest($maintenance, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminEnableOrDisableMaintenanceMode'][0])
    {

        // verify the required parameter 'maintenance' is set
        if ($maintenance === null || (is_array($maintenance) && count($maintenance) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $maintenance when calling enterpriseAdminEnableOrDisableMaintenanceMode'
            );
        }


        $resourcePath = '/setup/api/maintenance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($maintenance !== null) {
            $formParams['maintenance'] = ObjectSerializer::toFormValue($maintenance);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminEnableOrDisableMaintenanceMode();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminEnableOrDisableMaintenanceMode
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminEnableOrDisableMaintenanceMode(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise
     *
     * Enable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        $this->enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseWithHttpInfo($enterprise, $org_id, $contentType);
    }

    /**
     * Operation enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseWithHttpInfo
     *
     * Enable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseWithHttpInfo($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest($enterprise, $org_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseAsync
     *
     * Enable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseAsync($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        return $this->enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $org_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseAsyncWithHttpInfo
     *
     * Enable a selected organization for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest($enterprise, $org_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest($enterprise, $org_id, string $contentType = self::contentTypes['enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'
            );
        }

        // verify the required parameter 'org_id' is set
        if ($org_id === null || (is_array($org_id) && count($org_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_id when calling enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/organizations/{org_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($org_id !== null) {
            $resourcePath = str_replace(
                '{' . 'org_id' . '}',
                ObjectSerializer::toPathValue($org_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetAllAuthorizedSshKeys
     *
     * Get all authorized SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]
     */
    public function enterpriseAdminGetAllAuthorizedSshKeys(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'][0])
    {
        list($response) = $this->enterpriseAdminGetAllAuthorizedSshKeysWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetAllAuthorizedSshKeysWithHttpInfo
     *
     * Get all authorized SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetAllAuthorizedSshKeysWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'][0])
    {
        $request = $this->enterpriseAdminGetAllAuthorizedSshKeysRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetAllAuthorizedSshKeysAsync
     *
     * Get all authorized SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAllAuthorizedSshKeysAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'][0])
    {
        return $this->enterpriseAdminGetAllAuthorizedSshKeysAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetAllAuthorizedSshKeysAsyncWithHttpInfo
     *
     * Get all authorized SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAllAuthorizedSshKeysAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]';
        $request = $this->enterpriseAdminGetAllAuthorizedSshKeysRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetAllAuthorizedSshKeys'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetAllAuthorizedSshKeysRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetAllAuthorizedSshKeys'][0])
    {


        $resourcePath = '/setup/api/settings/authorized-keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetAllAuthorizedSshKeys();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetAllAuthorizedSshKeys
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetAllAuthorizedSshKeys(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetAllStats
     *
     * Get all statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview
     */
    public function enterpriseAdminGetAllStats(string $contentType = self::contentTypes['enterpriseAdminGetAllStats'][0])
    {
        list($response) = $this->enterpriseAdminGetAllStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetAllStatsWithHttpInfo
     *
     * Get all statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetAllStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetAllStats'][0])
    {
        $request = $this->enterpriseAdminGetAllStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetAllStatsAsync
     *
     * Get all statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAllStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetAllStats'][0])
    {
        return $this->enterpriseAdminGetAllStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetAllStatsAsyncWithHttpInfo
     *
     * Get all statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAllStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetAllStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOverview';
        $request = $this->enterpriseAdminGetAllStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetAllStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetAllStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetAllStats'][0])
    {


        $resourcePath = '/enterprise/stats/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetAllowedActionsEnterprise
     *
     * Get allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions
     */
    public function enterpriseAdminGetAllowedActionsEnterprise($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminGetAllowedActionsEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetAllowedActionsEnterpriseWithHttpInfo
     *
     * Get allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetAllowedActionsEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminGetAllowedActionsEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetAllowedActionsEnterpriseAsync
     *
     * Get allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAllowedActionsEnterpriseAsync($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'][0])
    {
        return $this->enterpriseAdminGetAllowedActionsEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetAllowedActionsEnterpriseAsyncWithHttpInfo
     *
     * Get allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAllowedActionsEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions';
        $request = $this->enterpriseAdminGetAllowedActionsEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetAllowedActionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetAllowedActionsEnterpriseRequest($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetAllowedActionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetAllowedActionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/selected-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetAnnouncement
     *
     * Get the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAnnouncement'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement
     */
    public function enterpriseAdminGetAnnouncement(string $contentType = self::contentTypes['enterpriseAdminGetAnnouncement'][0])
    {
        list($response) = $this->enterpriseAdminGetAnnouncementWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetAnnouncementWithHttpInfo
     *
     * Get the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAnnouncement'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetAnnouncementWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetAnnouncement'][0])
    {
        $request = $this->enterpriseAdminGetAnnouncementRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetAnnouncementAsync
     *
     * Get the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAnnouncementAsync(string $contentType = self::contentTypes['enterpriseAdminGetAnnouncement'][0])
    {
        return $this->enterpriseAdminGetAnnouncementAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetAnnouncementAsyncWithHttpInfo
     *
     * Get the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAnnouncementAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetAnnouncement'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement';
        $request = $this->enterpriseAdminGetAnnouncementRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetAnnouncement'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetAnnouncementRequest(string $contentType = self::contentTypes['enterpriseAdminGetAnnouncement'][0])
    {


        $resourcePath = '/enterprise/announcement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetAuditLog
     *
     * Get the audit log for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $phrase A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.12/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/searching-the-audit-log-for-your-enterprise#searching-the-audit-log). (optional)
     * @param  string $include The event types to include:  - &#x60;web&#x60; - returns web (non-Git) events. - &#x60;git&#x60; - returns Git events. - &#x60;all&#x60; - returns both web and Git events.  The default is &#x60;web&#x60;. (optional)
     * @param  string $after A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor. (optional)
     * @param  string $before A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. (optional)
     * @param  string $order The order of audit log events. To list newest events first, specify &#x60;desc&#x60;. To list oldest events first, specify &#x60;asc&#x60;.  The default is &#x60;desc&#x60;. (optional)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAuditLog'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]
     */
    public function enterpriseAdminGetAuditLog($enterprise, $phrase = null, $include = null, $after = null, $before = null, $order = null, $page = 1, $per_page = 30, string $contentType = self::contentTypes['enterpriseAdminGetAuditLog'][0])
    {
        list($response) = $this->enterpriseAdminGetAuditLogWithHttpInfo($enterprise, $phrase, $include, $after, $before, $order, $page, $per_page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetAuditLogWithHttpInfo
     *
     * Get the audit log for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $phrase A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.12/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/searching-the-audit-log-for-your-enterprise#searching-the-audit-log). (optional)
     * @param  string $include The event types to include:  - &#x60;web&#x60; - returns web (non-Git) events. - &#x60;git&#x60; - returns Git events. - &#x60;all&#x60; - returns both web and Git events.  The default is &#x60;web&#x60;. (optional)
     * @param  string $after A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor. (optional)
     * @param  string $before A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. (optional)
     * @param  string $order The order of audit log events. To list newest events first, specify &#x60;desc&#x60;. To list oldest events first, specify &#x60;asc&#x60;.  The default is &#x60;desc&#x60;. (optional)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAuditLog'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetAuditLogWithHttpInfo($enterprise, $phrase = null, $include = null, $after = null, $before = null, $order = null, $page = 1, $per_page = 30, string $contentType = self::contentTypes['enterpriseAdminGetAuditLog'][0])
    {
        $request = $this->enterpriseAdminGetAuditLogRequest($enterprise, $phrase, $include, $after, $before, $order, $page, $per_page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetAuditLogAsync
     *
     * Get the audit log for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $phrase A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.12/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/searching-the-audit-log-for-your-enterprise#searching-the-audit-log). (optional)
     * @param  string $include The event types to include:  - &#x60;web&#x60; - returns web (non-Git) events. - &#x60;git&#x60; - returns Git events. - &#x60;all&#x60; - returns both web and Git events.  The default is &#x60;web&#x60;. (optional)
     * @param  string $after A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor. (optional)
     * @param  string $before A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. (optional)
     * @param  string $order The order of audit log events. To list newest events first, specify &#x60;desc&#x60;. To list oldest events first, specify &#x60;asc&#x60;.  The default is &#x60;desc&#x60;. (optional)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAuditLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAuditLogAsync($enterprise, $phrase = null, $include = null, $after = null, $before = null, $order = null, $page = 1, $per_page = 30, string $contentType = self::contentTypes['enterpriseAdminGetAuditLog'][0])
    {
        return $this->enterpriseAdminGetAuditLogAsyncWithHttpInfo($enterprise, $phrase, $include, $after, $before, $order, $page, $per_page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetAuditLogAsyncWithHttpInfo
     *
     * Get the audit log for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $phrase A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.12/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/searching-the-audit-log-for-your-enterprise#searching-the-audit-log). (optional)
     * @param  string $include The event types to include:  - &#x60;web&#x60; - returns web (non-Git) events. - &#x60;git&#x60; - returns Git events. - &#x60;all&#x60; - returns both web and Git events.  The default is &#x60;web&#x60;. (optional)
     * @param  string $after A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor. (optional)
     * @param  string $before A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. (optional)
     * @param  string $order The order of audit log events. To list newest events first, specify &#x60;desc&#x60;. To list oldest events first, specify &#x60;asc&#x60;.  The default is &#x60;desc&#x60;. (optional)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAuditLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetAuditLogAsyncWithHttpInfo($enterprise, $phrase = null, $include = null, $after = null, $before = null, $order = null, $page = 1, $per_page = 30, string $contentType = self::contentTypes['enterpriseAdminGetAuditLog'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\AuditLogEvent[]';
        $request = $this->enterpriseAdminGetAuditLogRequest($enterprise, $phrase, $include, $after, $before, $order, $page, $per_page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetAuditLog'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $phrase A search phrase. For more information, see [Searching the audit log](https://docs.github.com/enterprise-server@3.12/admin/monitoring-activity-in-your-enterprise/reviewing-audit-logs-for-your-enterprise/searching-the-audit-log-for-your-enterprise#searching-the-audit-log). (optional)
     * @param  string $include The event types to include:  - &#x60;web&#x60; - returns web (non-Git) events. - &#x60;git&#x60; - returns Git events. - &#x60;all&#x60; - returns both web and Git events.  The default is &#x60;web&#x60;. (optional)
     * @param  string $after A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor. (optional)
     * @param  string $before A cursor, as given in the [Link header](https://docs.github.com/enterprise-server@3.12/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. (optional)
     * @param  string $order The order of audit log events. To list newest events first, specify &#x60;desc&#x60;. To list oldest events first, specify &#x60;asc&#x60;.  The default is &#x60;desc&#x60;. (optional)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetAuditLog'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetAuditLogRequest($enterprise, $phrase = null, $include = null, $after = null, $before = null, $order = null, $page = 1, $per_page = 30, string $contentType = self::contentTypes['enterpriseAdminGetAuditLog'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetAuditLog'
            );
        }









        $resourcePath = '/enterprises/{enterprise}/audit-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phrase,
            'phrase', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include,
            'include', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetChecksSystemRequirements
     *
     * Get the system requirement check results for configured cluster nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetChecksSystemRequirements'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements
     */
    public function enterpriseAdminGetChecksSystemRequirements(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetChecksSystemRequirements'][0])
    {
        list($response) = $this->enterpriseAdminGetChecksSystemRequirementsWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetChecksSystemRequirementsWithHttpInfo
     *
     * Get the system requirement check results for configured cluster nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetChecksSystemRequirements'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetChecksSystemRequirementsWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetChecksSystemRequirements'][0])
    {
        $request = $this->enterpriseAdminGetChecksSystemRequirementsRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetChecksSystemRequirementsAsync
     *
     * Get the system requirement check results for configured cluster nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetChecksSystemRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetChecksSystemRequirementsAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetChecksSystemRequirements'][0])
    {
        return $this->enterpriseAdminGetChecksSystemRequirementsAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetChecksSystemRequirementsAsyncWithHttpInfo
     *
     * Get the system requirement check results for configured cluster nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetChecksSystemRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetChecksSystemRequirementsAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetChecksSystemRequirements'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesChecksSystemRequirements';
        $request = $this->enterpriseAdminGetChecksSystemRequirementsRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetChecksSystemRequirements'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetChecksSystemRequirements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetChecksSystemRequirementsRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetChecksSystemRequirements'][0])
    {


        $resourcePath = '/manage/v1/checks/system-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetChecksSystemRequirements();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetChecksSystemRequirements
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetChecksSystemRequirements(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetCommentStats
     *
     * Get comment statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetCommentStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview
     */
    public function enterpriseAdminGetCommentStats(string $contentType = self::contentTypes['enterpriseAdminGetCommentStats'][0])
    {
        list($response) = $this->enterpriseAdminGetCommentStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetCommentStatsWithHttpInfo
     *
     * Get comment statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetCommentStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetCommentStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetCommentStats'][0])
    {
        $request = $this->enterpriseAdminGetCommentStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetCommentStatsAsync
     *
     * Get comment statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetCommentStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetCommentStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetCommentStats'][0])
    {
        return $this->enterpriseAdminGetCommentStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetCommentStatsAsyncWithHttpInfo
     *
     * Get comment statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetCommentStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetCommentStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetCommentStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseCommentOverview';
        $request = $this->enterpriseAdminGetCommentStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetCommentStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetCommentStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetCommentStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetCommentStats'][0])
    {


        $resourcePath = '/enterprise/stats/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetConfigNodes
     *
     * Get GHES node metadata for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigNodes'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes
     */
    public function enterpriseAdminGetConfigNodes($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigNodes'][0])
    {
        list($response) = $this->enterpriseAdminGetConfigNodesWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetConfigNodesWithHttpInfo
     *
     * Get GHES node metadata for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigNodes'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetConfigNodesWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigNodes'][0])
    {
        $request = $this->enterpriseAdminGetConfigNodesRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetConfigNodesAsync
     *
     * Get GHES node metadata for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigNodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetConfigNodesAsync($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigNodes'][0])
    {
        return $this->enterpriseAdminGetConfigNodesAsyncWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetConfigNodesAsyncWithHttpInfo
     *
     * Get GHES node metadata for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigNodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetConfigNodesAsyncWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigNodes'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesConfigNodes';
        $request = $this->enterpriseAdminGetConfigNodesRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetConfigNodes'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigNodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetConfigNodesRequest($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigNodes'][0])
    {




        $resourcePath = '/manage/v1/config/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_roles,
            'cluster_roles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetConfigNodes();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetConfigNodes
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetConfigNodes(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetConfigurationStatus
     *
     * Get the configuration status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigurationStatus'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus
     */
    public function enterpriseAdminGetConfigurationStatus(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigurationStatus'][0])
    {
        list($response) = $this->enterpriseAdminGetConfigurationStatusWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetConfigurationStatusWithHttpInfo
     *
     * Get the configuration status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigurationStatus'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetConfigurationStatusWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigurationStatus'][0])
    {
        $request = $this->enterpriseAdminGetConfigurationStatusRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetConfigurationStatusAsync
     *
     * Get the configuration status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigurationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetConfigurationStatusAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigurationStatus'][0])
    {
        return $this->enterpriseAdminGetConfigurationStatusAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetConfigurationStatusAsyncWithHttpInfo
     *
     * Get the configuration status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigurationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetConfigurationStatusAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigurationStatus'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ConfigurationStatus';
        $request = $this->enterpriseAdminGetConfigurationStatusRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetConfigurationStatus'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetConfigurationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetConfigurationStatusRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetConfigurationStatus'][0])
    {


        $resourcePath = '/setup/api/configcheck';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetConfigurationStatus();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetConfigurationStatus
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetConfigurationStatus(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetDownloadStatusForPreReceiveEnvironment
     *
     * Get the download status for a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus
     */
    public function enterpriseAdminGetDownloadStatusForPreReceiveEnvironment($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'][0])
    {
        list($response) = $this->enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentWithHttpInfo
     *
     * Get the download status for a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'][0])
    {
        $request = $this->enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentRequest($pre_receive_environment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentAsync
     *
     * Get the download status for a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentAsync($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'][0])
    {
        return $this->enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentAsyncWithHttpInfo
     *
     * Get the download status for a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus';
        $request = $this->enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentRequest($pre_receive_environment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetDownloadStatusForPreReceiveEnvironmentRequest($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'][0])
    {

        // verify the required parameter 'pre_receive_environment_id' is set
        if ($pre_receive_environment_id === null || (is_array($pre_receive_environment_id) && count($pre_receive_environment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_environment_id when calling enterpriseAdminGetDownloadStatusForPreReceiveEnvironment'
            );
        }


        $resourcePath = '/admin/pre-receive-environments/{pre_receive_environment_id}/downloads/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_environment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_environment_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_environment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetGistStats
     *
     * Get gist statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGistStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview
     */
    public function enterpriseAdminGetGistStats(string $contentType = self::contentTypes['enterpriseAdminGetGistStats'][0])
    {
        list($response) = $this->enterpriseAdminGetGistStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetGistStatsWithHttpInfo
     *
     * Get gist statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGistStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetGistStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetGistStats'][0])
    {
        $request = $this->enterpriseAdminGetGistStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetGistStatsAsync
     *
     * Get gist statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGistStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetGistStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetGistStats'][0])
    {
        return $this->enterpriseAdminGetGistStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetGistStatsAsyncWithHttpInfo
     *
     * Get gist statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGistStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetGistStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetGistStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseGistOverview';
        $request = $this->enterpriseAdminGetGistStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetGistStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGistStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetGistStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetGistStats'][0])
    {


        $resourcePath = '/enterprise/stats/gists';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetGithubActionsPermissionsEnterprise
     *
     * Get GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions
     */
    public function enterpriseAdminGetGithubActionsPermissionsEnterprise($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminGetGithubActionsPermissionsEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetGithubActionsPermissionsEnterpriseWithHttpInfo
     *
     * Get GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetGithubActionsPermissionsEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminGetGithubActionsPermissionsEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetGithubActionsPermissionsEnterpriseAsync
     *
     * Get GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetGithubActionsPermissionsEnterpriseAsync($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'][0])
    {
        return $this->enterpriseAdminGetGithubActionsPermissionsEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetGithubActionsPermissionsEnterpriseAsyncWithHttpInfo
     *
     * Get GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetGithubActionsPermissionsEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ActionsEnterprisePermissions';
        $request = $this->enterpriseAdminGetGithubActionsPermissionsEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetGithubActionsPermissionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetGithubActionsPermissionsEnterpriseRequest($enterprise, string $contentType = self::contentTypes['enterpriseAdminGetGithubActionsPermissionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetGithubActionsPermissionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetGlobalWebhook
     *
     * Get a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook
     */
    public function enterpriseAdminGetGlobalWebhook($hook_id, string $contentType = self::contentTypes['enterpriseAdminGetGlobalWebhook'][0])
    {
        list($response) = $this->enterpriseAdminGetGlobalWebhookWithHttpInfo($hook_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetGlobalWebhookWithHttpInfo
     *
     * Get a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetGlobalWebhookWithHttpInfo($hook_id, string $contentType = self::contentTypes['enterpriseAdminGetGlobalWebhook'][0])
    {
        $request = $this->enterpriseAdminGetGlobalWebhookRequest($hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetGlobalWebhookAsync
     *
     * Get a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetGlobalWebhookAsync($hook_id, string $contentType = self::contentTypes['enterpriseAdminGetGlobalWebhook'][0])
    {
        return $this->enterpriseAdminGetGlobalWebhookAsyncWithHttpInfo($hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetGlobalWebhookAsyncWithHttpInfo
     *
     * Get a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetGlobalWebhookAsyncWithHttpInfo($hook_id, string $contentType = self::contentTypes['enterpriseAdminGetGlobalWebhook'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook';
        $request = $this->enterpriseAdminGetGlobalWebhookRequest($hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetGlobalWebhook'
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetGlobalWebhookRequest($hook_id, string $contentType = self::contentTypes['enterpriseAdminGetGlobalWebhook'][0])
    {

        // verify the required parameter 'hook_id' is set
        if ($hook_id === null || (is_array($hook_id) && count($hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hook_id when calling enterpriseAdminGetGlobalWebhook'
            );
        }


        $resourcePath = '/admin/hooks/{hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'hook_id' . '}',
                ObjectSerializer::toPathValue($hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetHooksStats
     *
     * Get hooks statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetHooksStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview
     */
    public function enterpriseAdminGetHooksStats(string $contentType = self::contentTypes['enterpriseAdminGetHooksStats'][0])
    {
        list($response) = $this->enterpriseAdminGetHooksStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetHooksStatsWithHttpInfo
     *
     * Get hooks statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetHooksStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetHooksStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetHooksStats'][0])
    {
        $request = $this->enterpriseAdminGetHooksStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetHooksStatsAsync
     *
     * Get hooks statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetHooksStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetHooksStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetHooksStats'][0])
    {
        return $this->enterpriseAdminGetHooksStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetHooksStatsAsyncWithHttpInfo
     *
     * Get hooks statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetHooksStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetHooksStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetHooksStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseHookOverview';
        $request = $this->enterpriseAdminGetHooksStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetHooksStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetHooksStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetHooksStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetHooksStats'][0])
    {


        $resourcePath = '/enterprise/stats/hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetIssueStats
     *
     * Get issue statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetIssueStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview
     */
    public function enterpriseAdminGetIssueStats(string $contentType = self::contentTypes['enterpriseAdminGetIssueStats'][0])
    {
        list($response) = $this->enterpriseAdminGetIssueStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetIssueStatsWithHttpInfo
     *
     * Get issue statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetIssueStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetIssueStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetIssueStats'][0])
    {
        $request = $this->enterpriseAdminGetIssueStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetIssueStatsAsync
     *
     * Get issue statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetIssueStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetIssueStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetIssueStats'][0])
    {
        return $this->enterpriseAdminGetIssueStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetIssueStatsAsyncWithHttpInfo
     *
     * Get issue statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetIssueStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetIssueStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetIssueStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseIssueOverview';
        $request = $this->enterpriseAdminGetIssueStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetIssueStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetIssueStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetIssueStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetIssueStats'][0])
    {


        $resourcePath = '/enterprise/stats/issues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetLicenseInformation
     *
     * Get license information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetLicenseInformation'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo
     */
    public function enterpriseAdminGetLicenseInformation(string $contentType = self::contentTypes['enterpriseAdminGetLicenseInformation'][0])
    {
        list($response) = $this->enterpriseAdminGetLicenseInformationWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetLicenseInformationWithHttpInfo
     *
     * Get license information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetLicenseInformation'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetLicenseInformationWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetLicenseInformation'][0])
    {
        $request = $this->enterpriseAdminGetLicenseInformationRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetLicenseInformationAsync
     *
     * Get license information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetLicenseInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetLicenseInformationAsync(string $contentType = self::contentTypes['enterpriseAdminGetLicenseInformation'][0])
    {
        return $this->enterpriseAdminGetLicenseInformationAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetLicenseInformationAsyncWithHttpInfo
     *
     * Get license information
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetLicenseInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetLicenseInformationAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetLicenseInformation'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LicenseInfo';
        $request = $this->enterpriseAdminGetLicenseInformationRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetLicenseInformation'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetLicenseInformation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetLicenseInformationRequest(string $contentType = self::contentTypes['enterpriseAdminGetLicenseInformation'][0])
    {


        $resourcePath = '/enterprise/settings/license';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetMaintenanceStatus
     *
     * Get the maintenance status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMaintenanceStatus'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus
     */
    public function enterpriseAdminGetMaintenanceStatus(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetMaintenanceStatus'][0])
    {
        list($response) = $this->enterpriseAdminGetMaintenanceStatusWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetMaintenanceStatusWithHttpInfo
     *
     * Get the maintenance status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMaintenanceStatus'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetMaintenanceStatusWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetMaintenanceStatus'][0])
    {
        $request = $this->enterpriseAdminGetMaintenanceStatusRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetMaintenanceStatusAsync
     *
     * Get the maintenance status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMaintenanceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetMaintenanceStatusAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetMaintenanceStatus'][0])
    {
        return $this->enterpriseAdminGetMaintenanceStatusAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetMaintenanceStatusAsyncWithHttpInfo
     *
     * Get the maintenance status
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMaintenanceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetMaintenanceStatusAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetMaintenanceStatus'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MaintenanceStatus';
        $request = $this->enterpriseAdminGetMaintenanceStatusRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetMaintenanceStatus'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMaintenanceStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetMaintenanceStatusRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetMaintenanceStatus'][0])
    {


        $resourcePath = '/setup/api/maintenance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetMaintenanceStatus();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetMaintenanceStatus
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetMaintenanceStatus(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetManageMaintenance
     *
     * Get the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]
     */
    public function enterpriseAdminGetManageMaintenance($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageMaintenance'][0])
    {
        list($response) = $this->enterpriseAdminGetManageMaintenanceWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetManageMaintenanceWithHttpInfo
     *
     * Get the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetManageMaintenanceWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageMaintenance'][0])
    {
        $request = $this->enterpriseAdminGetManageMaintenanceRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetManageMaintenanceAsync
     *
     * Get the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageMaintenanceAsync($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageMaintenance'][0])
    {
        return $this->enterpriseAdminGetManageMaintenanceAsyncWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetManageMaintenanceAsyncWithHttpInfo
     *
     * Get the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageMaintenanceAsyncWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageMaintenance'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetMaintenanceInner[]';
        $request = $this->enterpriseAdminGetManageMaintenanceRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetManageMaintenance'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetManageMaintenanceRequest($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageMaintenance'][0])
    {




        $resourcePath = '/manage/v1/maintenance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_roles,
            'cluster_roles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetManageMaintenance();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetManageMaintenance
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetManageMaintenance(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetManageSettings
     *
     * Get the status of a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $run_id The unique run ID of the &#x60;ghe-config-apply&#x60; run. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response
     */
    public function enterpriseAdminGetManageSettings($run_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings'][0])
    {
        list($response) = $this->enterpriseAdminGetManageSettingsWithHttpInfo($run_id, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetManageSettingsWithHttpInfo
     *
     * Get the status of a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $run_id The unique run ID of the &#x60;ghe-config-apply&#x60; run. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetManageSettingsWithHttpInfo($run_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings'][0])
    {
        $request = $this->enterpriseAdminGetManageSettingsRequest($run_id, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetManageSettingsAsync
     *
     * Get the status of a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $run_id The unique run ID of the &#x60;ghe-config-apply&#x60; run. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettingsAsync($run_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings'][0])
    {
        return $this->enterpriseAdminGetManageSettingsAsyncWithHttpInfo($run_id, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetManageSettingsAsyncWithHttpInfo
     *
     * Get the status of a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $run_id The unique run ID of the &#x60;ghe-config-apply&#x60; run. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettingsAsyncWithHttpInfo($run_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response';
        $request = $this->enterpriseAdminGetManageSettingsRequest($run_id, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetManageSettings'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $run_id The unique run ID of the &#x60;ghe-config-apply&#x60; run. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetManageSettingsRequest($run_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings'][0])
    {



        $resourcePath = '/manage/v1/config/apply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $run_id,
            'run_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetManageSettings();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetManageSettings
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetManageSettings(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetManageSettings_0
     *
     * Trigger a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettingsRequest $enterprise_admin_get_manage_settings_request enterprise_admin_get_manage_settings_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_0'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1
     */
    public function enterpriseAdminGetManageSettings_0($enterprise_admin_get_manage_settings_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_0'][0])
    {
        list($response) = $this->enterpriseAdminGetManageSettings_0WithHttpInfo($enterprise_admin_get_manage_settings_request, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetManageSettings_0WithHttpInfo
     *
     * Trigger a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettingsRequest $enterprise_admin_get_manage_settings_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_0'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetManageSettings_0WithHttpInfo($enterprise_admin_get_manage_settings_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_0'][0])
    {
        $request = $this->enterpriseAdminGetManageSettings_0Request($enterprise_admin_get_manage_settings_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetManageSettings_0Async
     *
     * Trigger a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettingsRequest $enterprise_admin_get_manage_settings_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_0'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettings_0Async($enterprise_admin_get_manage_settings_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_0'][0])
    {
        return $this->enterpriseAdminGetManageSettings_0AsyncWithHttpInfo($enterprise_admin_get_manage_settings_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetManageSettings_0AsyncWithHttpInfo
     *
     * Trigger a ghe-config-apply run
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettingsRequest $enterprise_admin_get_manage_settings_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_0'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettings_0AsyncWithHttpInfo($enterprise_admin_get_manage_settings_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_0'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response1';
        $request = $this->enterpriseAdminGetManageSettings_0Request($enterprise_admin_get_manage_settings_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetManageSettings_0'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettingsRequest $enterprise_admin_get_manage_settings_request (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_0'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetManageSettings_0Request($enterprise_admin_get_manage_settings_request = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_0'][0])
    {



        $resourcePath = '/manage/v1/config/apply';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_get_manage_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_get_manage_settings_request));
            } else {
                $httpBody = $enterprise_admin_get_manage_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetManageSettings_0();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetManageSettings_0
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetManageSettings_0(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetManageSettings_1
     *
     * List events from ghe-config-apply
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $last_request_id The unique ID of the last response from a host, used for pagination. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_1'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2
     */
    public function enterpriseAdminGetManageSettings_1($last_request_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_1'][0])
    {
        list($response) = $this->enterpriseAdminGetManageSettings_1WithHttpInfo($last_request_id, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetManageSettings_1WithHttpInfo
     *
     * List events from ghe-config-apply
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $last_request_id The unique ID of the last response from a host, used for pagination. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_1'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetManageSettings_1WithHttpInfo($last_request_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_1'][0])
    {
        $request = $this->enterpriseAdminGetManageSettings_1Request($last_request_id, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetManageSettings_1Async
     *
     * List events from ghe-config-apply
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $last_request_id The unique ID of the last response from a host, used for pagination. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettings_1Async($last_request_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_1'][0])
    {
        return $this->enterpriseAdminGetManageSettings_1AsyncWithHttpInfo($last_request_id, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetManageSettings_1AsyncWithHttpInfo
     *
     * List events from ghe-config-apply
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $last_request_id The unique ID of the last response from a host, used for pagination. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettings_1AsyncWithHttpInfo($last_request_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_1'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminGetManageSettings200Response2';
        $request = $this->enterpriseAdminGetManageSettings_1Request($last_request_id, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetManageSettings_1'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $last_request_id The unique ID of the last response from a host, used for pagination. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetManageSettings_1Request($last_request_id = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_1'][0])
    {



        $resourcePath = '/manage/v1/config/apply/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_request_id,
            'last_request_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetManageSettings_1();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetManageSettings_1
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetManageSettings_1(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetManageSettings_2
     *
     * Get the GHES settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_2'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings
     */
    public function enterpriseAdminGetManageSettings_2(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_2'][0])
    {
        list($response) = $this->enterpriseAdminGetManageSettings_2WithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetManageSettings_2WithHttpInfo
     *
     * Get the GHES settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_2'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetManageSettings_2WithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_2'][0])
    {
        $request = $this->enterpriseAdminGetManageSettings_2Request($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetManageSettings_2Async
     *
     * Get the GHES settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettings_2Async(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_2'][0])
    {
        return $this->enterpriseAdminGetManageSettings_2AsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetManageSettings_2AsyncWithHttpInfo
     *
     * Get the GHES settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSettings_2AsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_2'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSettings';
        $request = $this->enterpriseAdminGetManageSettings_2Request($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetManageSettings_2'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSettings_2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetManageSettings_2Request(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSettings_2'][0])
    {


        $resourcePath = '/manage/v1/config/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetManageSettings_2();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetManageSettings_2
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetManageSettings_2(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetManageSsh
     *
     * Get the configured SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSsh'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]
     */
    public function enterpriseAdminGetManageSsh(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSsh'][0])
    {
        list($response) = $this->enterpriseAdminGetManageSshWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetManageSshWithHttpInfo
     *
     * Get the configured SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSsh'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetManageSshWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSsh'][0])
    {
        $request = $this->enterpriseAdminGetManageSshRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetManageSshAsync
     *
     * Get the configured SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSshAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSsh'][0])
    {
        return $this->enterpriseAdminGetManageSshAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetManageSshAsyncWithHttpInfo
     *
     * Get the configured SSH keys
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetManageSshAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSsh'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesGetSshInner[]';
        $request = $this->enterpriseAdminGetManageSshRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetManageSsh'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetManageSshRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetManageSsh'][0])
    {


        $resourcePath = '/manage/v1/access/ssh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetManageSsh();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetManageSsh
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetManageSsh(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetMilestoneStats
     *
     * Get milestone statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMilestoneStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview
     */
    public function enterpriseAdminGetMilestoneStats(string $contentType = self::contentTypes['enterpriseAdminGetMilestoneStats'][0])
    {
        list($response) = $this->enterpriseAdminGetMilestoneStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetMilestoneStatsWithHttpInfo
     *
     * Get milestone statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMilestoneStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetMilestoneStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetMilestoneStats'][0])
    {
        $request = $this->enterpriseAdminGetMilestoneStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetMilestoneStatsAsync
     *
     * Get milestone statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMilestoneStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetMilestoneStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetMilestoneStats'][0])
    {
        return $this->enterpriseAdminGetMilestoneStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetMilestoneStatsAsyncWithHttpInfo
     *
     * Get milestone statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMilestoneStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetMilestoneStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetMilestoneStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseMilestoneOverview';
        $request = $this->enterpriseAdminGetMilestoneStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetMilestoneStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetMilestoneStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetMilestoneStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetMilestoneStats'][0])
    {


        $resourcePath = '/enterprise/stats/milestones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetOrgStats
     *
     * Get organization statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetOrgStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview
     */
    public function enterpriseAdminGetOrgStats(string $contentType = self::contentTypes['enterpriseAdminGetOrgStats'][0])
    {
        list($response) = $this->enterpriseAdminGetOrgStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetOrgStatsWithHttpInfo
     *
     * Get organization statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetOrgStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetOrgStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetOrgStats'][0])
    {
        $request = $this->enterpriseAdminGetOrgStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetOrgStatsAsync
     *
     * Get organization statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetOrgStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetOrgStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetOrgStats'][0])
    {
        return $this->enterpriseAdminGetOrgStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetOrgStatsAsyncWithHttpInfo
     *
     * Get organization statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetOrgStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetOrgStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetOrgStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseOrganizationOverview';
        $request = $this->enterpriseAdminGetOrgStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetOrgStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetOrgStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetOrgStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetOrgStats'][0])
    {


        $resourcePath = '/enterprise/stats/orgs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetPagesStats
     *
     * Get pages statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPagesStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview
     */
    public function enterpriseAdminGetPagesStats(string $contentType = self::contentTypes['enterpriseAdminGetPagesStats'][0])
    {
        list($response) = $this->enterpriseAdminGetPagesStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetPagesStatsWithHttpInfo
     *
     * Get pages statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPagesStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetPagesStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetPagesStats'][0])
    {
        $request = $this->enterpriseAdminGetPagesStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetPagesStatsAsync
     *
     * Get pages statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPagesStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPagesStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetPagesStats'][0])
    {
        return $this->enterpriseAdminGetPagesStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetPagesStatsAsyncWithHttpInfo
     *
     * Get pages statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPagesStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPagesStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetPagesStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePageOverview';
        $request = $this->enterpriseAdminGetPagesStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetPagesStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPagesStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetPagesStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetPagesStats'][0])
    {


        $resourcePath = '/enterprise/stats/pages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveEnvironment
     *
     * Get a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment
     */
    public function enterpriseAdminGetPreReceiveEnvironment($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'][0])
    {
        list($response) = $this->enterpriseAdminGetPreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetPreReceiveEnvironmentWithHttpInfo
     *
     * Get a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetPreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'][0])
    {
        $request = $this->enterpriseAdminGetPreReceiveEnvironmentRequest($pre_receive_environment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetPreReceiveEnvironmentAsync
     *
     * Get a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveEnvironmentAsync($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'][0])
    {
        return $this->enterpriseAdminGetPreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveEnvironmentAsyncWithHttpInfo
     *
     * Get a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment';
        $request = $this->enterpriseAdminGetPreReceiveEnvironmentRequest($pre_receive_environment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetPreReceiveEnvironment'
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetPreReceiveEnvironmentRequest($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveEnvironment'][0])
    {

        // verify the required parameter 'pre_receive_environment_id' is set
        if ($pre_receive_environment_id === null || (is_array($pre_receive_environment_id) && count($pre_receive_environment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_environment_id when calling enterpriseAdminGetPreReceiveEnvironment'
            );
        }


        $resourcePath = '/admin/pre-receive-environments/{pre_receive_environment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_environment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_environment_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_environment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHook
     *
     * Get a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook
     */
    public function enterpriseAdminGetPreReceiveHook($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHook'][0])
    {
        list($response) = $this->enterpriseAdminGetPreReceiveHookWithHttpInfo($pre_receive_hook_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookWithHttpInfo
     *
     * Get a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetPreReceiveHookWithHttpInfo($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHook'][0])
    {
        $request = $this->enterpriseAdminGetPreReceiveHookRequest($pre_receive_hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookAsync
     *
     * Get a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveHookAsync($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHook'][0])
    {
        return $this->enterpriseAdminGetPreReceiveHookAsyncWithHttpInfo($pre_receive_hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookAsyncWithHttpInfo
     *
     * Get a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveHookAsyncWithHttpInfo($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHook'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook';
        $request = $this->enterpriseAdminGetPreReceiveHookRequest($pre_receive_hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetPreReceiveHook'
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetPreReceiveHookRequest($pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHook'][0])
    {

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminGetPreReceiveHook'
            );
        }


        $resourcePath = '/admin/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForOrg
     *
     * Get a pre-receive hook for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook
     */
    public function enterpriseAdminGetPreReceiveHookForOrg($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'][0])
    {
        list($response) = $this->enterpriseAdminGetPreReceiveHookForOrgWithHttpInfo($org, $pre_receive_hook_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForOrgWithHttpInfo
     *
     * Get a pre-receive hook for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetPreReceiveHookForOrgWithHttpInfo($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'][0])
    {
        $request = $this->enterpriseAdminGetPreReceiveHookForOrgRequest($org, $pre_receive_hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForOrgAsync
     *
     * Get a pre-receive hook for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveHookForOrgAsync($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'][0])
    {
        return $this->enterpriseAdminGetPreReceiveHookForOrgAsyncWithHttpInfo($org, $pre_receive_hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForOrgAsyncWithHttpInfo
     *
     * Get a pre-receive hook for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveHookForOrgAsyncWithHttpInfo($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook';
        $request = $this->enterpriseAdminGetPreReceiveHookForOrgRequest($org, $pre_receive_hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetPreReceiveHookForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetPreReceiveHookForOrgRequest($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling enterpriseAdminGetPreReceiveHookForOrg'
            );
        }

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminGetPreReceiveHookForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForRepo
     *
     * Get a pre-receive hook for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook
     */
    public function enterpriseAdminGetPreReceiveHookForRepo($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'][0])
    {
        list($response) = $this->enterpriseAdminGetPreReceiveHookForRepoWithHttpInfo($owner, $repo, $pre_receive_hook_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForRepoWithHttpInfo
     *
     * Get a pre-receive hook for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetPreReceiveHookForRepoWithHttpInfo($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'][0])
    {
        $request = $this->enterpriseAdminGetPreReceiveHookForRepoRequest($owner, $repo, $pre_receive_hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForRepoAsync
     *
     * Get a pre-receive hook for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveHookForRepoAsync($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'][0])
    {
        return $this->enterpriseAdminGetPreReceiveHookForRepoAsyncWithHttpInfo($owner, $repo, $pre_receive_hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetPreReceiveHookForRepoAsyncWithHttpInfo
     *
     * Get a pre-receive hook for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPreReceiveHookForRepoAsyncWithHttpInfo($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook';
        $request = $this->enterpriseAdminGetPreReceiveHookForRepoRequest($owner, $repo, $pre_receive_hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetPreReceiveHookForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetPreReceiveHookForRepoRequest($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminGetPreReceiveHookForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling enterpriseAdminGetPreReceiveHookForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling enterpriseAdminGetPreReceiveHookForRepo'
            );
        }

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminGetPreReceiveHookForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseGroup
     *
     * Get SCIM provisioning information for an enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseGroup($scim_group_id, $enterprise, $excluded_attributes = null, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'][0])
    {
        list($response) = $this->enterpriseAdminGetProvisioningInformationForEnterpriseGroupWithHttpInfo($scim_group_id, $enterprise, $excluded_attributes, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseGroupWithHttpInfo
     *
     * Get SCIM provisioning information for an enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseGroupWithHttpInfo($scim_group_id, $enterprise, $excluded_attributes = null, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'][0])
    {
        $request = $this->enterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest($scim_group_id, $enterprise, $excluded_attributes, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseGroupAsync
     *
     * Get SCIM provisioning information for an enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseGroupAsync($scim_group_id, $enterprise, $excluded_attributes = null, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'][0])
    {
        return $this->enterpriseAdminGetProvisioningInformationForEnterpriseGroupAsyncWithHttpInfo($scim_group_id, $enterprise, $excluded_attributes, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseGroupAsyncWithHttpInfo
     *
     * Get SCIM provisioning information for an enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseGroupAsyncWithHttpInfo($scim_group_id, $enterprise, $excluded_attributes = null, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
        $request = $this->enterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest($scim_group_id, $enterprise, $excluded_attributes, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetProvisioningInformationForEnterpriseGroup'
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseGroupRequest($scim_group_id, $enterprise, $excluded_attributes = null, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseGroup'][0])
    {

        // verify the required parameter 'scim_group_id' is set
        if ($scim_group_id === null || (is_array($scim_group_id) && count($scim_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_group_id when calling enterpriseAdminGetProvisioningInformationForEnterpriseGroup'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetProvisioningInformationForEnterpriseGroup'
            );
        }



        $resourcePath = '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $excluded_attributes,
            'excludedAttributes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($scim_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_group_id' . '}',
                ObjectSerializer::toPathValue($scim_group_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseUser
     *
     * Get SCIM provisioning information for an enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseUser($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'][0])
    {
        list($response) = $this->enterpriseAdminGetProvisioningInformationForEnterpriseUserWithHttpInfo($scim_user_id, $enterprise, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseUserWithHttpInfo
     *
     * Get SCIM provisioning information for an enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseUserWithHttpInfo($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'][0])
    {
        $request = $this->enterpriseAdminGetProvisioningInformationForEnterpriseUserRequest($scim_user_id, $enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseUserAsync
     *
     * Get SCIM provisioning information for an enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseUserAsync($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'][0])
    {
        return $this->enterpriseAdminGetProvisioningInformationForEnterpriseUserAsyncWithHttpInfo($scim_user_id, $enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetProvisioningInformationForEnterpriseUserAsyncWithHttpInfo
     *
     * Get SCIM provisioning information for an enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseUserAsyncWithHttpInfo($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
        $request = $this->enterpriseAdminGetProvisioningInformationForEnterpriseUserRequest($scim_user_id, $enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetProvisioningInformationForEnterpriseUser'
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetProvisioningInformationForEnterpriseUserRequest($scim_user_id, $enterprise, string $contentType = self::contentTypes['enterpriseAdminGetProvisioningInformationForEnterpriseUser'][0])
    {

        // verify the required parameter 'scim_user_id' is set
        if ($scim_user_id === null || (is_array($scim_user_id) && count($scim_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_user_id when calling enterpriseAdminGetProvisioningInformationForEnterpriseUser'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetProvisioningInformationForEnterpriseUser'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_user_id' . '}',
                ObjectSerializer::toPathValue($scim_user_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetPullRequestStats
     *
     * Get pull request statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPullRequestStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview
     */
    public function enterpriseAdminGetPullRequestStats(string $contentType = self::contentTypes['enterpriseAdminGetPullRequestStats'][0])
    {
        list($response) = $this->enterpriseAdminGetPullRequestStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetPullRequestStatsWithHttpInfo
     *
     * Get pull request statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPullRequestStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetPullRequestStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetPullRequestStats'][0])
    {
        $request = $this->enterpriseAdminGetPullRequestStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetPullRequestStatsAsync
     *
     * Get pull request statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPullRequestStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPullRequestStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetPullRequestStats'][0])
    {
        return $this->enterpriseAdminGetPullRequestStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetPullRequestStatsAsyncWithHttpInfo
     *
     * Get pull request statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPullRequestStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetPullRequestStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetPullRequestStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterprisePullRequestOverview';
        $request = $this->enterpriseAdminGetPullRequestStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetPullRequestStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetPullRequestStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetPullRequestStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetPullRequestStats'][0])
    {


        $resourcePath = '/enterprise/stats/pulls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetReplicationStatus
     *
     * Get the status of services running on all replica nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetReplicationStatus'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus
     */
    public function enterpriseAdminGetReplicationStatus($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetReplicationStatus'][0])
    {
        list($response) = $this->enterpriseAdminGetReplicationStatusWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetReplicationStatusWithHttpInfo
     *
     * Get the status of services running on all replica nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetReplicationStatus'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetReplicationStatusWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetReplicationStatus'][0])
    {
        $request = $this->enterpriseAdminGetReplicationStatusRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetReplicationStatusAsync
     *
     * Get the status of services running on all replica nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetReplicationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetReplicationStatusAsync($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetReplicationStatus'][0])
    {
        return $this->enterpriseAdminGetReplicationStatusAsyncWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetReplicationStatusAsyncWithHttpInfo
     *
     * Get the status of services running on all replica nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetReplicationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetReplicationStatusAsyncWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetReplicationStatus'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesReplicationStatus';
        $request = $this->enterpriseAdminGetReplicationStatusRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetReplicationStatus'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetReplicationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetReplicationStatusRequest($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetReplicationStatus'][0])
    {




        $resourcePath = '/manage/v1/replication/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_roles,
            'cluster_roles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetReplicationStatus();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetReplicationStatus
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetReplicationStatus(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetRepoStats
     *
     * Get repository statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetRepoStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview
     */
    public function enterpriseAdminGetRepoStats(string $contentType = self::contentTypes['enterpriseAdminGetRepoStats'][0])
    {
        list($response) = $this->enterpriseAdminGetRepoStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetRepoStatsWithHttpInfo
     *
     * Get repository statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetRepoStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetRepoStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetRepoStats'][0])
    {
        $request = $this->enterpriseAdminGetRepoStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetRepoStatsAsync
     *
     * Get repository statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetRepoStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetRepoStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetRepoStats'][0])
    {
        return $this->enterpriseAdminGetRepoStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetRepoStatsAsyncWithHttpInfo
     *
     * Get repository statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetRepoStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetRepoStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetRepoStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseRepositoryOverview';
        $request = $this->enterpriseAdminGetRepoStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetRepoStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetRepoStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetRepoStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetRepoStats'][0])
    {


        $resourcePath = '/enterprise/stats/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetSecurityProducts
     *
     * Get security products statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSecurityProducts'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview
     */
    public function enterpriseAdminGetSecurityProducts(string $contentType = self::contentTypes['enterpriseAdminGetSecurityProducts'][0])
    {
        list($response) = $this->enterpriseAdminGetSecurityProductsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetSecurityProductsWithHttpInfo
     *
     * Get security products statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSecurityProducts'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetSecurityProductsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetSecurityProducts'][0])
    {
        $request = $this->enterpriseAdminGetSecurityProductsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetSecurityProductsAsync
     *
     * Get security products statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSecurityProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSecurityProductsAsync(string $contentType = self::contentTypes['enterpriseAdminGetSecurityProducts'][0])
    {
        return $this->enterpriseAdminGetSecurityProductsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetSecurityProductsAsyncWithHttpInfo
     *
     * Get security products statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSecurityProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSecurityProductsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetSecurityProducts'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityProductsOverview';
        $request = $this->enterpriseAdminGetSecurityProductsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetSecurityProducts'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSecurityProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetSecurityProductsRequest(string $contentType = self::contentTypes['enterpriseAdminGetSecurityProducts'][0])
    {


        $resourcePath = '/enterprise/stats/security-products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerForEnterprise
     *
     * Get a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner
     */
    public function enterpriseAdminGetSelfHostedRunnerForEnterprise($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminGetSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerForEnterpriseWithHttpInfo
     *
     * Get a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'][0])
    {
        $request = $this->enterpriseAdminGetSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerForEnterpriseAsync
     *
     * Get a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSelfHostedRunnerForEnterpriseAsync($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'][0])
    {
        return $this->enterpriseAdminGetSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerForEnterpriseAsyncWithHttpInfo
     *
     * Get a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Runner';
        $request = $this->enterpriseAdminGetSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetSelfHostedRunnerForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminGetSelfHostedRunnerForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerGroupForEnterprise
     *
     * Get a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise
     */
    public function enterpriseAdminGetSelfHostedRunnerGroupForEnterprise($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseWithHttpInfo
     *
     * Get a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $runner_group_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseAsync
     *
     * Get a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseAsync($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo
     *
     * Get a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise';
        $request = $this->enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $runner_group_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $runner_group_id, string $contentType = self::contentTypes['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetSettings
     *
     * Get settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings
     */
    public function enterpriseAdminGetSettings(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetSettings'][0])
    {
        list($response) = $this->enterpriseAdminGetSettingsWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetSettingsWithHttpInfo
     *
     * Get settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetSettingsWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetSettings'][0])
    {
        $request = $this->enterpriseAdminGetSettingsRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetSettingsAsync
     *
     * Get settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSettingsAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetSettings'][0])
    {
        return $this->enterpriseAdminGetSettingsAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetSettingsAsyncWithHttpInfo
     *
     * Get settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetSettingsAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetSettings'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSettings';
        $request = $this->enterpriseAdminGetSettingsRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetSettings'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetSettingsRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetSettings'][0])
    {


        $resourcePath = '/setup/api/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetSettings();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetSettings
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetSettings(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminGetUserStats
     *
     * Get users statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetUserStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview
     */
    public function enterpriseAdminGetUserStats(string $contentType = self::contentTypes['enterpriseAdminGetUserStats'][0])
    {
        list($response) = $this->enterpriseAdminGetUserStatsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetUserStatsWithHttpInfo
     *
     * Get users statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetUserStats'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetUserStatsWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetUserStats'][0])
    {
        $request = $this->enterpriseAdminGetUserStatsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetUserStatsAsync
     *
     * Get users statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetUserStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetUserStatsAsync(string $contentType = self::contentTypes['enterpriseAdminGetUserStats'][0])
    {
        return $this->enterpriseAdminGetUserStatsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetUserStatsAsyncWithHttpInfo
     *
     * Get users statistics
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetUserStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetUserStatsAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminGetUserStats'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseUserOverview';
        $request = $this->enterpriseAdminGetUserStatsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetUserStats'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetUserStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetUserStatsRequest(string $contentType = self::contentTypes['enterpriseAdminGetUserStats'][0])
    {


        $resourcePath = '/enterprise/stats/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminGetVersion
     *
     * Get all GHES release versions for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetVersion'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]
     */
    public function enterpriseAdminGetVersion($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetVersion'][0])
    {
        list($response) = $this->enterpriseAdminGetVersionWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminGetVersionWithHttpInfo
     *
     * Get all GHES release versions for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetVersion'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminGetVersionWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetVersion'][0])
    {
        $request = $this->enterpriseAdminGetVersionRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminGetVersionAsync
     *
     * Get all GHES release versions for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetVersionAsync($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetVersion'][0])
    {
        return $this->enterpriseAdminGetVersionAsyncWithHttpInfo($uuid, $cluster_roles, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminGetVersionAsyncWithHttpInfo
     *
     * Get all GHES release versions for all nodes
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminGetVersionAsyncWithHttpInfo($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetVersion'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesVersionInner[]';
        $request = $this->enterpriseAdminGetVersionRequest($uuid, $cluster_roles, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminGetVersion'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $uuid The UUID which identifies a node. (optional)
     * @param  string $cluster_roles The cluster roles from the cluster configuration file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminGetVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminGetVersionRequest($uuid = null, $cluster_roles = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminGetVersion'][0])
    {




        $resourcePath = '/manage/v1/version';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cluster_roles,
            'cluster_roles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminGetVersion();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminGetVersion
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminGetVersion(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminInitializeInstanceConfiguration
     *
     * Initialize instance configuration with license upload
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password The root site administrator password. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminInitializeInstanceConfiguration($license, $password, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'][0])
    {
        $this->enterpriseAdminInitializeInstanceConfigurationWithHttpInfo($license, $password, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation enterpriseAdminInitializeInstanceConfigurationWithHttpInfo
     *
     * Initialize instance configuration with license upload
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password The root site administrator password. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminInitializeInstanceConfigurationWithHttpInfo($license, $password, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'][0])
    {
        $request = $this->enterpriseAdminInitializeInstanceConfigurationRequest($license, $password, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminInitializeInstanceConfigurationAsync
     *
     * Initialize instance configuration with license upload
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password The root site administrator password. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminInitializeInstanceConfigurationAsync($license, $password, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'][0])
    {
        return $this->enterpriseAdminInitializeInstanceConfigurationAsyncWithHttpInfo($license, $password, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminInitializeInstanceConfigurationAsyncWithHttpInfo
     *
     * Initialize instance configuration with license upload
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password The root site administrator password. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminInitializeInstanceConfigurationAsyncWithHttpInfo($license, $password, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminInitializeInstanceConfigurationRequest($license, $password, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminInitializeInstanceConfiguration'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your _.ghl_ license file. (required)
     * @param  string $password The root site administrator password. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminInitializeInstanceConfigurationRequest($license, $password, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminInitializeInstanceConfiguration'][0])
    {

        // verify the required parameter 'license' is set
        if ($license === null || (is_array($license) && count($license) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $license when calling enterpriseAdminInitializeInstanceConfiguration'
            );
        }

        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling enterpriseAdminInitializeInstanceConfiguration'
            );
        }


        $resourcePath = '/manage/v1/config/init';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($license !== null) {
            $formParams['license'] = ObjectSerializer::toFormValue($license);
        }
        // form params
        if ($password !== null) {
            $formParams['password'] = ObjectSerializer::toFormValue($password);
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminInitializeInstanceConfiguration();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminInitializeInstanceConfiguration
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminInitializeInstanceConfiguration(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminLicenseCheck
     *
     * Check a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseCheck'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck
     */
    public function enterpriseAdminLicenseCheck(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseCheck'][0])
    {
        list($response) = $this->enterpriseAdminLicenseCheckWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminLicenseCheckWithHttpInfo
     *
     * Check a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseCheck'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminLicenseCheckWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseCheck'][0])
    {
        $request = $this->enterpriseAdminLicenseCheckRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminLicenseCheckAsync
     *
     * Check a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminLicenseCheckAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseCheck'][0])
    {
        return $this->enterpriseAdminLicenseCheckAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminLicenseCheckAsyncWithHttpInfo
     *
     * Check a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminLicenseCheckAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseCheck'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseCheck';
        $request = $this->enterpriseAdminLicenseCheckRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminLicenseCheck'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseCheck'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminLicenseCheckRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseCheck'][0])
    {


        $resourcePath = '/manage/v1/config/license/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminLicenseCheck();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminLicenseCheck
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminLicenseCheck(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminLicenseInfo
     *
     * Get the enterprise license information
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseInfo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo
     */
    public function enterpriseAdminLicenseInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseInfo'][0])
    {
        list($response) = $this->enterpriseAdminLicenseInfoWithHttpInfo($hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminLicenseInfoWithHttpInfo
     *
     * Get the enterprise license information
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseInfo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminLicenseInfoWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseInfo'][0])
    {
        $request = $this->enterpriseAdminLicenseInfoRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminLicenseInfoAsync
     *
     * Get the enterprise license information
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminLicenseInfoAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseInfo'][0])
    {
        return $this->enterpriseAdminLicenseInfoAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminLicenseInfoAsyncWithHttpInfo
     *
     * Get the enterprise license information
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminLicenseInfoAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseInfo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseInfo';
        $request = $this->enterpriseAdminLicenseInfoRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminLicenseInfo'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminLicenseInfoRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseInfo'][0])
    {


        $resourcePath = '/manage/v1/config/license';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminLicenseInfo();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminLicenseInfo
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminLicenseInfo(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminLicenseUpload
     *
     * Upload an enterprise license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \SplFileObject $body body (required)
     * @param  bool $apply Whether to apply changes from the license. Uploading a license does not automatically apply changes. To make the changes effective, you can specify to apply the license too. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseUpload'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]
     */
    public function enterpriseAdminLicenseUpload($body, $apply = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseUpload'][0])
    {
        list($response) = $this->enterpriseAdminLicenseUploadWithHttpInfo($body, $apply, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminLicenseUploadWithHttpInfo
     *
     * Upload an enterprise license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \SplFileObject $body (required)
     * @param  bool $apply Whether to apply changes from the license. Uploading a license does not automatically apply changes. To make the changes effective, you can specify to apply the license too. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseUpload'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminLicenseUploadWithHttpInfo($body, $apply = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseUpload'][0])
    {
        $request = $this->enterpriseAdminLicenseUploadRequest($body, $apply, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminLicenseUploadAsync
     *
     * Upload an enterprise license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \SplFileObject $body (required)
     * @param  bool $apply Whether to apply changes from the license. Uploading a license does not automatically apply changes. To make the changes effective, you can specify to apply the license too. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminLicenseUploadAsync($body, $apply = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseUpload'][0])
    {
        return $this->enterpriseAdminLicenseUploadAsyncWithHttpInfo($body, $apply, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminLicenseUploadAsyncWithHttpInfo
     *
     * Upload an enterprise license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \SplFileObject $body (required)
     * @param  bool $apply Whether to apply changes from the license. Uploading a license does not automatically apply changes. To make the changes effective, you can specify to apply the license too. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminLicenseUploadAsyncWithHttpInfo($body, $apply = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseUpload'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesLicenseUploadInner[]';
        $request = $this->enterpriseAdminLicenseUploadRequest($body, $apply, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminLicenseUpload'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \SplFileObject $body (required)
     * @param  bool $apply Whether to apply changes from the license. Uploading a license does not automatically apply changes. To make the changes effective, you can specify to apply the license too. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminLicenseUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminLicenseUploadRequest($body, $apply = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminLicenseUpload'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling enterpriseAdminLicenseUpload'
            );
        }



        $resourcePath = '/manage/v1/config/license';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apply,
            'apply', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminLicenseUpload();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminLicenseUpload
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminLicenseUpload(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminListGlobalWebhooks
     *
     * List global webhooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListGlobalWebhooks'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]
     */
    public function enterpriseAdminListGlobalWebhooks($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListGlobalWebhooks'][0])
    {
        list($response) = $this->enterpriseAdminListGlobalWebhooksWithHttpInfo($per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListGlobalWebhooksWithHttpInfo
     *
     * List global webhooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListGlobalWebhooks'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListGlobalWebhooksWithHttpInfo($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListGlobalWebhooks'][0])
    {
        $request = $this->enterpriseAdminListGlobalWebhooksRequest($per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListGlobalWebhooksAsync
     *
     * List global webhooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListGlobalWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListGlobalWebhooksAsync($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListGlobalWebhooks'][0])
    {
        return $this->enterpriseAdminListGlobalWebhooksAsyncWithHttpInfo($per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListGlobalWebhooksAsyncWithHttpInfo
     *
     * List global webhooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListGlobalWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListGlobalWebhooksAsyncWithHttpInfo($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListGlobalWebhooks'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook[]';
        $request = $this->enterpriseAdminListGlobalWebhooksRequest($per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListGlobalWebhooks'
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListGlobalWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListGlobalWebhooksRequest($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListGlobalWebhooks'][0])
    {




        $resourcePath = '/admin/hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise
     *
     * List labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseWithHttpInfo
     *
     * List labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        $request = $this->enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseAsync
     *
     * List labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseAsync($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        return $this->enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseAsyncWithHttpInfo
     *
     * List labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise
     *
     * List organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response
     */
    public function enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo
     *
     * List organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $request = $this->enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync
     *
     * List organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        return $this->enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo
     *
     * List organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response';
        $request = $this->enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }




        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListPersonalAccessTokens
     *
     * List personal access tokens
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPersonalAccessTokens'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]
     */
    public function enterpriseAdminListPersonalAccessTokens($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListPersonalAccessTokens'][0])
    {
        list($response) = $this->enterpriseAdminListPersonalAccessTokensWithHttpInfo($per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListPersonalAccessTokensWithHttpInfo
     *
     * List personal access tokens
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPersonalAccessTokens'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListPersonalAccessTokensWithHttpInfo($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListPersonalAccessTokens'][0])
    {
        $request = $this->enterpriseAdminListPersonalAccessTokensRequest($per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListPersonalAccessTokensAsync
     *
     * List personal access tokens
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPersonalAccessTokens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPersonalAccessTokensAsync($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListPersonalAccessTokens'][0])
    {
        return $this->enterpriseAdminListPersonalAccessTokensAsyncWithHttpInfo($per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListPersonalAccessTokensAsyncWithHttpInfo
     *
     * List personal access tokens
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPersonalAccessTokens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPersonalAccessTokensAsyncWithHttpInfo($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListPersonalAccessTokens'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Authorization[]';
        $request = $this->enterpriseAdminListPersonalAccessTokensRequest($per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListPersonalAccessTokens'
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPersonalAccessTokens'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListPersonalAccessTokensRequest($per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListPersonalAccessTokens'][0])
    {




        $resourcePath = '/admin/tokens';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListPreReceiveEnvironments
     *
     * List pre-receive environments
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveEnvironments'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]
     */
    public function enterpriseAdminListPreReceiveEnvironments($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveEnvironments'][0])
    {
        list($response) = $this->enterpriseAdminListPreReceiveEnvironmentsWithHttpInfo($per_page, $page, $direction, $sort, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListPreReceiveEnvironmentsWithHttpInfo
     *
     * List pre-receive environments
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveEnvironments'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListPreReceiveEnvironmentsWithHttpInfo($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveEnvironments'][0])
    {
        $request = $this->enterpriseAdminListPreReceiveEnvironmentsRequest($per_page, $page, $direction, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListPreReceiveEnvironmentsAsync
     *
     * List pre-receive environments
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveEnvironments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveEnvironmentsAsync($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveEnvironments'][0])
    {
        return $this->enterpriseAdminListPreReceiveEnvironmentsAsyncWithHttpInfo($per_page, $page, $direction, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListPreReceiveEnvironmentsAsyncWithHttpInfo
     *
     * List pre-receive environments
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveEnvironments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveEnvironmentsAsyncWithHttpInfo($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveEnvironments'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment[]';
        $request = $this->enterpriseAdminListPreReceiveEnvironmentsRequest($per_page, $page, $direction, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListPreReceiveEnvironments'
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveEnvironments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListPreReceiveEnvironmentsRequest($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveEnvironments'][0])
    {






        $resourcePath = '/admin/pre-receive-environments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooks
     *
     * List pre-receive hooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The property to sort the results by. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooks'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]
     */
    public function enterpriseAdminListPreReceiveHooks($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooks'][0])
    {
        list($response) = $this->enterpriseAdminListPreReceiveHooksWithHttpInfo($per_page, $page, $direction, $sort, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksWithHttpInfo
     *
     * List pre-receive hooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The property to sort the results by. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooks'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListPreReceiveHooksWithHttpInfo($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooks'][0])
    {
        $request = $this->enterpriseAdminListPreReceiveHooksRequest($per_page, $page, $direction, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksAsync
     *
     * List pre-receive hooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The property to sort the results by. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveHooksAsync($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooks'][0])
    {
        return $this->enterpriseAdminListPreReceiveHooksAsyncWithHttpInfo($per_page, $page, $direction, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksAsyncWithHttpInfo
     *
     * List pre-receive hooks
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The property to sort the results by. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveHooksAsyncWithHttpInfo($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooks'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook[]';
        $request = $this->enterpriseAdminListPreReceiveHooksRequest($per_page, $page, $direction, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListPreReceiveHooks'
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The property to sort the results by. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListPreReceiveHooksRequest($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooks'][0])
    {






        $resourcePath = '/admin/pre-receive-hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForOrg
     *
     * List pre-receive hooks for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The sort order for the response collection. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]
     */
    public function enterpriseAdminListPreReceiveHooksForOrg($org, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'][0])
    {
        list($response) = $this->enterpriseAdminListPreReceiveHooksForOrgWithHttpInfo($org, $per_page, $page, $direction, $sort, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForOrgWithHttpInfo
     *
     * List pre-receive hooks for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The sort order for the response collection. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListPreReceiveHooksForOrgWithHttpInfo($org, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'][0])
    {
        $request = $this->enterpriseAdminListPreReceiveHooksForOrgRequest($org, $per_page, $page, $direction, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForOrgAsync
     *
     * List pre-receive hooks for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The sort order for the response collection. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveHooksForOrgAsync($org, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'][0])
    {
        return $this->enterpriseAdminListPreReceiveHooksForOrgAsyncWithHttpInfo($org, $per_page, $page, $direction, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForOrgAsyncWithHttpInfo
     *
     * List pre-receive hooks for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The sort order for the response collection. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveHooksForOrgAsyncWithHttpInfo($org, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook[]';
        $request = $this->enterpriseAdminListPreReceiveHooksForOrgRequest($org, $per_page, $page, $direction, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListPreReceiveHooksForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort The sort order for the response collection. (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListPreReceiveHooksForOrgRequest($org, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling enterpriseAdminListPreReceiveHooksForOrg'
            );
        }






        $resourcePath = '/orgs/{org}/pre-receive-hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForRepo
     *
     * List pre-receive hooks for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]
     */
    public function enterpriseAdminListPreReceiveHooksForRepo($owner, $repo, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'][0])
    {
        list($response) = $this->enterpriseAdminListPreReceiveHooksForRepoWithHttpInfo($owner, $repo, $per_page, $page, $direction, $sort, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForRepoWithHttpInfo
     *
     * List pre-receive hooks for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListPreReceiveHooksForRepoWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'][0])
    {
        $request = $this->enterpriseAdminListPreReceiveHooksForRepoRequest($owner, $repo, $per_page, $page, $direction, $sort, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForRepoAsync
     *
     * List pre-receive hooks for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveHooksForRepoAsync($owner, $repo, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'][0])
    {
        return $this->enterpriseAdminListPreReceiveHooksForRepoAsyncWithHttpInfo($owner, $repo, $per_page, $page, $direction, $sort, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListPreReceiveHooksForRepoAsyncWithHttpInfo
     *
     * List pre-receive hooks for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPreReceiveHooksForRepoAsyncWithHttpInfo($owner, $repo, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook[]';
        $request = $this->enterpriseAdminListPreReceiveHooksForRepoRequest($owner, $repo, $per_page, $page, $direction, $sort, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListPreReceiveHooksForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListPreReceiveHooksForRepoRequest($owner, $repo, $per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', string $contentType = self::contentTypes['enterpriseAdminListPreReceiveHooksForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling enterpriseAdminListPreReceiveHooksForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling enterpriseAdminListPreReceiveHooksForRepo'
            );
        }






        $resourcePath = '/repos/{owner}/{repo}/pre-receive-hooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListProvisionedGroupsEnterprise
     *
     * List provisioned SCIM groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminListProvisionedGroupsEnterprise($enterprise, $filter = null, $excluded_attributes = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListProvisionedGroupsEnterpriseWithHttpInfo($enterprise, $filter, $excluded_attributes, $start_index, $count, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListProvisionedGroupsEnterpriseWithHttpInfo
     *
     * List provisioned SCIM groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListProvisionedGroupsEnterpriseWithHttpInfo($enterprise, $filter = null, $excluded_attributes = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'][0])
    {
        $request = $this->enterpriseAdminListProvisionedGroupsEnterpriseRequest($enterprise, $filter, $excluded_attributes, $start_index, $count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListProvisionedGroupsEnterpriseAsync
     *
     * List provisioned SCIM groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListProvisionedGroupsEnterpriseAsync($enterprise, $filter = null, $excluded_attributes = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'][0])
    {
        return $this->enterpriseAdminListProvisionedGroupsEnterpriseAsyncWithHttpInfo($enterprise, $filter, $excluded_attributes, $start_index, $count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListProvisionedGroupsEnterpriseAsyncWithHttpInfo
     *
     * List provisioned SCIM groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListProvisionedGroupsEnterpriseAsyncWithHttpInfo($enterprise, $filter = null, $excluded_attributes = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupList';
        $request = $this->enterpriseAdminListProvisionedGroupsEnterpriseRequest($enterprise, $filter, $excluded_attributes, $start_index, $count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListProvisionedGroupsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  string $excluded_attributes Excludes the specified attribute from being returned in the results. Using this parameter can speed up response time. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListProvisionedGroupsEnterpriseRequest($enterprise, $filter = null, $excluded_attributes = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedGroupsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListProvisionedGroupsEnterprise'
            );
        }






        $resourcePath = '/scim/v2/enterprises/{enterprise}/Groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $excluded_attributes,
            'excludedAttributes', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListProvisionedIdentitiesEnterprise
     *
     * List SCIM provisioned identities for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;userName&#x60;, &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminListProvisionedIdentitiesEnterprise($enterprise, $filter = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListProvisionedIdentitiesEnterpriseWithHttpInfo($enterprise, $filter, $start_index, $count, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListProvisionedIdentitiesEnterpriseWithHttpInfo
     *
     * List SCIM provisioned identities for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;userName&#x60;, &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListProvisionedIdentitiesEnterpriseWithHttpInfo($enterprise, $filter = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'][0])
    {
        $request = $this->enterpriseAdminListProvisionedIdentitiesEnterpriseRequest($enterprise, $filter, $start_index, $count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListProvisionedIdentitiesEnterpriseAsync
     *
     * List SCIM provisioned identities for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;userName&#x60;, &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListProvisionedIdentitiesEnterpriseAsync($enterprise, $filter = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'][0])
    {
        return $this->enterpriseAdminListProvisionedIdentitiesEnterpriseAsyncWithHttpInfo($enterprise, $filter, $start_index, $count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListProvisionedIdentitiesEnterpriseAsyncWithHttpInfo
     *
     * List SCIM provisioned identities for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;userName&#x60;, &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListProvisionedIdentitiesEnterpriseAsyncWithHttpInfo($enterprise, $filter = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserList';
        $request = $this->enterpriseAdminListProvisionedIdentitiesEnterpriseRequest($enterprise, $filter, $start_index, $count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListProvisionedIdentitiesEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $filter If specified, only results that match the specified filter will be returned. Multiple filters are not supported. Possible filters are &#x60;userName&#x60;, &#x60;externalId&#x60;, &#x60;id&#x60;, and &#x60;displayName&#x60;. For example, &#x60;?filter&#x3D;\&quot;externalId eq &#39;9138790-10932-109120392-12321&#39;\&quot;&#x60;. (optional)
     * @param  int $start_index Used for pagination: the starting index of the first result to return when paginating through values. (optional, default to 1)
     * @param  int $count Used for pagination: the number of results to return per page. (optional, default to 30)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListProvisionedIdentitiesEnterpriseRequest($enterprise, $filter = null, $start_index = 1, $count = 30, string $contentType = self::contentTypes['enterpriseAdminListProvisionedIdentitiesEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListProvisionedIdentitiesEnterprise'
            );
        }





        $resourcePath = '/scim/v2/enterprises/{enterprise}/Users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter,
            'filter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListPublicKeys
     *
     * List public keys
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort sort (optional, default to 'created')
     * @param  string $since Only show public keys accessed after the given time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPublicKeys'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]
     */
    public function enterpriseAdminListPublicKeys($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', $since = null, string $contentType = self::contentTypes['enterpriseAdminListPublicKeys'][0])
    {
        list($response) = $this->enterpriseAdminListPublicKeysWithHttpInfo($per_page, $page, $direction, $sort, $since, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListPublicKeysWithHttpInfo
     *
     * List public keys
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $since Only show public keys accessed after the given time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPublicKeys'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListPublicKeysWithHttpInfo($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', $since = null, string $contentType = self::contentTypes['enterpriseAdminListPublicKeys'][0])
    {
        $request = $this->enterpriseAdminListPublicKeysRequest($per_page, $page, $direction, $sort, $since, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListPublicKeysAsync
     *
     * List public keys
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $since Only show public keys accessed after the given time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPublicKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPublicKeysAsync($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', $since = null, string $contentType = self::contentTypes['enterpriseAdminListPublicKeys'][0])
    {
        return $this->enterpriseAdminListPublicKeysAsyncWithHttpInfo($per_page, $page, $direction, $sort, $since, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListPublicKeysAsyncWithHttpInfo
     *
     * List public keys
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $since Only show public keys accessed after the given time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPublicKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListPublicKeysAsyncWithHttpInfo($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', $since = null, string $contentType = self::contentTypes['enterpriseAdminListPublicKeys'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PublicKeyFull[]';
        $request = $this->enterpriseAdminListPublicKeysRequest($per_page, $page, $direction, $sort, $since, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListPublicKeys'
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  string $sort (optional, default to 'created')
     * @param  string $since Only show public keys accessed after the given time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListPublicKeys'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListPublicKeysRequest($per_page = 30, $page = 1, $direction = 'desc', $sort = 'created', $since = null, string $contentType = self::contentTypes['enterpriseAdminListPublicKeys'][0])
    {







        $resourcePath = '/admin/keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListRunnerApplicationsForEnterprise
     *
     * List runner applications for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]
     */
    public function enterpriseAdminListRunnerApplicationsForEnterprise($enterprise, string $contentType = self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListRunnerApplicationsForEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListRunnerApplicationsForEnterpriseWithHttpInfo
     *
     * List runner applications for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListRunnerApplicationsForEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'][0])
    {
        $request = $this->enterpriseAdminListRunnerApplicationsForEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListRunnerApplicationsForEnterpriseAsync
     *
     * List runner applications for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListRunnerApplicationsForEnterpriseAsync($enterprise, string $contentType = self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'][0])
    {
        return $this->enterpriseAdminListRunnerApplicationsForEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListRunnerApplicationsForEnterpriseAsyncWithHttpInfo
     *
     * List runner applications for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListRunnerApplicationsForEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerApplication[]';
        $request = $this->enterpriseAdminListRunnerApplicationsForEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListRunnerApplicationsForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListRunnerApplicationsForEnterpriseRequest($enterprise, string $contentType = self::contentTypes['enterpriseAdminListRunnerApplicationsForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListRunnerApplicationsForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise
     *
     * List selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response
     */
    public function enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise($enterprise, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseWithHttpInfo($enterprise, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseWithHttpInfo
     *
     * List selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseWithHttpInfo($enterprise, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest($enterprise, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseAsync
     *
     * List selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseAsync($enterprise, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        return $this->enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseAsyncWithHttpInfo
     *
     * List selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200Response';
        $request = $this->enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest($enterprise, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest($enterprise, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'
            );
        }




        $resourcePath = '/enterprises/{enterprise}/actions/permissions/organizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnerGroupsForEnterprise
     *
     * List self-hosted runner groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_organization Only return runner groups that are allowed to be used by this organization. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response
     */
    public function enterpriseAdminListSelfHostedRunnerGroupsForEnterprise($enterprise, $per_page = 30, $page = 1, $visible_to_organization = null, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseWithHttpInfo($enterprise, $per_page, $page, $visible_to_organization, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseWithHttpInfo
     *
     * List self-hosted runner groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_organization Only return runner groups that are allowed to be used by this organization. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseWithHttpInfo($enterprise, $per_page = 30, $page = 1, $visible_to_organization = null, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'][0])
    {
        $request = $this->enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest($enterprise, $per_page, $page, $visible_to_organization, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseAsync
     *
     * List self-hosted runner groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_organization Only return runner groups that are allowed to be used by this organization. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseAsync($enterprise, $per_page = 30, $page = 1, $visible_to_organization = null, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'][0])
    {
        return $this->enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseAsyncWithHttpInfo($enterprise, $per_page, $page, $visible_to_organization, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseAsyncWithHttpInfo
     *
     * List self-hosted runner groups for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_organization Only return runner groups that are allowed to be used by this organization. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseAsyncWithHttpInfo($enterprise, $per_page = 30, $page = 1, $visible_to_organization = null, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200Response';
        $request = $this->enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest($enterprise, $per_page, $page, $visible_to_organization, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $visible_to_organization Only return runner groups that are allowed to be used by this organization. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest($enterprise, $per_page = 30, $page = 1, $visible_to_organization = null, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'
            );
        }





        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visible_to_organization,
            'visible_to_organization', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersForEnterprise
     *
     * List self-hosted runners for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response
     */
    public function enterpriseAdminListSelfHostedRunnersForEnterprise($enterprise, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListSelfHostedRunnersForEnterpriseWithHttpInfo($enterprise, $name, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersForEnterpriseWithHttpInfo
     *
     * List self-hosted runners for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListSelfHostedRunnersForEnterpriseWithHttpInfo($enterprise, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'][0])
    {
        $request = $this->enterpriseAdminListSelfHostedRunnersForEnterpriseRequest($enterprise, $name, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersForEnterpriseAsync
     *
     * List self-hosted runners for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelfHostedRunnersForEnterpriseAsync($enterprise, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'][0])
    {
        return $this->enterpriseAdminListSelfHostedRunnersForEnterpriseAsyncWithHttpInfo($enterprise, $name, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersForEnterpriseAsyncWithHttpInfo
     *
     * List self-hosted runners for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelfHostedRunnersForEnterpriseAsyncWithHttpInfo($enterprise, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersForEnterprise200Response';
        $request = $this->enterpriseAdminListSelfHostedRunnersForEnterpriseRequest($enterprise, $name, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListSelfHostedRunnersForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $name The name of a self-hosted runner. (optional)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListSelfHostedRunnersForEnterpriseRequest($enterprise, $name = null, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListSelfHostedRunnersForEnterprise'
            );
        }





        $resourcePath = '/enterprises/{enterprise}/actions/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersInGroupForEnterprise
     *
     * List self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response
     */
    public function enterpriseAdminListSelfHostedRunnersInGroupForEnterprise($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseWithHttpInfo
     *
     * List self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest($enterprise, $runner_group_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseAsync
     *
     * List self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseAsync($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseAsyncWithHttpInfo
     *
     * List self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200Response';
        $request = $this->enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest($enterprise, $runner_group_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.12/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest($enterprise, $runner_group_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'
            );
        }




        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminPingGlobalWebhook
     *
     * Ping a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPingGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminPingGlobalWebhook($hook_id, string $contentType = self::contentTypes['enterpriseAdminPingGlobalWebhook'][0])
    {
        $this->enterpriseAdminPingGlobalWebhookWithHttpInfo($hook_id, $contentType);
    }

    /**
     * Operation enterpriseAdminPingGlobalWebhookWithHttpInfo
     *
     * Ping a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPingGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminPingGlobalWebhookWithHttpInfo($hook_id, string $contentType = self::contentTypes['enterpriseAdminPingGlobalWebhook'][0])
    {
        $request = $this->enterpriseAdminPingGlobalWebhookRequest($hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminPingGlobalWebhookAsync
     *
     * Ping a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPingGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminPingGlobalWebhookAsync($hook_id, string $contentType = self::contentTypes['enterpriseAdminPingGlobalWebhook'][0])
    {
        return $this->enterpriseAdminPingGlobalWebhookAsyncWithHttpInfo($hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminPingGlobalWebhookAsyncWithHttpInfo
     *
     * Ping a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPingGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminPingGlobalWebhookAsyncWithHttpInfo($hook_id, string $contentType = self::contentTypes['enterpriseAdminPingGlobalWebhook'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminPingGlobalWebhookRequest($hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminPingGlobalWebhook'
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPingGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminPingGlobalWebhookRequest($hook_id, string $contentType = self::contentTypes['enterpriseAdminPingGlobalWebhook'][0])
    {

        // verify the required parameter 'hook_id' is set
        if ($hook_id === null || (is_array($hook_id) && count($hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hook_id when calling enterpriseAdminPingGlobalWebhook'
            );
        }


        $resourcePath = '/admin/hooks/{hook_id}/pings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'hook_id' . '}',
                ObjectSerializer::toPathValue($hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminPromoteUserToBeSiteAdministrator
     *
     * Promote a user to be a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminPromoteUserToBeSiteAdministrator($username, string $contentType = self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'][0])
    {
        $this->enterpriseAdminPromoteUserToBeSiteAdministratorWithHttpInfo($username, $contentType);
    }

    /**
     * Operation enterpriseAdminPromoteUserToBeSiteAdministratorWithHttpInfo
     *
     * Promote a user to be a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminPromoteUserToBeSiteAdministratorWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'][0])
    {
        $request = $this->enterpriseAdminPromoteUserToBeSiteAdministratorRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminPromoteUserToBeSiteAdministratorAsync
     *
     * Promote a user to be a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminPromoteUserToBeSiteAdministratorAsync($username, string $contentType = self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'][0])
    {
        return $this->enterpriseAdminPromoteUserToBeSiteAdministratorAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminPromoteUserToBeSiteAdministratorAsyncWithHttpInfo
     *
     * Promote a user to be a site administrator
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminPromoteUserToBeSiteAdministratorAsyncWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminPromoteUserToBeSiteAdministratorRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminPromoteUserToBeSiteAdministrator'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminPromoteUserToBeSiteAdministratorRequest($username, string $contentType = self::contentTypes['enterpriseAdminPromoteUserToBeSiteAdministrator'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminPromoteUserToBeSiteAdministrator'
            );
        }


        $resourcePath = '/users/{username}/site_admin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseGroup
     *
     * Provision a SCIM enterprise group
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminProvisionEnterpriseGroup($enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'][0])
    {
        list($response) = $this->enterpriseAdminProvisionEnterpriseGroupWithHttpInfo($enterprise, $group, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseGroupWithHttpInfo
     *
     * Provision a SCIM enterprise group
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminProvisionEnterpriseGroupWithHttpInfo($enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'][0])
    {
        $request = $this->enterpriseAdminProvisionEnterpriseGroupRequest($enterprise, $group, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseGroupAsync
     *
     * Provision a SCIM enterprise group
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminProvisionEnterpriseGroupAsync($enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'][0])
    {
        return $this->enterpriseAdminProvisionEnterpriseGroupAsyncWithHttpInfo($enterprise, $group, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseGroupAsyncWithHttpInfo
     *
     * Provision a SCIM enterprise group
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminProvisionEnterpriseGroupAsyncWithHttpInfo($enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
        $request = $this->enterpriseAdminProvisionEnterpriseGroupRequest($enterprise, $group, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminProvisionEnterpriseGroup'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminProvisionEnterpriseGroupRequest($enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseGroup'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminProvisionEnterpriseGroup'
            );
        }

        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling enterpriseAdminProvisionEnterpriseGroup'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Groups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group));
            } else {
                $httpBody = $group;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseUser
     *
     * Provision a SCIM enterprise user
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminProvisionEnterpriseUser($enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseUser'][0])
    {
        list($response) = $this->enterpriseAdminProvisionEnterpriseUserWithHttpInfo($enterprise, $user, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseUserWithHttpInfo
     *
     * Provision a SCIM enterprise user
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminProvisionEnterpriseUserWithHttpInfo($enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseUser'][0])
    {
        $request = $this->enterpriseAdminProvisionEnterpriseUserRequest($enterprise, $user, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseUserAsync
     *
     * Provision a SCIM enterprise user
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminProvisionEnterpriseUserAsync($enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseUser'][0])
    {
        return $this->enterpriseAdminProvisionEnterpriseUserAsyncWithHttpInfo($enterprise, $user, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminProvisionEnterpriseUserAsyncWithHttpInfo
     *
     * Provision a SCIM enterprise user
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminProvisionEnterpriseUserAsyncWithHttpInfo($enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
        $request = $this->enterpriseAdminProvisionEnterpriseUserRequest($enterprise, $user, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminProvisionEnterpriseUser'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminProvisionEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminProvisionEnterpriseUserRequest($enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminProvisionEnterpriseUser'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminProvisionEnterpriseUser'
            );
        }

        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling enterpriseAdminProvisionEnterpriseUser'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user));
            } else {
                $httpBody = $user;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise
     *
     * Remove all custom labels from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithHttpInfo
     *
     * Remove all custom labels from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'][0])
    {
        $request = $this->enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseAsync
     *
     * Remove all custom labels from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseAsync($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'][0])
    {
        return $this->enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseAsyncWithHttpInfo
     *
     * Remove all custom labels from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemoveAnnouncement
     *
     * Remove the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAnnouncement'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminRemoveAnnouncement(string $contentType = self::contentTypes['enterpriseAdminRemoveAnnouncement'][0])
    {
        $this->enterpriseAdminRemoveAnnouncementWithHttpInfo($contentType);
    }

    /**
     * Operation enterpriseAdminRemoveAnnouncementWithHttpInfo
     *
     * Remove the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAnnouncement'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemoveAnnouncementWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminRemoveAnnouncement'][0])
    {
        $request = $this->enterpriseAdminRemoveAnnouncementRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemoveAnnouncementAsync
     *
     * Remove the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveAnnouncementAsync(string $contentType = self::contentTypes['enterpriseAdminRemoveAnnouncement'][0])
    {
        return $this->enterpriseAdminRemoveAnnouncementAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemoveAnnouncementAsyncWithHttpInfo
     *
     * Remove the global announcement banner
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveAnnouncementAsyncWithHttpInfo(string $contentType = self::contentTypes['enterpriseAdminRemoveAnnouncement'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminRemoveAnnouncementRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemoveAnnouncement'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemoveAnnouncementRequest(string $contentType = self::contentTypes['enterpriseAdminRemoveAnnouncement'][0])
    {


        $resourcePath = '/enterprise/announcement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemoveAuthorizedSshKey
     *
     * Remove an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]
     */
    public function enterpriseAdminRemoveAuthorizedSshKey($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'][0])
    {
        list($response) = $this->enterpriseAdminRemoveAuthorizedSshKeyWithHttpInfo($authorized_key, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminRemoveAuthorizedSshKeyWithHttpInfo
     *
     * Remove an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemoveAuthorizedSshKeyWithHttpInfo($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'][0])
    {
        $request = $this->enterpriseAdminRemoveAuthorizedSshKeyRequest($authorized_key, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemoveAuthorizedSshKeyAsync
     *
     * Remove an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveAuthorizedSshKeyAsync($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'][0])
    {
        return $this->enterpriseAdminRemoveAuthorizedSshKeyAsyncWithHttpInfo($authorized_key, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemoveAuthorizedSshKeyAsyncWithHttpInfo
     *
     * Remove an authorized SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveAuthorizedSshKeyAsyncWithHttpInfo($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SshKey[]';
        $request = $this->enterpriseAdminRemoveAuthorizedSshKeyRequest($authorized_key, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemoveAuthorizedSshKey'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $authorized_key The public SSH key. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemoveAuthorizedSshKeyRequest($authorized_key, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminRemoveAuthorizedSshKey'][0])
    {

        // verify the required parameter 'authorized_key' is set
        if ($authorized_key === null || (is_array($authorized_key) && count($authorized_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorized_key when calling enterpriseAdminRemoveAuthorizedSshKey'
            );
        }


        $resourcePath = '/setup/api/settings/authorized-keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($authorized_key !== null) {
            $formParams['authorized_key'] = ObjectSerializer::toFormValue($authorized_key);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminRemoveAuthorizedSshKey();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminRemoveAuthorizedSshKey
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminRemoveAuthorizedSshKey(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise
     *
     * Remove a custom label from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise($enterprise, $runner_id, $name, string $contentType = self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $name, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseWithHttpInfo
     *
     * Remove a custom label from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $name, string $contentType = self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'][0])
    {
        $request = $this->enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseAsync
     *
     * Remove a custom label from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseAsync($enterprise, $runner_id, $name, string $contentType = self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'][0])
    {
        return $this->enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseAsyncWithHttpInfo
     *
     * Remove a custom label from a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $name, string $contentType = self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $name The name of a self-hosted runner&#39;s custom label. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $name, string $contentType = self::contentTypes['enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise
     *
     * Remove organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $this->enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $org_id, $contentType);
    }

    /**
     * Operation enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo
     *
     * Remove organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $request = $this->enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $org_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync
     *
     * Remove organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        return $this->enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $org_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo
     *
     * Remove organization access to a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $org_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $org_id The unique identifier of the organization. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $org_id, string $contentType = self::contentTypes['enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'org_id' is set
        if ($org_id === null || (is_array($org_id) && count($org_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org_id when calling enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations/{org_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($org_id !== null) {
            $resourcePath = str_replace(
                '{' . 'org_id' . '}',
                ObjectSerializer::toPathValue($org_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForOrg
     *
     * Remove pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForOrg($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'][0])
    {
        list($response) = $this->enterpriseAdminRemovePreReceiveHookEnforcementForOrgWithHttpInfo($org, $pre_receive_hook_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForOrgWithHttpInfo
     *
     * Remove pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForOrgWithHttpInfo($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'][0])
    {
        $request = $this->enterpriseAdminRemovePreReceiveHookEnforcementForOrgRequest($org, $pre_receive_hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForOrgAsync
     *
     * Remove pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForOrgAsync($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'][0])
    {
        return $this->enterpriseAdminRemovePreReceiveHookEnforcementForOrgAsyncWithHttpInfo($org, $pre_receive_hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForOrgAsyncWithHttpInfo
     *
     * Remove pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForOrgAsyncWithHttpInfo($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook';
        $request = $this->enterpriseAdminRemovePreReceiveHookEnforcementForOrgRequest($org, $pre_receive_hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemovePreReceiveHookEnforcementForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForOrgRequest($org, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling enterpriseAdminRemovePreReceiveHookEnforcementForOrg'
            );
        }

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminRemovePreReceiveHookEnforcementForOrg'
            );
        }


        $resourcePath = '/orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForRepo
     *
     * Remove pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForRepo($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'][0])
    {
        list($response) = $this->enterpriseAdminRemovePreReceiveHookEnforcementForRepoWithHttpInfo($owner, $repo, $pre_receive_hook_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForRepoWithHttpInfo
     *
     * Remove pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForRepoWithHttpInfo($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'][0])
    {
        $request = $this->enterpriseAdminRemovePreReceiveHookEnforcementForRepoRequest($owner, $repo, $pre_receive_hook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForRepoAsync
     *
     * Remove pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForRepoAsync($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'][0])
    {
        return $this->enterpriseAdminRemovePreReceiveHookEnforcementForRepoAsyncWithHttpInfo($owner, $repo, $pre_receive_hook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemovePreReceiveHookEnforcementForRepoAsyncWithHttpInfo
     *
     * Remove pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForRepoAsyncWithHttpInfo($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook';
        $request = $this->enterpriseAdminRemovePreReceiveHookEnforcementForRepoRequest($owner, $repo, $pre_receive_hook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemovePreReceiveHookEnforcementForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemovePreReceiveHookEnforcementForRepoRequest($owner, $repo, $pre_receive_hook_id, string $contentType = self::contentTypes['enterpriseAdminRemovePreReceiveHookEnforcementForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling enterpriseAdminRemovePreReceiveHookEnforcementForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling enterpriseAdminRemovePreReceiveHookEnforcementForRepo'
            );
        }

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminRemovePreReceiveHookEnforcementForRepo'
            );
        }


        $resourcePath = '/repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise
     *
     * Remove a self-hosted runner from a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'][0])
    {
        $this->enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $runner_id, $contentType);
    }

    /**
     * Operation enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseWithHttpInfo
     *
     * Remove a self-hosted runner from a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest($enterprise, $runner_group_id, $runner_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseAsync
     *
     * Remove a self-hosted runner from a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseAsync($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $runner_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseAsyncWithHttpInfo
     *
     * Remove a self-hosted runner from a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest($enterprise, $runner_group_id, $runner_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest($enterprise, $runner_group_id, $runner_id, string $contentType = self::contentTypes['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners/{runner_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetAllowedActionsEnterprise
     *
     * Set allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions selected_actions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetAllowedActionsEnterprise($enterprise, $selected_actions, string $contentType = self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'][0])
    {
        $this->enterpriseAdminSetAllowedActionsEnterpriseWithHttpInfo($enterprise, $selected_actions, $contentType);
    }

    /**
     * Operation enterpriseAdminSetAllowedActionsEnterpriseWithHttpInfo
     *
     * Set allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetAllowedActionsEnterpriseWithHttpInfo($enterprise, $selected_actions, string $contentType = self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminSetAllowedActionsEnterpriseRequest($enterprise, $selected_actions, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetAllowedActionsEnterpriseAsync
     *
     * Set allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetAllowedActionsEnterpriseAsync($enterprise, $selected_actions, string $contentType = self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'][0])
    {
        return $this->enterpriseAdminSetAllowedActionsEnterpriseAsyncWithHttpInfo($enterprise, $selected_actions, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetAllowedActionsEnterpriseAsyncWithHttpInfo
     *
     * Set allowed actions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetAllowedActionsEnterpriseAsyncWithHttpInfo($enterprise, $selected_actions, string $contentType = self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetAllowedActionsEnterpriseRequest($enterprise, $selected_actions, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetAllowedActionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SelectedActions $selected_actions (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetAllowedActionsEnterpriseRequest($enterprise, $selected_actions, string $contentType = self::contentTypes['enterpriseAdminSetAllowedActionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetAllowedActionsEnterprise'
            );
        }

        // verify the required parameter 'selected_actions' is set
        if ($selected_actions === null || (is_array($selected_actions) && count($selected_actions) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $selected_actions when calling enterpriseAdminSetAllowedActionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/selected-actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($selected_actions)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($selected_actions));
            } else {
                $httpBody = $selected_actions;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetAnnouncement
     *
     * Set the global announcement banner
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement $announcement announcement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement
     */
    public function enterpriseAdminSetAnnouncement($announcement, string $contentType = self::contentTypes['enterpriseAdminSetAnnouncement'][0])
    {
        list($response) = $this->enterpriseAdminSetAnnouncementWithHttpInfo($announcement, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSetAnnouncementWithHttpInfo
     *
     * Set the global announcement banner
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement $announcement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetAnnouncementWithHttpInfo($announcement, string $contentType = self::contentTypes['enterpriseAdminSetAnnouncement'][0])
    {
        $request = $this->enterpriseAdminSetAnnouncementRequest($announcement, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetAnnouncementAsync
     *
     * Set the global announcement banner
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement $announcement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetAnnouncementAsync($announcement, string $contentType = self::contentTypes['enterpriseAdminSetAnnouncement'][0])
    {
        return $this->enterpriseAdminSetAnnouncementAsyncWithHttpInfo($announcement, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetAnnouncementAsyncWithHttpInfo
     *
     * Set the global announcement banner
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement $announcement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetAnnouncementAsyncWithHttpInfo($announcement, string $contentType = self::contentTypes['enterpriseAdminSetAnnouncement'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement';
        $request = $this->enterpriseAdminSetAnnouncementRequest($announcement, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetAnnouncement'
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Announcement $announcement (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetAnnouncement'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetAnnouncementRequest($announcement, string $contentType = self::contentTypes['enterpriseAdminSetAnnouncement'][0])
    {

        // verify the required parameter 'announcement' is set
        if ($announcement === null || (is_array($announcement) && count($announcement) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $announcement when calling enterpriseAdminSetAnnouncement'
            );
        }


        $resourcePath = '/enterprise/announcement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($announcement)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($announcement));
            } else {
                $httpBody = $announcement;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise
     *
     * Set custom labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple
     */
    public function enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseWithHttpInfo
     *
     * Set custom labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseWithHttpInfo($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        $request = $this->enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationErrorSimple',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseAsync
     *
     * Set custom labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseAsync($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        return $this->enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseAsyncWithHttpInfo
     *
     * Set custom labels for a self-hosted runner for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseAsyncWithHttpInfo($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200Response';
        $request = $this->enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_id Unique identifier of the self-hosted runner. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest($enterprise, $runner_id, $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'runner_id' is set
        if ($runner_id === null || (is_array($runner_id) && count($runner_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_id when calling enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request' is set
        if ($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request === null || (is_array($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request) && count($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request when calling enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runners/{runner_id}/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_id' . '}',
                ObjectSerializer::toPathValue($runner_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_custom_labels_for_self_hosted_runner_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetGithubActionsPermissionsEnterprise
     *
     * Set GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest $enterprise_admin_set_github_actions_permissions_enterprise_request enterprise_admin_set_github_actions_permissions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetGithubActionsPermissionsEnterprise($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'][0])
    {
        $this->enterpriseAdminSetGithubActionsPermissionsEnterpriseWithHttpInfo($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, $contentType);
    }

    /**
     * Operation enterpriseAdminSetGithubActionsPermissionsEnterpriseWithHttpInfo
     *
     * Set GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest $enterprise_admin_set_github_actions_permissions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetGithubActionsPermissionsEnterpriseWithHttpInfo($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminSetGithubActionsPermissionsEnterpriseRequest($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetGithubActionsPermissionsEnterpriseAsync
     *
     * Set GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest $enterprise_admin_set_github_actions_permissions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetGithubActionsPermissionsEnterpriseAsync($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'][0])
    {
        return $this->enterpriseAdminSetGithubActionsPermissionsEnterpriseAsyncWithHttpInfo($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetGithubActionsPermissionsEnterpriseAsyncWithHttpInfo
     *
     * Set GitHub Actions permissions for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest $enterprise_admin_set_github_actions_permissions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetGithubActionsPermissionsEnterpriseAsyncWithHttpInfo($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetGithubActionsPermissionsEnterpriseRequest($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetGithubActionsPermissionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest $enterprise_admin_set_github_actions_permissions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetGithubActionsPermissionsEnterpriseRequest($enterprise, $enterprise_admin_set_github_actions_permissions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetGithubActionsPermissionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetGithubActionsPermissionsEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_set_github_actions_permissions_enterprise_request' is set
        if ($enterprise_admin_set_github_actions_permissions_enterprise_request === null || (is_array($enterprise_admin_set_github_actions_permissions_enterprise_request) && count($enterprise_admin_set_github_actions_permissions_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_github_actions_permissions_enterprise_request when calling enterpriseAdminSetGithubActionsPermissionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_github_actions_permissions_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_github_actions_permissions_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_github_actions_permissions_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseGroup
     *
     * Set SCIM information for a provisioned enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseGroup($scim_group_id, $enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'][0])
    {
        list($response) = $this->enterpriseAdminSetInformationForProvisionedEnterpriseGroupWithHttpInfo($scim_group_id, $enterprise, $group, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseGroupWithHttpInfo
     *
     * Set SCIM information for a provisioned enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseGroupWithHttpInfo($scim_group_id, $enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'][0])
    {
        $request = $this->enterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest($scim_group_id, $enterprise, $group, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseGroupAsync
     *
     * Set SCIM information for a provisioned enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseGroupAsync($scim_group_id, $enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'][0])
    {
        return $this->enterpriseAdminSetInformationForProvisionedEnterpriseGroupAsyncWithHttpInfo($scim_group_id, $enterprise, $group, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseGroupAsyncWithHttpInfo
     *
     * Set SCIM information for a provisioned enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseGroupAsyncWithHttpInfo($scim_group_id, $enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
        $request = $this->enterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest($scim_group_id, $enterprise, $group, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetInformationForProvisionedEnterpriseGroup'
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Group $group (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseGroupRequest($scim_group_id, $enterprise, $group, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseGroup'][0])
    {

        // verify the required parameter 'scim_group_id' is set
        if ($scim_group_id === null || (is_array($scim_group_id) && count($scim_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_group_id when calling enterpriseAdminSetInformationForProvisionedEnterpriseGroup'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetInformationForProvisionedEnterpriseGroup'
            );
        }

        // verify the required parameter 'group' is set
        if ($group === null || (is_array($group) && count($group) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group when calling enterpriseAdminSetInformationForProvisionedEnterpriseGroup'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_group_id' . '}',
                ObjectSerializer::toPathValue($scim_group_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($group)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($group));
            } else {
                $httpBody = $group;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseUser
     *
     * Set SCIM information for a provisioned enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseUser($scim_user_id, $enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'][0])
    {
        list($response) = $this->enterpriseAdminSetInformationForProvisionedEnterpriseUserWithHttpInfo($scim_user_id, $enterprise, $user, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseUserWithHttpInfo
     *
     * Set SCIM information for a provisioned enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseUserWithHttpInfo($scim_user_id, $enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'][0])
    {
        $request = $this->enterpriseAdminSetInformationForProvisionedEnterpriseUserRequest($scim_user_id, $enterprise, $user, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseUserAsync
     *
     * Set SCIM information for a provisioned enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseUserAsync($scim_user_id, $enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'][0])
    {
        return $this->enterpriseAdminSetInformationForProvisionedEnterpriseUserAsyncWithHttpInfo($scim_user_id, $enterprise, $user, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetInformationForProvisionedEnterpriseUserAsyncWithHttpInfo
     *
     * Set SCIM information for a provisioned enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseUserAsyncWithHttpInfo($scim_user_id, $enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
        $request = $this->enterpriseAdminSetInformationForProvisionedEnterpriseUserRequest($scim_user_id, $enterprise, $user, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetInformationForProvisionedEnterpriseUser'
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\User $user (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetInformationForProvisionedEnterpriseUserRequest($scim_user_id, $enterprise, $user, string $contentType = self::contentTypes['enterpriseAdminSetInformationForProvisionedEnterpriseUser'][0])
    {

        // verify the required parameter 'scim_user_id' is set
        if ($scim_user_id === null || (is_array($scim_user_id) && count($scim_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_user_id when calling enterpriseAdminSetInformationForProvisionedEnterpriseUser'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetInformationForProvisionedEnterpriseUser'
            );
        }

        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling enterpriseAdminSetInformationForProvisionedEnterpriseUser'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_user_id' . '}',
                ObjectSerializer::toPathValue($scim_user_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user));
            } else {
                $httpBody = $user;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetManageMaintenance
     *
     * Set the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceRequest $ghes_set_maintenance_request ghes_set_maintenance_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]
     */
    public function enterpriseAdminSetManageMaintenance($ghes_set_maintenance_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageMaintenance'][0])
    {
        list($response) = $this->enterpriseAdminSetManageMaintenanceWithHttpInfo($ghes_set_maintenance_request, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSetManageMaintenanceWithHttpInfo
     *
     * Set the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceRequest $ghes_set_maintenance_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetManageMaintenanceWithHttpInfo($ghes_set_maintenance_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageMaintenance'][0])
    {
        $request = $this->enterpriseAdminSetManageMaintenanceRequest($ghes_set_maintenance_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetManageMaintenanceAsync
     *
     * Set the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceRequest $ghes_set_maintenance_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetManageMaintenanceAsync($ghes_set_maintenance_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageMaintenance'][0])
    {
        return $this->enterpriseAdminSetManageMaintenanceAsyncWithHttpInfo($ghes_set_maintenance_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetManageMaintenanceAsyncWithHttpInfo
     *
     * Set the status of maintenance mode
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceRequest $ghes_set_maintenance_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetManageMaintenanceAsyncWithHttpInfo($ghes_set_maintenance_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageMaintenance'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceResponseInner[]';
        $request = $this->enterpriseAdminSetManageMaintenanceRequest($ghes_set_maintenance_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetManageMaintenance'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetMaintenanceRequest $ghes_set_maintenance_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageMaintenance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetManageMaintenanceRequest($ghes_set_maintenance_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageMaintenance'][0])
    {

        // verify the required parameter 'ghes_set_maintenance_request' is set
        if ($ghes_set_maintenance_request === null || (is_array($ghes_set_maintenance_request) && count($ghes_set_maintenance_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ghes_set_maintenance_request when calling enterpriseAdminSetManageMaintenance'
            );
        }


        $resourcePath = '/manage/v1/maintenance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ghes_set_maintenance_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ghes_set_maintenance_request));
            } else {
                $httpBody = $ghes_set_maintenance_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminSetManageMaintenance();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminSetManageMaintenance
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminSetManageMaintenance(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminSetManageSettings
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  object $body Only the settings parameters that should be modified need to be specified. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetManageSettings($body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSettings'][0])
    {
        $this->enterpriseAdminSetManageSettingsWithHttpInfo($body, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation enterpriseAdminSetManageSettingsWithHttpInfo
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  object $body Only the settings parameters that should be modified need to be specified. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetManageSettingsWithHttpInfo($body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSettings'][0])
    {
        $request = $this->enterpriseAdminSetManageSettingsRequest($body, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetManageSettingsAsync
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  object $body Only the settings parameters that should be modified need to be specified. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetManageSettingsAsync($body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSettings'][0])
    {
        return $this->enterpriseAdminSetManageSettingsAsyncWithHttpInfo($body, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetManageSettingsAsyncWithHttpInfo
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  object $body Only the settings parameters that should be modified need to be specified. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetManageSettingsAsyncWithHttpInfo($body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSettings'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetManageSettingsRequest($body, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetManageSettings'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  object $body Only the settings parameters that should be modified need to be specified. (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetManageSettingsRequest($body, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSettings'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling enterpriseAdminSetManageSettings'
            );
        }


        $resourcePath = '/manage/v1/config/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminSetManageSettings();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminSetManageSettings
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminSetManageSettings(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminSetManageSsh
     *
     * Set a new SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshRequest $ghes_set_ssh_request ghes_set_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSsh'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]
     */
    public function enterpriseAdminSetManageSsh($ghes_set_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSsh'][0])
    {
        list($response) = $this->enterpriseAdminSetManageSshWithHttpInfo($ghes_set_ssh_request, $hostIndex, $variables, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSetManageSshWithHttpInfo
     *
     * Set a new SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshRequest $ghes_set_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSsh'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[], HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetManageSshWithHttpInfo($ghes_set_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSsh'][0])
    {
        $request = $this->enterpriseAdminSetManageSshRequest($ghes_set_ssh_request, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetManageSshAsync
     *
     * Set a new SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshRequest $ghes_set_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetManageSshAsync($ghes_set_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSsh'][0])
    {
        return $this->enterpriseAdminSetManageSshAsyncWithHttpInfo($ghes_set_ssh_request, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetManageSshAsyncWithHttpInfo
     *
     * Set a new SSH key
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshRequest $ghes_set_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetManageSshAsyncWithHttpInfo($ghes_set_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSsh'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshResponseInner[]';
        $request = $this->enterpriseAdminSetManageSshRequest($ghes_set_ssh_request, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetManageSsh'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GhesSetSshRequest $ghes_set_ssh_request (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetManageSsh'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetManageSshRequest($ghes_set_ssh_request, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetManageSsh'][0])
    {

        // verify the required parameter 'ghes_set_ssh_request' is set
        if ($ghes_set_ssh_request === null || (is_array($ghes_set_ssh_request) && count($ghes_set_ssh_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ghes_set_ssh_request when calling enterpriseAdminSetManageSsh'
            );
        }


        $resourcePath = '/manage/v1/access/ssh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ghes_set_ssh_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ghes_set_ssh_request));
            } else {
                $httpBody = $ghes_set_ssh_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminSetManageSsh();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminSetManageSsh
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminSetManageSsh(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise
     *
     * Set organization access for a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $this->enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, $contentType);
    }

    /**
     * Operation enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo
     *
     * Set organization access for a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $request = $this->enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync
     *
     * Set organization access for a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseAsync($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        return $this->enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo
     *
     * Set organization access for a self-hosted runner group in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request' is set
        if ($enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request === null || (is_array($enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request) && count($enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request when calling enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_org_access_to_self_hosted_runner_group_in_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise
     *
     * Set selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        $this->enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseWithHttpInfo($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, $contentType);
    }

    /**
     * Operation enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseWithHttpInfo
     *
     * Set selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseWithHttpInfo($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        $request = $this->enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseAsync
     *
     * Set selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseAsync($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        return $this->enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseAsyncWithHttpInfo
     *
     * Set selected organizations enabled for GitHub Actions in an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseAsyncWithHttpInfo($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest($enterprise, $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request' is set
        if ($enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request === null || (is_array($enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request) && count($enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request when calling enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/permissions/organizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_selected_organizations_enabled_github_actions_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise
     *
     * Set self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'][0])
    {
        $this->enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType);
    }

    /**
     * Operation enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseWithHttpInfo
     *
     * Set self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseAsync
     *
     * Set self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseAsync($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseAsyncWithHttpInfo
     *
     * Set self-hosted runners in a group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request, string $contentType = self::contentTypes['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'
            );
        }

        // verify the required parameter 'enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request' is set
        if ($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request === null || (is_array($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request) && count($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request when calling enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_set_self_hosted_runners_in_group_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSetSettings
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $settings A JSON string with the new settings. Note that you only need to pass the specific settings you want to modify. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSetSettings($settings, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetSettings'][0])
    {
        $this->enterpriseAdminSetSettingsWithHttpInfo($settings, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation enterpriseAdminSetSettingsWithHttpInfo
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $settings A JSON string with the new settings. Note that you only need to pass the specific settings you want to modify. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSettings'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSetSettingsWithHttpInfo($settings, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetSettings'][0])
    {
        $request = $this->enterpriseAdminSetSettingsRequest($settings, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSetSettingsAsync
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $settings A JSON string with the new settings. Note that you only need to pass the specific settings you want to modify. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetSettingsAsync($settings, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetSettings'][0])
    {
        return $this->enterpriseAdminSetSettingsAsyncWithHttpInfo($settings, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSetSettingsAsyncWithHttpInfo
     *
     * Set settings
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $settings A JSON string with the new settings. Note that you only need to pass the specific settings you want to modify. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSetSettingsAsyncWithHttpInfo($settings, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetSettings'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSetSettingsRequest($settings, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSetSettings'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $settings A JSON string with the new settings. Note that you only need to pass the specific settings you want to modify. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.12/rest/enterprise-admin/management-console#get-settings). (required)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSetSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSetSettingsRequest($settings, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminSetSettings'][0])
    {

        // verify the required parameter 'settings' is set
        if ($settings === null || (is_array($settings) && count($settings) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $settings when calling enterpriseAdminSetSettings'
            );
        }


        $resourcePath = '/setup/api/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($settings !== null) {
            $formParams['settings'] = ObjectSerializer::toFormValue($settings);
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminSetSettings();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminSetSettings
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminSetSettings(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminStartConfigurationProcess
     *
     * Start a configuration process
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartConfigurationProcess'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminStartConfigurationProcess(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminStartConfigurationProcess'][0])
    {
        $this->enterpriseAdminStartConfigurationProcessWithHttpInfo($hostIndex, $variables, $contentType);
    }

    /**
     * Operation enterpriseAdminStartConfigurationProcessWithHttpInfo
     *
     * Start a configuration process
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartConfigurationProcess'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminStartConfigurationProcessWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminStartConfigurationProcess'][0])
    {
        $request = $this->enterpriseAdminStartConfigurationProcessRequest($hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminStartConfigurationProcessAsync
     *
     * Start a configuration process
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartConfigurationProcess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminStartConfigurationProcessAsync(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminStartConfigurationProcess'][0])
    {
        return $this->enterpriseAdminStartConfigurationProcessAsyncWithHttpInfo($hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminStartConfigurationProcessAsyncWithHttpInfo
     *
     * Start a configuration process
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartConfigurationProcess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminStartConfigurationProcessAsyncWithHttpInfo(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminStartConfigurationProcess'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminStartConfigurationProcessRequest($hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminStartConfigurationProcess'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartConfigurationProcess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminStartConfigurationProcessRequest(?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminStartConfigurationProcess'][0])
    {


        $resourcePath = '/setup/api/configure';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminStartConfigurationProcess();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminStartConfigurationProcess
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminStartConfigurationProcess(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation enterpriseAdminStartPreReceiveEnvironmentDownload
     *
     * Start a pre-receive environment download
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response
     */
    public function enterpriseAdminStartPreReceiveEnvironmentDownload($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'][0])
    {
        list($response) = $this->enterpriseAdminStartPreReceiveEnvironmentDownloadWithHttpInfo($pre_receive_environment_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminStartPreReceiveEnvironmentDownloadWithHttpInfo
     *
     * Start a pre-receive environment download
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminStartPreReceiveEnvironmentDownloadWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'][0])
    {
        $request = $this->enterpriseAdminStartPreReceiveEnvironmentDownloadRequest($pre_receive_environment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminStartPreReceiveEnvironmentDownloadAsync
     *
     * Start a pre-receive environment download
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminStartPreReceiveEnvironmentDownloadAsync($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'][0])
    {
        return $this->enterpriseAdminStartPreReceiveEnvironmentDownloadAsyncWithHttpInfo($pre_receive_environment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminStartPreReceiveEnvironmentDownloadAsyncWithHttpInfo
     *
     * Start a pre-receive environment download
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminStartPreReceiveEnvironmentDownloadAsyncWithHttpInfo($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironmentDownloadStatus';
        $request = $this->enterpriseAdminStartPreReceiveEnvironmentDownloadRequest($pre_receive_environment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminStartPreReceiveEnvironmentDownload'
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminStartPreReceiveEnvironmentDownloadRequest($pre_receive_environment_id, string $contentType = self::contentTypes['enterpriseAdminStartPreReceiveEnvironmentDownload'][0])
    {

        // verify the required parameter 'pre_receive_environment_id' is set
        if ($pre_receive_environment_id === null || (is_array($pre_receive_environment_id) && count($pre_receive_environment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_environment_id when calling enterpriseAdminStartPreReceiveEnvironmentDownload'
            );
        }


        $resourcePath = '/admin/pre-receive-environments/{pre_receive_environment_id}/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_environment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_environment_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_environment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSuspendUser
     *
     * Suspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSuspendUserRequest $enterprise_admin_suspend_user_request enterprise_admin_suspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSuspendUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminSuspendUser($username, $enterprise_admin_suspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminSuspendUser'][0])
    {
        $this->enterpriseAdminSuspendUserWithHttpInfo($username, $enterprise_admin_suspend_user_request, $contentType);
    }

    /**
     * Operation enterpriseAdminSuspendUserWithHttpInfo
     *
     * Suspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSuspendUserRequest $enterprise_admin_suspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSuspendUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSuspendUserWithHttpInfo($username, $enterprise_admin_suspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminSuspendUser'][0])
    {
        $request = $this->enterpriseAdminSuspendUserRequest($username, $enterprise_admin_suspend_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSuspendUserAsync
     *
     * Suspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSuspendUserRequest $enterprise_admin_suspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSuspendUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSuspendUserAsync($username, $enterprise_admin_suspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminSuspendUser'][0])
    {
        return $this->enterpriseAdminSuspendUserAsyncWithHttpInfo($username, $enterprise_admin_suspend_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSuspendUserAsyncWithHttpInfo
     *
     * Suspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSuspendUserRequest $enterprise_admin_suspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSuspendUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSuspendUserAsyncWithHttpInfo($username, $enterprise_admin_suspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminSuspendUser'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminSuspendUserRequest($username, $enterprise_admin_suspend_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSuspendUser'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSuspendUserRequest $enterprise_admin_suspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSuspendUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSuspendUserRequest($username, $enterprise_admin_suspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminSuspendUser'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminSuspendUser'
            );
        }



        $resourcePath = '/users/{username}/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_suspend_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_suspend_user_request));
            } else {
                $httpBody = $enterprise_admin_suspend_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForTeam
     *
     * Sync LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response
     */
    public function enterpriseAdminSyncLdapMappingForTeam($team_id, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'][0])
    {
        list($response) = $this->enterpriseAdminSyncLdapMappingForTeamWithHttpInfo($team_id, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForTeamWithHttpInfo
     *
     * Sync LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSyncLdapMappingForTeamWithHttpInfo($team_id, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'][0])
    {
        $request = $this->enterpriseAdminSyncLdapMappingForTeamRequest($team_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForTeamAsync
     *
     * Sync LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSyncLdapMappingForTeamAsync($team_id, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'][0])
    {
        return $this->enterpriseAdminSyncLdapMappingForTeamAsyncWithHttpInfo($team_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForTeamAsyncWithHttpInfo
     *
     * Sync LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSyncLdapMappingForTeamAsyncWithHttpInfo($team_id, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response';
        $request = $this->enterpriseAdminSyncLdapMappingForTeamRequest($team_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSyncLdapMappingForTeam'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSyncLdapMappingForTeamRequest($team_id, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForTeam'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling enterpriseAdminSyncLdapMappingForTeam'
            );
        }


        $resourcePath = '/admin/ldap/teams/{team_id}/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForUser
     *
     * Sync LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response
     */
    public function enterpriseAdminSyncLdapMappingForUser($username, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForUser'][0])
    {
        list($response) = $this->enterpriseAdminSyncLdapMappingForUserWithHttpInfo($username, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForUserWithHttpInfo
     *
     * Sync LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminSyncLdapMappingForUserWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForUser'][0])
    {
        $request = $this->enterpriseAdminSyncLdapMappingForUserRequest($username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForUserAsync
     *
     * Sync LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSyncLdapMappingForUserAsync($username, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForUser'][0])
    {
        return $this->enterpriseAdminSyncLdapMappingForUserAsyncWithHttpInfo($username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminSyncLdapMappingForUserAsyncWithHttpInfo
     *
     * Sync LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminSyncLdapMappingForUserAsyncWithHttpInfo($username, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminSyncLdapMappingForTeam201Response';
        $request = $this->enterpriseAdminSyncLdapMappingForUserRequest($username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminSyncLdapMappingForUser'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminSyncLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminSyncLdapMappingForUserRequest($username, string $contentType = self::contentTypes['enterpriseAdminSyncLdapMappingForUser'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminSyncLdapMappingForUser'
            );
        }


        $resourcePath = '/admin/ldap/users/{username}/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUnsuspendUser
     *
     * Unsuspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUnsuspendUserRequest $enterprise_admin_unsuspend_user_request enterprise_admin_unsuspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUnsuspendUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminUnsuspendUser($username, $enterprise_admin_unsuspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminUnsuspendUser'][0])
    {
        $this->enterpriseAdminUnsuspendUserWithHttpInfo($username, $enterprise_admin_unsuspend_user_request, $contentType);
    }

    /**
     * Operation enterpriseAdminUnsuspendUserWithHttpInfo
     *
     * Unsuspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUnsuspendUserRequest $enterprise_admin_unsuspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUnsuspendUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUnsuspendUserWithHttpInfo($username, $enterprise_admin_unsuspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminUnsuspendUser'][0])
    {
        $request = $this->enterpriseAdminUnsuspendUserRequest($username, $enterprise_admin_unsuspend_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUnsuspendUserAsync
     *
     * Unsuspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUnsuspendUserRequest $enterprise_admin_unsuspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUnsuspendUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUnsuspendUserAsync($username, $enterprise_admin_unsuspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminUnsuspendUser'][0])
    {
        return $this->enterpriseAdminUnsuspendUserAsyncWithHttpInfo($username, $enterprise_admin_unsuspend_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUnsuspendUserAsyncWithHttpInfo
     *
     * Unsuspend a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUnsuspendUserRequest $enterprise_admin_unsuspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUnsuspendUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUnsuspendUserAsyncWithHttpInfo($username, $enterprise_admin_unsuspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminUnsuspendUser'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminUnsuspendUserRequest($username, $enterprise_admin_unsuspend_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUnsuspendUser'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUnsuspendUserRequest $enterprise_admin_unsuspend_user_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUnsuspendUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUnsuspendUserRequest($username, $enterprise_admin_unsuspend_user_request = null, string $contentType = self::contentTypes['enterpriseAdminUnsuspendUser'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminUnsuspendUser'
            );
        }



        $resourcePath = '/users/{username}/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_unsuspend_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_unsuspend_user_request));
            } else {
                $httpBody = $enterprise_admin_unsuspend_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseGroup
     *
     * Update an attribute for a SCIM enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseGroup($scim_group_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'][0])
    {
        list($response) = $this->enterpriseAdminUpdateAttributeForEnterpriseGroupWithHttpInfo($scim_group_id, $enterprise, $patch_schema, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseGroupWithHttpInfo
     *
     * Update an attribute for a SCIM enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseGroupWithHttpInfo($scim_group_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'][0])
    {
        $request = $this->enterpriseAdminUpdateAttributeForEnterpriseGroupRequest($scim_group_id, $enterprise, $patch_schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseGroupAsync
     *
     * Update an attribute for a SCIM enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseGroupAsync($scim_group_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'][0])
    {
        return $this->enterpriseAdminUpdateAttributeForEnterpriseGroupAsyncWithHttpInfo($scim_group_id, $enterprise, $patch_schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseGroupAsyncWithHttpInfo
     *
     * Update an attribute for a SCIM enterprise group
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseGroupAsyncWithHttpInfo($scim_group_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseGroupResponse';
        $request = $this->enterpriseAdminUpdateAttributeForEnterpriseGroupRequest($scim_group_id, $enterprise, $patch_schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateAttributeForEnterpriseGroup'
     *
     * @param  string $scim_group_id A unique identifier of the SCIM group. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseGroupRequest($scim_group_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseGroup'][0])
    {

        // verify the required parameter 'scim_group_id' is set
        if ($scim_group_id === null || (is_array($scim_group_id) && count($scim_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_group_id when calling enterpriseAdminUpdateAttributeForEnterpriseGroup'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminUpdateAttributeForEnterpriseGroup'
            );
        }

        // verify the required parameter 'patch_schema' is set
        if ($patch_schema === null || (is_array($patch_schema) && count($patch_schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_schema when calling enterpriseAdminUpdateAttributeForEnterpriseGroup'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Groups/{scim_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_group_id' . '}',
                ObjectSerializer::toPathValue($scim_group_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patch_schema)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patch_schema));
            } else {
                $httpBody = $patch_schema;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseUser
     *
     * Update an attribute for a SCIM enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseUser($scim_user_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'][0])
    {
        list($response) = $this->enterpriseAdminUpdateAttributeForEnterpriseUserWithHttpInfo($scim_user_id, $enterprise, $patch_schema, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseUserWithHttpInfo
     *
     * Update an attribute for a SCIM enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseUserWithHttpInfo($scim_user_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'][0])
    {
        $request = $this->enterpriseAdminUpdateAttributeForEnterpriseUserRequest($scim_user_id, $enterprise, $patch_schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseUserAsync
     *
     * Update an attribute for a SCIM enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseUserAsync($scim_user_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'][0])
    {
        return $this->enterpriseAdminUpdateAttributeForEnterpriseUserAsyncWithHttpInfo($scim_user_id, $enterprise, $patch_schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateAttributeForEnterpriseUserAsyncWithHttpInfo
     *
     * Update an attribute for a SCIM enterprise user
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseUserAsyncWithHttpInfo($scim_user_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ScimEnterpriseUserResponse';
        $request = $this->enterpriseAdminUpdateAttributeForEnterpriseUserRequest($scim_user_id, $enterprise, $patch_schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateAttributeForEnterpriseUser'
     *
     * @param  string $scim_user_id The unique identifier of the SCIM user. (required)
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PatchSchema $patch_schema (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateAttributeForEnterpriseUserRequest($scim_user_id, $enterprise, $patch_schema, string $contentType = self::contentTypes['enterpriseAdminUpdateAttributeForEnterpriseUser'][0])
    {

        // verify the required parameter 'scim_user_id' is set
        if ($scim_user_id === null || (is_array($scim_user_id) && count($scim_user_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scim_user_id when calling enterpriseAdminUpdateAttributeForEnterpriseUser'
            );
        }

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminUpdateAttributeForEnterpriseUser'
            );
        }

        // verify the required parameter 'patch_schema' is set
        if ($patch_schema === null || (is_array($patch_schema) && count($patch_schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patch_schema when calling enterpriseAdminUpdateAttributeForEnterpriseUser'
            );
        }


        $resourcePath = '/scim/v2/enterprises/{enterprise}/Users/{scim_user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scim_user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scim_user_id' . '}',
                ObjectSerializer::toPathValue($scim_user_id),
                $resourcePath
            );
        }
        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/scim+json', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patch_schema)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patch_schema));
            } else {
                $httpBody = $patch_schema;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateGlobalWebhook
     *
     * Update a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateGlobalWebhookRequest $enterprise_admin_update_global_webhook_request enterprise_admin_update_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2
     */
    public function enterpriseAdminUpdateGlobalWebhook($hook_id, $enterprise_admin_update_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminUpdateGlobalWebhook'][0])
    {
        list($response) = $this->enterpriseAdminUpdateGlobalWebhookWithHttpInfo($hook_id, $enterprise_admin_update_global_webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateGlobalWebhookWithHttpInfo
     *
     * Update a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateGlobalWebhookRequest $enterprise_admin_update_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateGlobalWebhookWithHttpInfo($hook_id, $enterprise_admin_update_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminUpdateGlobalWebhook'][0])
    {
        $request = $this->enterpriseAdminUpdateGlobalWebhookRequest($hook_id, $enterprise_admin_update_global_webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateGlobalWebhookAsync
     *
     * Update a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateGlobalWebhookRequest $enterprise_admin_update_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateGlobalWebhookAsync($hook_id, $enterprise_admin_update_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminUpdateGlobalWebhook'][0])
    {
        return $this->enterpriseAdminUpdateGlobalWebhookAsyncWithHttpInfo($hook_id, $enterprise_admin_update_global_webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateGlobalWebhookAsyncWithHttpInfo
     *
     * Update a global webhook
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateGlobalWebhookRequest $enterprise_admin_update_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateGlobalWebhookAsyncWithHttpInfo($hook_id, $enterprise_admin_update_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminUpdateGlobalWebhook'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\GlobalHook2';
        $request = $this->enterpriseAdminUpdateGlobalWebhookRequest($hook_id, $enterprise_admin_update_global_webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateGlobalWebhook'
     *
     * @param  int $hook_id The unique identifier of the hook. You can find this value in the &#x60;X-GitHub-Hook-ID&#x60; header of a webhook delivery. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateGlobalWebhookRequest $enterprise_admin_update_global_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateGlobalWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateGlobalWebhookRequest($hook_id, $enterprise_admin_update_global_webhook_request, string $contentType = self::contentTypes['enterpriseAdminUpdateGlobalWebhook'][0])
    {

        // verify the required parameter 'hook_id' is set
        if ($hook_id === null || (is_array($hook_id) && count($hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hook_id when calling enterpriseAdminUpdateGlobalWebhook'
            );
        }

        // verify the required parameter 'enterprise_admin_update_global_webhook_request' is set
        if ($enterprise_admin_update_global_webhook_request === null || (is_array($enterprise_admin_update_global_webhook_request) && count($enterprise_admin_update_global_webhook_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_update_global_webhook_request when calling enterpriseAdminUpdateGlobalWebhook'
            );
        }


        $resourcePath = '/admin/hooks/{hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'hook_id' . '}',
                ObjectSerializer::toPathValue($hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_global_webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_global_webhook_request));
            } else {
                $httpBody = $enterprise_admin_update_global_webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForTeam
     *
     * Update LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam
     */
    public function enterpriseAdminUpdateLdapMappingForTeam($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'][0])
    {
        list($response) = $this->enterpriseAdminUpdateLdapMappingForTeamWithHttpInfo($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForTeamWithHttpInfo
     *
     * Update LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateLdapMappingForTeamWithHttpInfo($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'][0])
    {
        $request = $this->enterpriseAdminUpdateLdapMappingForTeamRequest($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForTeamAsync
     *
     * Update LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateLdapMappingForTeamAsync($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'][0])
    {
        return $this->enterpriseAdminUpdateLdapMappingForTeamAsyncWithHttpInfo($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForTeamAsyncWithHttpInfo
     *
     * Update LDAP mapping for a team
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateLdapMappingForTeamAsyncWithHttpInfo($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingTeam';
        $request = $this->enterpriseAdminUpdateLdapMappingForTeamRequest($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateLdapMappingForTeam'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateLdapMappingForTeamRequest($team_id, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForTeam'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling enterpriseAdminUpdateLdapMappingForTeam'
            );
        }

        // verify the required parameter 'enterprise_admin_update_ldap_mapping_for_team_request' is set
        if ($enterprise_admin_update_ldap_mapping_for_team_request === null || (is_array($enterprise_admin_update_ldap_mapping_for_team_request) && count($enterprise_admin_update_ldap_mapping_for_team_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_update_ldap_mapping_for_team_request when calling enterpriseAdminUpdateLdapMappingForTeam'
            );
        }


        $resourcePath = '/admin/ldap/teams/{team_id}/mapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_ldap_mapping_for_team_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_ldap_mapping_for_team_request));
            } else {
                $httpBody = $enterprise_admin_update_ldap_mapping_for_team_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForUser
     *
     * Update LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser
     */
    public function enterpriseAdminUpdateLdapMappingForUser($username, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'][0])
    {
        list($response) = $this->enterpriseAdminUpdateLdapMappingForUserWithHttpInfo($username, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForUserWithHttpInfo
     *
     * Update LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateLdapMappingForUserWithHttpInfo($username, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'][0])
    {
        $request = $this->enterpriseAdminUpdateLdapMappingForUserRequest($username, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForUserAsync
     *
     * Update LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateLdapMappingForUserAsync($username, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'][0])
    {
        return $this->enterpriseAdminUpdateLdapMappingForUserAsyncWithHttpInfo($username, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateLdapMappingForUserAsyncWithHttpInfo
     *
     * Update LDAP mapping for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateLdapMappingForUserAsyncWithHttpInfo($username, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\LdapMappingUser';
        $request = $this->enterpriseAdminUpdateLdapMappingForUserRequest($username, $enterprise_admin_update_ldap_mapping_for_team_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateLdapMappingForUser'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateLdapMappingForTeamRequest $enterprise_admin_update_ldap_mapping_for_team_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateLdapMappingForUserRequest($username, $enterprise_admin_update_ldap_mapping_for_team_request, string $contentType = self::contentTypes['enterpriseAdminUpdateLdapMappingForUser'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminUpdateLdapMappingForUser'
            );
        }

        // verify the required parameter 'enterprise_admin_update_ldap_mapping_for_team_request' is set
        if ($enterprise_admin_update_ldap_mapping_for_team_request === null || (is_array($enterprise_admin_update_ldap_mapping_for_team_request) && count($enterprise_admin_update_ldap_mapping_for_team_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_update_ldap_mapping_for_team_request when calling enterpriseAdminUpdateLdapMappingForUser'
            );
        }


        $resourcePath = '/admin/ldap/users/{username}/mapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_ldap_mapping_for_team_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_ldap_mapping_for_team_request));
            } else {
                $httpBody = $enterprise_admin_update_ldap_mapping_for_team_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateOrgName
     *
     * Update an organization name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgNameRequest $enterprise_admin_update_org_name_request enterprise_admin_update_org_name_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateOrgName'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response
     */
    public function enterpriseAdminUpdateOrgName($org, $enterprise_admin_update_org_name_request, string $contentType = self::contentTypes['enterpriseAdminUpdateOrgName'][0])
    {
        list($response) = $this->enterpriseAdminUpdateOrgNameWithHttpInfo($org, $enterprise_admin_update_org_name_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateOrgNameWithHttpInfo
     *
     * Update an organization name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgNameRequest $enterprise_admin_update_org_name_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateOrgName'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateOrgNameWithHttpInfo($org, $enterprise_admin_update_org_name_request, string $contentType = self::contentTypes['enterpriseAdminUpdateOrgName'][0])
    {
        $request = $this->enterpriseAdminUpdateOrgNameRequest($org, $enterprise_admin_update_org_name_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateOrgNameAsync
     *
     * Update an organization name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgNameRequest $enterprise_admin_update_org_name_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateOrgName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateOrgNameAsync($org, $enterprise_admin_update_org_name_request, string $contentType = self::contentTypes['enterpriseAdminUpdateOrgName'][0])
    {
        return $this->enterpriseAdminUpdateOrgNameAsyncWithHttpInfo($org, $enterprise_admin_update_org_name_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateOrgNameAsyncWithHttpInfo
     *
     * Update an organization name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgNameRequest $enterprise_admin_update_org_name_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateOrgName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateOrgNameAsyncWithHttpInfo($org, $enterprise_admin_update_org_name_request, string $contentType = self::contentTypes['enterpriseAdminUpdateOrgName'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response';
        $request = $this->enterpriseAdminUpdateOrgNameRequest($org, $enterprise_admin_update_org_name_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateOrgName'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgNameRequest $enterprise_admin_update_org_name_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateOrgName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateOrgNameRequest($org, $enterprise_admin_update_org_name_request, string $contentType = self::contentTypes['enterpriseAdminUpdateOrgName'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling enterpriseAdminUpdateOrgName'
            );
        }

        // verify the required parameter 'enterprise_admin_update_org_name_request' is set
        if ($enterprise_admin_update_org_name_request === null || (is_array($enterprise_admin_update_org_name_request) && count($enterprise_admin_update_org_name_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_update_org_name_request when calling enterpriseAdminUpdateOrgName'
            );
        }


        $resourcePath = '/admin/organizations/{org}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_org_name_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_org_name_request));
            } else {
                $httpBody = $enterprise_admin_update_org_name_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveEnvironment
     *
     * Update a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveEnvironmentRequest $enterprise_admin_update_pre_receive_environment_request enterprise_admin_update_pre_receive_environment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response
     */
    public function enterpriseAdminUpdatePreReceiveEnvironment($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'][0])
    {
        list($response) = $this->enterpriseAdminUpdatePreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveEnvironmentWithHttpInfo
     *
     * Update a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveEnvironmentRequest $enterprise_admin_update_pre_receive_environment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdatePreReceiveEnvironmentWithHttpInfo($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'][0])
    {
        $request = $this->enterpriseAdminUpdatePreReceiveEnvironmentRequest($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminDeletePreReceiveEnvironment422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveEnvironmentAsync
     *
     * Update a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveEnvironmentRequest $enterprise_admin_update_pre_receive_environment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveEnvironmentAsync($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'][0])
    {
        return $this->enterpriseAdminUpdatePreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveEnvironmentAsyncWithHttpInfo
     *
     * Update a pre-receive environment
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveEnvironmentRequest $enterprise_admin_update_pre_receive_environment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveEnvironmentAsyncWithHttpInfo($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveEnvironment';
        $request = $this->enterpriseAdminUpdatePreReceiveEnvironmentRequest($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdatePreReceiveEnvironment'
     *
     * @param  int $pre_receive_environment_id The unique identifier of the pre-receive environment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveEnvironmentRequest $enterprise_admin_update_pre_receive_environment_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdatePreReceiveEnvironmentRequest($pre_receive_environment_id, $enterprise_admin_update_pre_receive_environment_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveEnvironment'][0])
    {

        // verify the required parameter 'pre_receive_environment_id' is set
        if ($pre_receive_environment_id === null || (is_array($pre_receive_environment_id) && count($pre_receive_environment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_environment_id when calling enterpriseAdminUpdatePreReceiveEnvironment'
            );
        }



        $resourcePath = '/admin/pre-receive-environments/{pre_receive_environment_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_environment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_environment_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_environment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_pre_receive_environment_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_pre_receive_environment_request));
            } else {
                $httpBody = $enterprise_admin_update_pre_receive_environment_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHook
     *
     * Update a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookRequest $enterprise_admin_update_pre_receive_hook_request enterprise_admin_update_pre_receive_hook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook
     */
    public function enterpriseAdminUpdatePreReceiveHook($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHook'][0])
    {
        list($response) = $this->enterpriseAdminUpdatePreReceiveHookWithHttpInfo($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookWithHttpInfo
     *
     * Update a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookRequest $enterprise_admin_update_pre_receive_hook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdatePreReceiveHookWithHttpInfo($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHook'][0])
    {
        $request = $this->enterpriseAdminUpdatePreReceiveHookRequest($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookAsync
     *
     * Update a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookRequest $enterprise_admin_update_pre_receive_hook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveHookAsync($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHook'][0])
    {
        return $this->enterpriseAdminUpdatePreReceiveHookAsyncWithHttpInfo($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookAsyncWithHttpInfo
     *
     * Update a pre-receive hook
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookRequest $enterprise_admin_update_pre_receive_hook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveHookAsyncWithHttpInfo($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHook'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\PreReceiveHook';
        $request = $this->enterpriseAdminUpdatePreReceiveHookRequest($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdatePreReceiveHook'
     *
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookRequest $enterprise_admin_update_pre_receive_hook_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdatePreReceiveHookRequest($pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHook'][0])
    {

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminUpdatePreReceiveHook'
            );
        }



        $resourcePath = '/admin/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_pre_receive_hook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_pre_receive_hook_request));
            } else {
                $httpBody = $enterprise_admin_update_pre_receive_hook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForOrg
     *
     * Update pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request enterprise_admin_update_pre_receive_hook_enforcement_for_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForOrg($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'][0])
    {
        list($response) = $this->enterpriseAdminUpdatePreReceiveHookEnforcementForOrgWithHttpInfo($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForOrgWithHttpInfo
     *
     * Update pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForOrgWithHttpInfo($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'][0])
    {
        $request = $this->enterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForOrgAsync
     *
     * Update pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForOrgAsync($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'][0])
    {
        return $this->enterpriseAdminUpdatePreReceiveHookEnforcementForOrgAsyncWithHttpInfo($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForOrgAsyncWithHttpInfo
     *
     * Update pre-receive hook enforcement for an organization
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForOrgAsyncWithHttpInfo($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgPreReceiveHook';
        $request = $this->enterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForOrgRequest($org, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'
            );
        }

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminUpdatePreReceiveHookEnforcementForOrg'
            );
        }



        $resourcePath = '/orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_pre_receive_hook_enforcement_for_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_pre_receive_hook_enforcement_for_org_request));
            } else {
                $httpBody = $enterprise_admin_update_pre_receive_hook_enforcement_for_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForRepo
     *
     * Update pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForRepo($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'][0])
    {
        list($response) = $this->enterpriseAdminUpdatePreReceiveHookEnforcementForRepoWithHttpInfo($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForRepoWithHttpInfo
     *
     * Update pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForRepoWithHttpInfo($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'][0])
    {
        $request = $this->enterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForRepoAsync
     *
     * Update pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForRepoAsync($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'][0])
    {
        return $this->enterpriseAdminUpdatePreReceiveHookEnforcementForRepoAsyncWithHttpInfo($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdatePreReceiveHookEnforcementForRepoAsyncWithHttpInfo
     *
     * Update pre-receive hook enforcement for a repository
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForRepoAsyncWithHttpInfo($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RepositoryPreReceiveHook';
        $request = $this->enterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'
     *
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  int $pre_receive_hook_id The unique identifier of the pre-receive hook. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdatePreReceiveHookEnforcementForRepoRequest($owner, $repo, $pre_receive_hook_id, $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'][0])
    {

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'
            );
        }

        // verify the required parameter 'pre_receive_hook_id' is set
        if ($pre_receive_hook_id === null || (is_array($pre_receive_hook_id) && count($pre_receive_hook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pre_receive_hook_id when calling enterpriseAdminUpdatePreReceiveHookEnforcementForRepo'
            );
        }



        $resourcePath = '/repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }
        // path params
        if ($pre_receive_hook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pre_receive_hook_id' . '}',
                ObjectSerializer::toPathValue($pre_receive_hook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request));
            } else {
                $httpBody = $enterprise_admin_update_pre_receive_hook_enforcement_for_repo_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise
     *
     * Update a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request enterprise_admin_update_self_hosted_runner_group_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise
     */
    public function enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'][0])
    {
        list($response) = $this->enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseWithHttpInfo
     *
     * Update a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'][0])
    {
        $request = $this->enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseAsync
     *
     * Update a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseAsync($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'][0])
    {
        return $this->enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo
     *
     * Update a self-hosted runner group for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseAsyncWithHttpInfo($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\RunnerGroupsEnterprise';
        $request = $this->enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  int $runner_group_id Unique identifier of the self-hosted runner group. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest($enterprise, $runner_group_id, $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request = null, string $contentType = self::contentTypes['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'
            );
        }

        // verify the required parameter 'runner_group_id' is set
        if ($runner_group_id === null || (is_array($runner_group_id) && count($runner_group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $runner_group_id when calling enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'
            );
        }



        $resourcePath = '/enterprises/{enterprise}/actions/runner-groups/{runner_group_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($runner_group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'runner_group_id' . '}',
                ObjectSerializer::toPathValue($runner_group_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_self_hosted_runner_group_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_self_hosted_runner_group_for_enterprise_request));
            } else {
                $httpBody = $enterprise_admin_update_self_hosted_runner_group_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpdateUsernameForUser
     *
     * Update the username for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateUsernameForUserRequest $enterprise_admin_update_username_for_user_request enterprise_admin_update_username_for_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateUsernameForUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response
     */
    public function enterpriseAdminUpdateUsernameForUser($username, $enterprise_admin_update_username_for_user_request, string $contentType = self::contentTypes['enterpriseAdminUpdateUsernameForUser'][0])
    {
        list($response) = $this->enterpriseAdminUpdateUsernameForUserWithHttpInfo($username, $enterprise_admin_update_username_for_user_request, $contentType);
        return $response;
    }

    /**
     * Operation enterpriseAdminUpdateUsernameForUserWithHttpInfo
     *
     * Update the username for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateUsernameForUserRequest $enterprise_admin_update_username_for_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateUsernameForUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpdateUsernameForUserWithHttpInfo($username, $enterprise_admin_update_username_for_user_request, string $contentType = self::contentTypes['enterpriseAdminUpdateUsernameForUser'][0])
    {
        $request = $this->enterpriseAdminUpdateUsernameForUserRequest($username, $enterprise_admin_update_username_for_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpdateUsernameForUserAsync
     *
     * Update the username for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateUsernameForUserRequest $enterprise_admin_update_username_for_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateUsernameForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateUsernameForUserAsync($username, $enterprise_admin_update_username_for_user_request, string $contentType = self::contentTypes['enterpriseAdminUpdateUsernameForUser'][0])
    {
        return $this->enterpriseAdminUpdateUsernameForUserAsyncWithHttpInfo($username, $enterprise_admin_update_username_for_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpdateUsernameForUserAsyncWithHttpInfo
     *
     * Update the username for a user
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateUsernameForUserRequest $enterprise_admin_update_username_for_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateUsernameForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpdateUsernameForUserAsyncWithHttpInfo($username, $enterprise_admin_update_username_for_user_request, string $contentType = self::contentTypes['enterpriseAdminUpdateUsernameForUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateOrgName202Response';
        $request = $this->enterpriseAdminUpdateUsernameForUserRequest($username, $enterprise_admin_update_username_for_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpdateUsernameForUser'
     *
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseAdminUpdateUsernameForUserRequest $enterprise_admin_update_username_for_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpdateUsernameForUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpdateUsernameForUserRequest($username, $enterprise_admin_update_username_for_user_request, string $contentType = self::contentTypes['enterpriseAdminUpdateUsernameForUser'][0])
    {

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling enterpriseAdminUpdateUsernameForUser'
            );
        }

        // verify the required parameter 'enterprise_admin_update_username_for_user_request' is set
        if ($enterprise_admin_update_username_for_user_request === null || (is_array($enterprise_admin_update_username_for_user_request) && count($enterprise_admin_update_username_for_user_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise_admin_update_username_for_user_request when calling enterpriseAdminUpdateUsernameForUser'
            );
        }


        $resourcePath = '/admin/users/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($enterprise_admin_update_username_for_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($enterprise_admin_update_username_for_user_request));
            } else {
                $httpBody = $enterprise_admin_update_username_for_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enterpriseAdminUpgradeLicense
     *
     * Upgrade a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your new _.ghl_ license file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpgradeLicense'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function enterpriseAdminUpgradeLicense($license = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminUpgradeLicense'][0])
    {
        $this->enterpriseAdminUpgradeLicenseWithHttpInfo($license, $hostIndex, $variables, $contentType);
    }

    /**
     * Operation enterpriseAdminUpgradeLicenseWithHttpInfo
     *
     * Upgrade a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your new _.ghl_ license file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpgradeLicense'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function enterpriseAdminUpgradeLicenseWithHttpInfo($license = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminUpgradeLicense'][0])
    {
        $request = $this->enterpriseAdminUpgradeLicenseRequest($license, $hostIndex, $variables, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation enterpriseAdminUpgradeLicenseAsync
     *
     * Upgrade a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your new _.ghl_ license file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpgradeLicense'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpgradeLicenseAsync($license = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminUpgradeLicense'][0])
    {
        return $this->enterpriseAdminUpgradeLicenseAsyncWithHttpInfo($license, $hostIndex, $variables, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enterpriseAdminUpgradeLicenseAsyncWithHttpInfo
     *
     * Upgrade a license
     *
     * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
     * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
     *    - hostname: Self-hosted Enterprise Server hostname
     *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your new _.ghl_ license file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpgradeLicense'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enterpriseAdminUpgradeLicenseAsyncWithHttpInfo($license = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminUpgradeLicense'][0])
    {
        $returnType = '';
        $request = $this->enterpriseAdminUpgradeLicenseRequest($license, $hostIndex, $variables, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enterpriseAdminUpgradeLicense'
     *
    * This operation contains host(s) defined in the OpenAPI spec. Use 'hostIndex' to select the host.
    * if needed, use the 'variables' parameter to pass variables to the host.
     * URL: {protocol}://{hostname}
     *  Variables:
    *    - hostname: Self-hosted Enterprise Server hostname
    *    - protocol: Self-hosted Enterprise Server protocol
     *
     * @param  string $license The content of your new _.ghl_ license file. (optional)
     * @param  null|int $hostIndex Host index. Defaults to null. If null, then the library will use $this->hostIndex instead
     * @param  array $variables Associative array of variables to pass to the host. Defaults to empty array.
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enterpriseAdminUpgradeLicense'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enterpriseAdminUpgradeLicenseRequest($license = null, ?int $hostIndex = null, array $variables = [], string $contentType = self::contentTypes['enterpriseAdminUpgradeLicense'][0])
    {



        $resourcePath = '/setup/api/upgrade';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($license !== null) {
            $formParams['license'] = ObjectSerializer::toFormValue($license);
        }

        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        # Preserve the original behavior of server indexing.
        if ($hostIndex === null) {
            $hostIndex = $this->hostIndex;
        }

        $hostSettings = $this->getHostSettingsForenterpriseAdminUpgradeLicense();

        if ($hostIndex < 0 || $hostIndex >= count($hostSettings)) {
            throw new \InvalidArgumentException("Invalid index {$hostIndex} when selecting the host. Must be less than ".count($hostSettings));
        }
        $operationHost = Configuration::getHostString($hostSettings, $hostIndex, $variables);
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Returns an array of host settings for Operation enterpriseAdminUpgradeLicense
     *
     * @return array an array of host settings
     */
    protected function getHostSettingsForenterpriseAdminUpgradeLicense(): array
    {
        return [
            [
                "url" => "{protocol}://{hostname}",
                "description" => "No description provided",
                "variables" => [
                    "hostname" => [
                    "description" => "Self-hosted Enterprise Server hostname",
                    "default_value" => "HOSTNAME",
                    ],
                    "protocol" => [
                    "description" => "Self-hosted Enterprise Server protocol",
                    "default_value" => "http",
                    ]
                ]
            ]
        ];
    }

    /**
     * Operation secretScanningGetSecurityAnalysisSettingsForEnterprise
     *
     * Get code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function secretScanningGetSecurityAnalysisSettingsForEnterprise($enterprise, string $contentType = self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'][0])
    {
        list($response) = $this->secretScanningGetSecurityAnalysisSettingsForEnterpriseWithHttpInfo($enterprise, $contentType);
        return $response;
    }

    /**
     * Operation secretScanningGetSecurityAnalysisSettingsForEnterpriseWithHttpInfo
     *
     * Get code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function secretScanningGetSecurityAnalysisSettingsForEnterpriseWithHttpInfo($enterprise, string $contentType = self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'][0])
    {
        $request = $this->secretScanningGetSecurityAnalysisSettingsForEnterpriseRequest($enterprise, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation secretScanningGetSecurityAnalysisSettingsForEnterpriseAsync
     *
     * Get code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function secretScanningGetSecurityAnalysisSettingsForEnterpriseAsync($enterprise, string $contentType = self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'][0])
    {
        return $this->secretScanningGetSecurityAnalysisSettingsForEnterpriseAsyncWithHttpInfo($enterprise, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation secretScanningGetSecurityAnalysisSettingsForEnterpriseAsyncWithHttpInfo
     *
     * Get code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function secretScanningGetSecurityAnalysisSettingsForEnterpriseAsyncWithHttpInfo($enterprise, string $contentType = self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\EnterpriseSecurityAnalysisSettings';
        $request = $this->secretScanningGetSecurityAnalysisSettingsForEnterpriseRequest($enterprise, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'secretScanningGetSecurityAnalysisSettingsForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function secretScanningGetSecurityAnalysisSettingsForEnterpriseRequest($enterprise, string $contentType = self::contentTypes['secretScanningGetSecurityAnalysisSettingsForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling secretScanningGetSecurityAnalysisSettingsForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/code_security_and_analysis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation secretScanningPatchSecurityAnalysisSettingsForEnterprise
     *
     * Update code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SecretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest $secret_scanning_patch_security_analysis_settings_for_enterprise_request secret_scanning_patch_security_analysis_settings_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function secretScanningPatchSecurityAnalysisSettingsForEnterprise($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request = null, string $contentType = self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'][0])
    {
        $this->secretScanningPatchSecurityAnalysisSettingsForEnterpriseWithHttpInfo($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request, $contentType);
    }

    /**
     * Operation secretScanningPatchSecurityAnalysisSettingsForEnterpriseWithHttpInfo
     *
     * Update code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SecretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest $secret_scanning_patch_security_analysis_settings_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function secretScanningPatchSecurityAnalysisSettingsForEnterpriseWithHttpInfo($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request = null, string $contentType = self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'][0])
    {
        $request = $this->secretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation secretScanningPatchSecurityAnalysisSettingsForEnterpriseAsync
     *
     * Update code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SecretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest $secret_scanning_patch_security_analysis_settings_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function secretScanningPatchSecurityAnalysisSettingsForEnterpriseAsync($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request = null, string $contentType = self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'][0])
    {
        return $this->secretScanningPatchSecurityAnalysisSettingsForEnterpriseAsyncWithHttpInfo($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation secretScanningPatchSecurityAnalysisSettingsForEnterpriseAsyncWithHttpInfo
     *
     * Update code security and analysis features for an enterprise
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SecretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest $secret_scanning_patch_security_analysis_settings_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function secretScanningPatchSecurityAnalysisSettingsForEnterpriseAsyncWithHttpInfo($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request = null, string $contentType = self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'][0])
    {
        $returnType = '';
        $request = $this->secretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'secretScanningPatchSecurityAnalysisSettingsForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SecretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest $secret_scanning_patch_security_analysis_settings_for_enterprise_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function secretScanningPatchSecurityAnalysisSettingsForEnterpriseRequest($enterprise, $secret_scanning_patch_security_analysis_settings_for_enterprise_request = null, string $contentType = self::contentTypes['secretScanningPatchSecurityAnalysisSettingsForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling secretScanningPatchSecurityAnalysisSettingsForEnterprise'
            );
        }



        $resourcePath = '/enterprises/{enterprise}/code_security_and_analysis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($secret_scanning_patch_security_analysis_settings_for_enterprise_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($secret_scanning_patch_security_analysis_settings_for_enterprise_request));
            } else {
                $httpBody = $secret_scanning_patch_security_analysis_settings_for_enterprise_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation secretScanningPostSecurityProductEnablementForEnterprise
     *
     * Enable or disable a security feature
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $security_product The security feature to enable or disable. (required)
     * @param  string $enablement The action to take.  &#x60;enable_all&#x60; means to enable the specified security feature for all repositories in the enterprise. &#x60;disable_all&#x60; means to disable the specified security feature for all repositories in the enterprise. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function secretScanningPostSecurityProductEnablementForEnterprise($enterprise, $security_product, $enablement, string $contentType = self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'][0])
    {
        $this->secretScanningPostSecurityProductEnablementForEnterpriseWithHttpInfo($enterprise, $security_product, $enablement, $contentType);
    }

    /**
     * Operation secretScanningPostSecurityProductEnablementForEnterpriseWithHttpInfo
     *
     * Enable or disable a security feature
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $security_product The security feature to enable or disable. (required)
     * @param  string $enablement The action to take.  &#x60;enable_all&#x60; means to enable the specified security feature for all repositories in the enterprise. &#x60;disable_all&#x60; means to disable the specified security feature for all repositories in the enterprise. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function secretScanningPostSecurityProductEnablementForEnterpriseWithHttpInfo($enterprise, $security_product, $enablement, string $contentType = self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'][0])
    {
        $request = $this->secretScanningPostSecurityProductEnablementForEnterpriseRequest($enterprise, $security_product, $enablement, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation secretScanningPostSecurityProductEnablementForEnterpriseAsync
     *
     * Enable or disable a security feature
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $security_product The security feature to enable or disable. (required)
     * @param  string $enablement The action to take.  &#x60;enable_all&#x60; means to enable the specified security feature for all repositories in the enterprise. &#x60;disable_all&#x60; means to disable the specified security feature for all repositories in the enterprise. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function secretScanningPostSecurityProductEnablementForEnterpriseAsync($enterprise, $security_product, $enablement, string $contentType = self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'][0])
    {
        return $this->secretScanningPostSecurityProductEnablementForEnterpriseAsyncWithHttpInfo($enterprise, $security_product, $enablement, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation secretScanningPostSecurityProductEnablementForEnterpriseAsyncWithHttpInfo
     *
     * Enable or disable a security feature
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $security_product The security feature to enable or disable. (required)
     * @param  string $enablement The action to take.  &#x60;enable_all&#x60; means to enable the specified security feature for all repositories in the enterprise. &#x60;disable_all&#x60; means to disable the specified security feature for all repositories in the enterprise. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function secretScanningPostSecurityProductEnablementForEnterpriseAsyncWithHttpInfo($enterprise, $security_product, $enablement, string $contentType = self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'][0])
    {
        $returnType = '';
        $request = $this->secretScanningPostSecurityProductEnablementForEnterpriseRequest($enterprise, $security_product, $enablement, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'secretScanningPostSecurityProductEnablementForEnterprise'
     *
     * @param  string $enterprise The slug version of the enterprise name. You can also substitute this value with the enterprise id. (required)
     * @param  string $security_product The security feature to enable or disable. (required)
     * @param  string $enablement The action to take.  &#x60;enable_all&#x60; means to enable the specified security feature for all repositories in the enterprise. &#x60;disable_all&#x60; means to disable the specified security feature for all repositories in the enterprise. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function secretScanningPostSecurityProductEnablementForEnterpriseRequest($enterprise, $security_product, $enablement, string $contentType = self::contentTypes['secretScanningPostSecurityProductEnablementForEnterprise'][0])
    {

        // verify the required parameter 'enterprise' is set
        if ($enterprise === null || (is_array($enterprise) && count($enterprise) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enterprise when calling secretScanningPostSecurityProductEnablementForEnterprise'
            );
        }

        // verify the required parameter 'security_product' is set
        if ($security_product === null || (is_array($security_product) && count($security_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $security_product when calling secretScanningPostSecurityProductEnablementForEnterprise'
            );
        }

        // verify the required parameter 'enablement' is set
        if ($enablement === null || (is_array($enablement) && count($enablement) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enablement when calling secretScanningPostSecurityProductEnablementForEnterprise'
            );
        }


        $resourcePath = '/enterprises/{enterprise}/{security_product}/{enablement}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enterprise !== null) {
            $resourcePath = str_replace(
                '{' . 'enterprise' . '}',
                ObjectSerializer::toPathValue($enterprise),
                $resourcePath
            );
        }
        // path params
        if ($security_product !== null) {
            $resourcePath = str_replace(
                '{' . 'security_product' . '}',
                ObjectSerializer::toPathValue($security_product),
                $resourcePath
            );
        }
        // path params
        if ($enablement !== null) {
            $resourcePath = str_replace(
                '{' . 'enablement' . '}',
                ObjectSerializer::toPathValue($enablement),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
