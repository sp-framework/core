<?php
/**
 * TeamsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Configuration;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\HeaderSelector;
use System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ObjectSerializer;

/**
 * TeamsApi Class Doc Comment
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TeamsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'teamsAddMemberLegacy' => [
            'application/json',
        ],
        'teamsAddOrUpdateMembershipForUserInOrg' => [
            'application/json',
        ],
        'teamsAddOrUpdateMembershipForUserLegacy' => [
            'application/json',
        ],
        'teamsAddOrUpdateProjectPermissionsInOrg' => [
            'application/json',
        ],
        'teamsAddOrUpdateProjectPermissionsLegacy' => [
            'application/json',
        ],
        'teamsAddOrUpdateRepoPermissionsInOrg' => [
            'application/json',
        ],
        'teamsAddOrUpdateRepoPermissionsLegacy' => [
            'application/json',
        ],
        'teamsCheckPermissionsForProjectInOrg' => [
            'application/json',
        ],
        'teamsCheckPermissionsForProjectLegacy' => [
            'application/json',
        ],
        'teamsCheckPermissionsForRepoInOrg' => [
            'application/json',
        ],
        'teamsCheckPermissionsForRepoLegacy' => [
            'application/json',
        ],
        'teamsCreate' => [
            'application/json',
        ],
        'teamsCreateDiscussionCommentInOrg' => [
            'application/json',
        ],
        'teamsCreateDiscussionCommentLegacy' => [
            'application/json',
        ],
        'teamsCreateDiscussionInOrg' => [
            'application/json',
        ],
        'teamsCreateDiscussionLegacy' => [
            'application/json',
        ],
        'teamsDeleteDiscussionCommentInOrg' => [
            'application/json',
        ],
        'teamsDeleteDiscussionCommentLegacy' => [
            'application/json',
        ],
        'teamsDeleteDiscussionInOrg' => [
            'application/json',
        ],
        'teamsDeleteDiscussionLegacy' => [
            'application/json',
        ],
        'teamsDeleteInOrg' => [
            'application/json',
        ],
        'teamsDeleteLegacy' => [
            'application/json',
        ],
        'teamsGetByName' => [
            'application/json',
        ],
        'teamsGetDiscussionCommentInOrg' => [
            'application/json',
        ],
        'teamsGetDiscussionCommentLegacy' => [
            'application/json',
        ],
        'teamsGetDiscussionInOrg' => [
            'application/json',
        ],
        'teamsGetDiscussionLegacy' => [
            'application/json',
        ],
        'teamsGetLegacy' => [
            'application/json',
        ],
        'teamsGetMemberLegacy' => [
            'application/json',
        ],
        'teamsGetMembershipForUserInOrg' => [
            'application/json',
        ],
        'teamsGetMembershipForUserLegacy' => [
            'application/json',
        ],
        'teamsList' => [
            'application/json',
        ],
        'teamsListChildInOrg' => [
            'application/json',
        ],
        'teamsListChildLegacy' => [
            'application/json',
        ],
        'teamsListDiscussionCommentsInOrg' => [
            'application/json',
        ],
        'teamsListDiscussionCommentsLegacy' => [
            'application/json',
        ],
        'teamsListDiscussionsInOrg' => [
            'application/json',
        ],
        'teamsListDiscussionsLegacy' => [
            'application/json',
        ],
        'teamsListForAuthenticatedUser' => [
            'application/json',
        ],
        'teamsListMembersInOrg' => [
            'application/json',
        ],
        'teamsListMembersLegacy' => [
            'application/json',
        ],
        'teamsListPendingInvitationsInOrg' => [
            'application/json',
        ],
        'teamsListPendingInvitationsLegacy' => [
            'application/json',
        ],
        'teamsListProjectsInOrg' => [
            'application/json',
        ],
        'teamsListProjectsLegacy' => [
            'application/json',
        ],
        'teamsListReposInOrg' => [
            'application/json',
        ],
        'teamsListReposLegacy' => [
            'application/json',
        ],
        'teamsRemoveMemberLegacy' => [
            'application/json',
        ],
        'teamsRemoveMembershipForUserInOrg' => [
            'application/json',
        ],
        'teamsRemoveMembershipForUserLegacy' => [
            'application/json',
        ],
        'teamsRemoveProjectInOrg' => [
            'application/json',
        ],
        'teamsRemoveProjectLegacy' => [
            'application/json',
        ],
        'teamsRemoveRepoInOrg' => [
            'application/json',
        ],
        'teamsRemoveRepoLegacy' => [
            'application/json',
        ],
        'teamsUpdateDiscussionCommentInOrg' => [
            'application/json',
        ],
        'teamsUpdateDiscussionCommentLegacy' => [
            'application/json',
        ],
        'teamsUpdateDiscussionInOrg' => [
            'application/json',
        ],
        'teamsUpdateDiscussionLegacy' => [
            'application/json',
        ],
        'teamsUpdateInOrg' => [
            'application/json',
        ],
        'teamsUpdateLegacy' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation teamsAddMemberLegacy
     *
     * Add team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddMemberLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsAddMemberLegacy($team_id, $username, string $contentType = self::contentTypes['teamsAddMemberLegacy'][0])
    {
        $this->teamsAddMemberLegacyWithHttpInfo($team_id, $username, $contentType);
    }

    /**
     * Operation teamsAddMemberLegacyWithHttpInfo
     *
     * Add team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddMemberLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsAddMemberLegacyWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsAddMemberLegacy'][0])
    {
        $request = $this->teamsAddMemberLegacyRequest($team_id, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddMemberLegacyAsync
     *
     * Add team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddMemberLegacyAsync($team_id, $username, string $contentType = self::contentTypes['teamsAddMemberLegacy'][0])
    {
        return $this->teamsAddMemberLegacyAsyncWithHttpInfo($team_id, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddMemberLegacyAsyncWithHttpInfo
     *
     * Add team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddMemberLegacyAsyncWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsAddMemberLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsAddMemberLegacyRequest($team_id, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddMemberLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsAddMemberLegacyRequest($team_id, $username, string $contentType = self::contentTypes['teamsAddMemberLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsAddMemberLegacy'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsAddMemberLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/members/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserInOrg
     *
     * Add or update team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership
     */
    public function teamsAddOrUpdateMembershipForUserInOrg($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'][0])
    {
        list($response) = $this->teamsAddOrUpdateMembershipForUserInOrgWithHttpInfo($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserInOrgWithHttpInfo
     *
     * Add or update team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsAddOrUpdateMembershipForUserInOrgWithHttpInfo($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'][0])
    {
        $request = $this->teamsAddOrUpdateMembershipForUserInOrgRequest($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserInOrgAsync
     *
     * Add or update team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddOrUpdateMembershipForUserInOrgAsync($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'][0])
    {
        return $this->teamsAddOrUpdateMembershipForUserInOrgAsyncWithHttpInfo($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserInOrgAsyncWithHttpInfo
     *
     * Add or update team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddOrUpdateMembershipForUserInOrgAsyncWithHttpInfo($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
        $request = $this->teamsAddOrUpdateMembershipForUserInOrgRequest($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddOrUpdateMembershipForUserInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsAddOrUpdateMembershipForUserInOrgRequest($org, $team_slug, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsAddOrUpdateMembershipForUserInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsAddOrUpdateMembershipForUserInOrg'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsAddOrUpdateMembershipForUserInOrg'
            );
        }



        $resourcePath = '/orgs/{org}/teams/{team_slug}/memberships/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_add_or_update_membership_for_user_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_add_or_update_membership_for_user_in_org_request));
            } else {
                $httpBody = $teams_add_or_update_membership_for_user_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserLegacy
     *
     * Add or update team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsAddOrUpdateMembershipForUserLegacy($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'][0])
    {
        list($response) = $this->teamsAddOrUpdateMembershipForUserLegacyWithHttpInfo($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserLegacyWithHttpInfo
     *
     * Add or update team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsAddOrUpdateMembershipForUserLegacyWithHttpInfo($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'][0])
    {
        $request = $this->teamsAddOrUpdateMembershipForUserLegacyRequest($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserLegacyAsync
     *
     * Add or update team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddOrUpdateMembershipForUserLegacyAsync($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'][0])
    {
        return $this->teamsAddOrUpdateMembershipForUserLegacyAsyncWithHttpInfo($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddOrUpdateMembershipForUserLegacyAsyncWithHttpInfo
     *
     * Add or update team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddOrUpdateMembershipForUserLegacyAsyncWithHttpInfo($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
        $request = $this->teamsAddOrUpdateMembershipForUserLegacyRequest($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddOrUpdateMembershipForUserLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateMembershipForUserInOrgRequest $teams_add_or_update_membership_for_user_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsAddOrUpdateMembershipForUserLegacyRequest($team_id, $username, $teams_add_or_update_membership_for_user_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateMembershipForUserLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsAddOrUpdateMembershipForUserLegacy'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsAddOrUpdateMembershipForUserLegacy'
            );
        }



        $resourcePath = '/teams/{team_id}/memberships/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_add_or_update_membership_for_user_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_add_or_update_membership_for_user_in_org_request));
            } else {
                $httpBody = $teams_add_or_update_membership_for_user_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsInOrg
     *
     * Add or update team project permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsInOrgRequest $teams_add_or_update_project_permissions_in_org_request teams_add_or_update_project_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsAddOrUpdateProjectPermissionsInOrg($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'][0])
    {
        $this->teamsAddOrUpdateProjectPermissionsInOrgWithHttpInfo($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request, $contentType);
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsInOrgWithHttpInfo
     *
     * Add or update team project permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsInOrgRequest $teams_add_or_update_project_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsAddOrUpdateProjectPermissionsInOrgWithHttpInfo($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'][0])
    {
        $request = $this->teamsAddOrUpdateProjectPermissionsInOrgRequest($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgsRemoveOutsideCollaborator422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsInOrgAsync
     *
     * Add or update team project permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsInOrgRequest $teams_add_or_update_project_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddOrUpdateProjectPermissionsInOrgAsync($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'][0])
    {
        return $this->teamsAddOrUpdateProjectPermissionsInOrgAsyncWithHttpInfo($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsInOrgAsyncWithHttpInfo
     *
     * Add or update team project permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsInOrgRequest $teams_add_or_update_project_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddOrUpdateProjectPermissionsInOrgAsyncWithHttpInfo($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsAddOrUpdateProjectPermissionsInOrgRequest($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddOrUpdateProjectPermissionsInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsInOrgRequest $teams_add_or_update_project_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsAddOrUpdateProjectPermissionsInOrgRequest($org, $team_slug, $project_id, $teams_add_or_update_project_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsAddOrUpdateProjectPermissionsInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsAddOrUpdateProjectPermissionsInOrg'
            );
        }

        // verify the required parameter 'project_id' is set
        if ($project_id === null || (is_array($project_id) && count($project_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_id when calling teamsAddOrUpdateProjectPermissionsInOrg'
            );
        }



        $resourcePath = '/orgs/{org}/teams/{team_slug}/projects/{project_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_id !== null) {
            $resourcePath = str_replace(
                '{' . 'project_id' . '}',
                ObjectSerializer::toPathValue($project_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_add_or_update_project_permissions_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_add_or_update_project_permissions_in_org_request));
            } else {
                $httpBody = $teams_add_or_update_project_permissions_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsLegacy
     *
     * Add or update team project permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsLegacyRequest $teams_add_or_update_project_permissions_legacy_request teams_add_or_update_project_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsAddOrUpdateProjectPermissionsLegacy($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'][0])
    {
        $this->teamsAddOrUpdateProjectPermissionsLegacyWithHttpInfo($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request, $contentType);
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsLegacyWithHttpInfo
     *
     * Add or update team project permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsLegacyRequest $teams_add_or_update_project_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsAddOrUpdateProjectPermissionsLegacyWithHttpInfo($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'][0])
    {
        $request = $this->teamsAddOrUpdateProjectPermissionsLegacyRequest($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrgsRemoveOutsideCollaborator422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsLegacyAsync
     *
     * Add or update team project permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsLegacyRequest $teams_add_or_update_project_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddOrUpdateProjectPermissionsLegacyAsync($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'][0])
    {
        return $this->teamsAddOrUpdateProjectPermissionsLegacyAsyncWithHttpInfo($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddOrUpdateProjectPermissionsLegacyAsyncWithHttpInfo
     *
     * Add or update team project permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsLegacyRequest $teams_add_or_update_project_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddOrUpdateProjectPermissionsLegacyAsyncWithHttpInfo($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsAddOrUpdateProjectPermissionsLegacyRequest($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddOrUpdateProjectPermissionsLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateProjectPermissionsLegacyRequest $teams_add_or_update_project_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsAddOrUpdateProjectPermissionsLegacyRequest($team_id, $project_id, $teams_add_or_update_project_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateProjectPermissionsLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsAddOrUpdateProjectPermissionsLegacy'
            );
        }

        // verify the required parameter 'project_id' is set
        if ($project_id === null || (is_array($project_id) && count($project_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_id when calling teamsAddOrUpdateProjectPermissionsLegacy'
            );
        }



        $resourcePath = '/teams/{team_id}/projects/{project_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($project_id !== null) {
            $resourcePath = str_replace(
                '{' . 'project_id' . '}',
                ObjectSerializer::toPathValue($project_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_add_or_update_project_permissions_legacy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_add_or_update_project_permissions_legacy_request));
            } else {
                $httpBody = $teams_add_or_update_project_permissions_legacy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsInOrg
     *
     * Add or update team repository permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsInOrgRequest $teams_add_or_update_repo_permissions_in_org_request teams_add_or_update_repo_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsAddOrUpdateRepoPermissionsInOrg($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'][0])
    {
        $this->teamsAddOrUpdateRepoPermissionsInOrgWithHttpInfo($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request, $contentType);
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsInOrgWithHttpInfo
     *
     * Add or update team repository permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsInOrgRequest $teams_add_or_update_repo_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsAddOrUpdateRepoPermissionsInOrgWithHttpInfo($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'][0])
    {
        $request = $this->teamsAddOrUpdateRepoPermissionsInOrgRequest($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsInOrgAsync
     *
     * Add or update team repository permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsInOrgRequest $teams_add_or_update_repo_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddOrUpdateRepoPermissionsInOrgAsync($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'][0])
    {
        return $this->teamsAddOrUpdateRepoPermissionsInOrgAsyncWithHttpInfo($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsInOrgAsyncWithHttpInfo
     *
     * Add or update team repository permissions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsInOrgRequest $teams_add_or_update_repo_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsAddOrUpdateRepoPermissionsInOrgAsyncWithHttpInfo($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsAddOrUpdateRepoPermissionsInOrgRequest($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddOrUpdateRepoPermissionsInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsInOrgRequest $teams_add_or_update_repo_permissions_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsAddOrUpdateRepoPermissionsInOrgRequest($org, $team_slug, $owner, $repo, $teams_add_or_update_repo_permissions_in_org_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsAddOrUpdateRepoPermissionsInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsAddOrUpdateRepoPermissionsInOrg'
            );
        }

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling teamsAddOrUpdateRepoPermissionsInOrg'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling teamsAddOrUpdateRepoPermissionsInOrg'
            );
        }



        $resourcePath = '/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_add_or_update_repo_permissions_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_add_or_update_repo_permissions_in_org_request));
            } else {
                $httpBody = $teams_add_or_update_repo_permissions_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsLegacy
     *
     * Add or update team repository permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsLegacyRequest $teams_add_or_update_repo_permissions_legacy_request teams_add_or_update_repo_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsAddOrUpdateRepoPermissionsLegacy($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'][0])
    {
        $this->teamsAddOrUpdateRepoPermissionsLegacyWithHttpInfo($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request, $contentType);
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsLegacyWithHttpInfo
     *
     * Add or update team repository permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsLegacyRequest $teams_add_or_update_repo_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsAddOrUpdateRepoPermissionsLegacyWithHttpInfo($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'][0])
    {
        $request = $this->teamsAddOrUpdateRepoPermissionsLegacyRequest($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsLegacyAsync
     *
     * Add or update team repository permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsLegacyRequest $teams_add_or_update_repo_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddOrUpdateRepoPermissionsLegacyAsync($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'][0])
    {
        return $this->teamsAddOrUpdateRepoPermissionsLegacyAsyncWithHttpInfo($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsAddOrUpdateRepoPermissionsLegacyAsyncWithHttpInfo
     *
     * Add or update team repository permissions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsLegacyRequest $teams_add_or_update_repo_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsAddOrUpdateRepoPermissionsLegacyAsyncWithHttpInfo($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsAddOrUpdateRepoPermissionsLegacyRequest($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsAddOrUpdateRepoPermissionsLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsAddOrUpdateRepoPermissionsLegacyRequest $teams_add_or_update_repo_permissions_legacy_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsAddOrUpdateRepoPermissionsLegacyRequest($team_id, $owner, $repo, $teams_add_or_update_repo_permissions_legacy_request = null, string $contentType = self::contentTypes['teamsAddOrUpdateRepoPermissionsLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsAddOrUpdateRepoPermissionsLegacy'
            );
        }

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling teamsAddOrUpdateRepoPermissionsLegacy'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling teamsAddOrUpdateRepoPermissionsLegacy'
            );
        }



        $resourcePath = '/teams/{team_id}/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_add_or_update_repo_permissions_legacy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_add_or_update_repo_permissions_legacy_request));
            } else {
                $httpBody = $teams_add_or_update_repo_permissions_legacy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCheckPermissionsForProjectInOrg
     *
     * Check team permissions for a project
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject
     */
    public function teamsCheckPermissionsForProjectInOrg($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectInOrg'][0])
    {
        list($response) = $this->teamsCheckPermissionsForProjectInOrgWithHttpInfo($org, $team_slug, $project_id, $contentType);
        return $response;
    }

    /**
     * Operation teamsCheckPermissionsForProjectInOrgWithHttpInfo
     *
     * Check team permissions for a project
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsCheckPermissionsForProjectInOrgWithHttpInfo($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectInOrg'][0])
    {
        $request = $this->teamsCheckPermissionsForProjectInOrgRequest($org, $team_slug, $project_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCheckPermissionsForProjectInOrgAsync
     *
     * Check team permissions for a project
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCheckPermissionsForProjectInOrgAsync($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectInOrg'][0])
    {
        return $this->teamsCheckPermissionsForProjectInOrgAsyncWithHttpInfo($org, $team_slug, $project_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCheckPermissionsForProjectInOrgAsyncWithHttpInfo
     *
     * Check team permissions for a project
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCheckPermissionsForProjectInOrgAsyncWithHttpInfo($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject';
        $request = $this->teamsCheckPermissionsForProjectInOrgRequest($org, $team_slug, $project_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCheckPermissionsForProjectInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsCheckPermissionsForProjectInOrgRequest($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsCheckPermissionsForProjectInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsCheckPermissionsForProjectInOrg'
            );
        }

        // verify the required parameter 'project_id' is set
        if ($project_id === null || (is_array($project_id) && count($project_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_id when calling teamsCheckPermissionsForProjectInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/projects/{project_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_id !== null) {
            $resourcePath = str_replace(
                '{' . 'project_id' . '}',
                ObjectSerializer::toPathValue($project_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCheckPermissionsForProjectLegacy
     *
     * Check team permissions for a project (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject
     * @deprecated
     */
    public function teamsCheckPermissionsForProjectLegacy($team_id, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectLegacy'][0])
    {
        list($response) = $this->teamsCheckPermissionsForProjectLegacyWithHttpInfo($team_id, $project_id, $contentType);
        return $response;
    }

    /**
     * Operation teamsCheckPermissionsForProjectLegacyWithHttpInfo
     *
     * Check team permissions for a project (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsCheckPermissionsForProjectLegacyWithHttpInfo($team_id, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectLegacy'][0])
    {
        $request = $this->teamsCheckPermissionsForProjectLegacyRequest($team_id, $project_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCheckPermissionsForProjectLegacyAsync
     *
     * Check team permissions for a project (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCheckPermissionsForProjectLegacyAsync($team_id, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectLegacy'][0])
    {
        return $this->teamsCheckPermissionsForProjectLegacyAsyncWithHttpInfo($team_id, $project_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCheckPermissionsForProjectLegacyAsyncWithHttpInfo
     *
     * Check team permissions for a project (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCheckPermissionsForProjectLegacyAsyncWithHttpInfo($team_id, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject';
        $request = $this->teamsCheckPermissionsForProjectLegacyRequest($team_id, $project_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCheckPermissionsForProjectLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForProjectLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsCheckPermissionsForProjectLegacyRequest($team_id, $project_id, string $contentType = self::contentTypes['teamsCheckPermissionsForProjectLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsCheckPermissionsForProjectLegacy'
            );
        }

        // verify the required parameter 'project_id' is set
        if ($project_id === null || (is_array($project_id) && count($project_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_id when calling teamsCheckPermissionsForProjectLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/projects/{project_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($project_id !== null) {
            $resourcePath = str_replace(
                '{' . 'project_id' . '}',
                ObjectSerializer::toPathValue($project_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCheckPermissionsForRepoInOrg
     *
     * Check team permissions for a repository
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository
     */
    public function teamsCheckPermissionsForRepoInOrg($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoInOrg'][0])
    {
        list($response) = $this->teamsCheckPermissionsForRepoInOrgWithHttpInfo($org, $team_slug, $owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation teamsCheckPermissionsForRepoInOrgWithHttpInfo
     *
     * Check team permissions for a repository
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsCheckPermissionsForRepoInOrgWithHttpInfo($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoInOrg'][0])
    {
        $request = $this->teamsCheckPermissionsForRepoInOrgRequest($org, $team_slug, $owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCheckPermissionsForRepoInOrgAsync
     *
     * Check team permissions for a repository
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCheckPermissionsForRepoInOrgAsync($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoInOrg'][0])
    {
        return $this->teamsCheckPermissionsForRepoInOrgAsyncWithHttpInfo($org, $team_slug, $owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCheckPermissionsForRepoInOrgAsyncWithHttpInfo
     *
     * Check team permissions for a repository
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCheckPermissionsForRepoInOrgAsyncWithHttpInfo($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository';
        $request = $this->teamsCheckPermissionsForRepoInOrgRequest($org, $team_slug, $owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCheckPermissionsForRepoInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsCheckPermissionsForRepoInOrgRequest($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsCheckPermissionsForRepoInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsCheckPermissionsForRepoInOrg'
            );
        }

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling teamsCheckPermissionsForRepoInOrg'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling teamsCheckPermissionsForRepoInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCheckPermissionsForRepoLegacy
     *
     * Check team permissions for a repository (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository
     * @deprecated
     */
    public function teamsCheckPermissionsForRepoLegacy($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoLegacy'][0])
    {
        list($response) = $this->teamsCheckPermissionsForRepoLegacyWithHttpInfo($team_id, $owner, $repo, $contentType);
        return $response;
    }

    /**
     * Operation teamsCheckPermissionsForRepoLegacyWithHttpInfo
     *
     * Check team permissions for a repository (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsCheckPermissionsForRepoLegacyWithHttpInfo($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoLegacy'][0])
    {
        $request = $this->teamsCheckPermissionsForRepoLegacyRequest($team_id, $owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCheckPermissionsForRepoLegacyAsync
     *
     * Check team permissions for a repository (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCheckPermissionsForRepoLegacyAsync($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoLegacy'][0])
    {
        return $this->teamsCheckPermissionsForRepoLegacyAsyncWithHttpInfo($team_id, $owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCheckPermissionsForRepoLegacyAsyncWithHttpInfo
     *
     * Check team permissions for a repository (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCheckPermissionsForRepoLegacyAsyncWithHttpInfo($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamRepository';
        $request = $this->teamsCheckPermissionsForRepoLegacyRequest($team_id, $owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCheckPermissionsForRepoLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCheckPermissionsForRepoLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsCheckPermissionsForRepoLegacyRequest($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsCheckPermissionsForRepoLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsCheckPermissionsForRepoLegacy'
            );
        }

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling teamsCheckPermissionsForRepoLegacy'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling teamsCheckPermissionsForRepoLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCreate
     *
     * Create a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateRequest $teams_create_request teams_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreate'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function teamsCreate($org, $teams_create_request, string $contentType = self::contentTypes['teamsCreate'][0])
    {
        list($response) = $this->teamsCreateWithHttpInfo($org, $teams_create_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsCreateWithHttpInfo
     *
     * Create a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateRequest $teams_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreate'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsCreateWithHttpInfo($org, $teams_create_request, string $contentType = self::contentTypes['teamsCreate'][0])
    {
        $request = $this->teamsCreateRequest($org, $teams_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCreateAsync
     *
     * Create a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateRequest $teams_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateAsync($org, $teams_create_request, string $contentType = self::contentTypes['teamsCreate'][0])
    {
        return $this->teamsCreateAsyncWithHttpInfo($org, $teams_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCreateAsyncWithHttpInfo
     *
     * Create a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateRequest $teams_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateAsyncWithHttpInfo($org, $teams_create_request, string $contentType = self::contentTypes['teamsCreate'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
        $request = $this->teamsCreateRequest($org, $teams_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCreate'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateRequest $teams_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsCreateRequest($org, $teams_create_request, string $contentType = self::contentTypes['teamsCreate'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsCreate'
            );
        }

        // verify the required parameter 'teams_create_request' is set
        if ($teams_create_request === null || (is_array($teams_create_request) && count($teams_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_request when calling teamsCreate'
            );
        }


        $resourcePath = '/orgs/{org}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_request));
            } else {
                $httpBody = $teams_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCreateDiscussionCommentInOrg
     *
     * Create a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment
     */
    public function teamsCreateDiscussionCommentInOrg($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentInOrg'][0])
    {
        list($response) = $this->teamsCreateDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsCreateDiscussionCommentInOrgWithHttpInfo
     *
     * Create a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsCreateDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentInOrg'][0])
    {
        $request = $this->teamsCreateDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCreateDiscussionCommentInOrgAsync
     *
     * Create a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateDiscussionCommentInOrgAsync($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentInOrg'][0])
    {
        return $this->teamsCreateDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCreateDiscussionCommentInOrgAsyncWithHttpInfo
     *
     * Create a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
        $request = $this->teamsCreateDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCreateDiscussionCommentInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsCreateDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsCreateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsCreateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsCreateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'teams_create_discussion_comment_in_org_request' is set
        if ($teams_create_discussion_comment_in_org_request === null || (is_array($teams_create_discussion_comment_in_org_request) && count($teams_create_discussion_comment_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_discussion_comment_in_org_request when calling teamsCreateDiscussionCommentInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_discussion_comment_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_discussion_comment_in_org_request));
            } else {
                $httpBody = $teams_create_discussion_comment_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCreateDiscussionCommentLegacy
     *
     * Create a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment
     * @deprecated
     */
    public function teamsCreateDiscussionCommentLegacy($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentLegacy'][0])
    {
        list($response) = $this->teamsCreateDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsCreateDiscussionCommentLegacyWithHttpInfo
     *
     * Create a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsCreateDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentLegacy'][0])
    {
        $request = $this->teamsCreateDiscussionCommentLegacyRequest($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCreateDiscussionCommentLegacyAsync
     *
     * Create a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCreateDiscussionCommentLegacyAsync($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentLegacy'][0])
    {
        return $this->teamsCreateDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCreateDiscussionCommentLegacyAsyncWithHttpInfo
     *
     * Create a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCreateDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
        $request = $this->teamsCreateDiscussionCommentLegacyRequest($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCreateDiscussionCommentLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsCreateDiscussionCommentLegacyRequest($team_id, $discussion_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionCommentLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsCreateDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsCreateDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'teams_create_discussion_comment_in_org_request' is set
        if ($teams_create_discussion_comment_in_org_request === null || (is_array($teams_create_discussion_comment_in_org_request) && count($teams_create_discussion_comment_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_discussion_comment_in_org_request when calling teamsCreateDiscussionCommentLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_discussion_comment_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_discussion_comment_in_org_request));
            } else {
                $httpBody = $teams_create_discussion_comment_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCreateDiscussionInOrg
     *
     * Create a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion
     */
    public function teamsCreateDiscussionInOrg($org, $team_slug, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionInOrg'][0])
    {
        list($response) = $this->teamsCreateDiscussionInOrgWithHttpInfo($org, $team_slug, $teams_create_discussion_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsCreateDiscussionInOrgWithHttpInfo
     *
     * Create a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsCreateDiscussionInOrgWithHttpInfo($org, $team_slug, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionInOrg'][0])
    {
        $request = $this->teamsCreateDiscussionInOrgRequest($org, $team_slug, $teams_create_discussion_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCreateDiscussionInOrgAsync
     *
     * Create a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateDiscussionInOrgAsync($org, $team_slug, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionInOrg'][0])
    {
        return $this->teamsCreateDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $teams_create_discussion_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCreateDiscussionInOrgAsyncWithHttpInfo
     *
     * Create a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsCreateDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
        $request = $this->teamsCreateDiscussionInOrgRequest($org, $team_slug, $teams_create_discussion_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCreateDiscussionInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsCreateDiscussionInOrgRequest($org, $team_slug, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsCreateDiscussionInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsCreateDiscussionInOrg'
            );
        }

        // verify the required parameter 'teams_create_discussion_in_org_request' is set
        if ($teams_create_discussion_in_org_request === null || (is_array($teams_create_discussion_in_org_request) && count($teams_create_discussion_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_discussion_in_org_request when calling teamsCreateDiscussionInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_discussion_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_discussion_in_org_request));
            } else {
                $httpBody = $teams_create_discussion_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsCreateDiscussionLegacy
     *
     * Create a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion
     * @deprecated
     */
    public function teamsCreateDiscussionLegacy($team_id, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionLegacy'][0])
    {
        list($response) = $this->teamsCreateDiscussionLegacyWithHttpInfo($team_id, $teams_create_discussion_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsCreateDiscussionLegacyWithHttpInfo
     *
     * Create a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsCreateDiscussionLegacyWithHttpInfo($team_id, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionLegacy'][0])
    {
        $request = $this->teamsCreateDiscussionLegacyRequest($team_id, $teams_create_discussion_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsCreateDiscussionLegacyAsync
     *
     * Create a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCreateDiscussionLegacyAsync($team_id, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionLegacy'][0])
    {
        return $this->teamsCreateDiscussionLegacyAsyncWithHttpInfo($team_id, $teams_create_discussion_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsCreateDiscussionLegacyAsyncWithHttpInfo
     *
     * Create a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsCreateDiscussionLegacyAsyncWithHttpInfo($team_id, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
        $request = $this->teamsCreateDiscussionLegacyRequest($team_id, $teams_create_discussion_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsCreateDiscussionLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionInOrgRequest $teams_create_discussion_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsCreateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsCreateDiscussionLegacyRequest($team_id, $teams_create_discussion_in_org_request, string $contentType = self::contentTypes['teamsCreateDiscussionLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsCreateDiscussionLegacy'
            );
        }

        // verify the required parameter 'teams_create_discussion_in_org_request' is set
        if ($teams_create_discussion_in_org_request === null || (is_array($teams_create_discussion_in_org_request) && count($teams_create_discussion_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_discussion_in_org_request when calling teamsCreateDiscussionLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_discussion_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_discussion_in_org_request));
            } else {
                $httpBody = $teams_create_discussion_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDeleteDiscussionCommentInOrg
     *
     * Delete a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsDeleteDiscussionCommentInOrg($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentInOrg'][0])
    {
        $this->teamsDeleteDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $contentType);
    }

    /**
     * Operation teamsDeleteDiscussionCommentInOrgWithHttpInfo
     *
     * Delete a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsDeleteDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentInOrg'][0])
    {
        $request = $this->teamsDeleteDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteDiscussionCommentInOrgAsync
     *
     * Delete a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteDiscussionCommentInOrgAsync($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentInOrg'][0])
    {
        return $this->teamsDeleteDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteDiscussionCommentInOrgAsyncWithHttpInfo
     *
     * Delete a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsDeleteDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDeleteDiscussionCommentInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsDeleteDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsDeleteDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsDeleteDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsDeleteDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'comment_number' is set
        if ($comment_number === null || (is_array($comment_number) && count($comment_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_number when calling teamsDeleteDiscussionCommentInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }
        // path params
        if ($comment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'comment_number' . '}',
                ObjectSerializer::toPathValue($comment_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDeleteDiscussionCommentLegacy
     *
     * Delete a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsDeleteDiscussionCommentLegacy($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentLegacy'][0])
    {
        $this->teamsDeleteDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $comment_number, $contentType);
    }

    /**
     * Operation teamsDeleteDiscussionCommentLegacyWithHttpInfo
     *
     * Delete a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsDeleteDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentLegacy'][0])
    {
        $request = $this->teamsDeleteDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteDiscussionCommentLegacyAsync
     *
     * Delete a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsDeleteDiscussionCommentLegacyAsync($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentLegacy'][0])
    {
        return $this->teamsDeleteDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $comment_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteDiscussionCommentLegacyAsyncWithHttpInfo
     *
     * Delete a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsDeleteDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsDeleteDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDeleteDiscussionCommentLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsDeleteDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsDeleteDiscussionCommentLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsDeleteDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsDeleteDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'comment_number' is set
        if ($comment_number === null || (is_array($comment_number) && count($comment_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_number when calling teamsDeleteDiscussionCommentLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }
        // path params
        if ($comment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'comment_number' . '}',
                ObjectSerializer::toPathValue($comment_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDeleteDiscussionInOrg
     *
     * Delete a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsDeleteDiscussionInOrg($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionInOrg'][0])
    {
        $this->teamsDeleteDiscussionInOrgWithHttpInfo($org, $team_slug, $discussion_number, $contentType);
    }

    /**
     * Operation teamsDeleteDiscussionInOrgWithHttpInfo
     *
     * Delete a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsDeleteDiscussionInOrgWithHttpInfo($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionInOrg'][0])
    {
        $request = $this->teamsDeleteDiscussionInOrgRequest($org, $team_slug, $discussion_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteDiscussionInOrgAsync
     *
     * Delete a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteDiscussionInOrgAsync($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionInOrg'][0])
    {
        return $this->teamsDeleteDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteDiscussionInOrgAsyncWithHttpInfo
     *
     * Delete a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsDeleteDiscussionInOrgRequest($org, $team_slug, $discussion_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDeleteDiscussionInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsDeleteDiscussionInOrgRequest($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsDeleteDiscussionInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsDeleteDiscussionInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsDeleteDiscussionInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDeleteDiscussionLegacy
     *
     * Delete a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsDeleteDiscussionLegacy($team_id, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionLegacy'][0])
    {
        $this->teamsDeleteDiscussionLegacyWithHttpInfo($team_id, $discussion_number, $contentType);
    }

    /**
     * Operation teamsDeleteDiscussionLegacyWithHttpInfo
     *
     * Delete a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsDeleteDiscussionLegacyWithHttpInfo($team_id, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionLegacy'][0])
    {
        $request = $this->teamsDeleteDiscussionLegacyRequest($team_id, $discussion_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteDiscussionLegacyAsync
     *
     * Delete a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsDeleteDiscussionLegacyAsync($team_id, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionLegacy'][0])
    {
        return $this->teamsDeleteDiscussionLegacyAsyncWithHttpInfo($team_id, $discussion_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteDiscussionLegacyAsyncWithHttpInfo
     *
     * Delete a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsDeleteDiscussionLegacyAsyncWithHttpInfo($team_id, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsDeleteDiscussionLegacyRequest($team_id, $discussion_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDeleteDiscussionLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsDeleteDiscussionLegacyRequest($team_id, $discussion_number, string $contentType = self::contentTypes['teamsDeleteDiscussionLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsDeleteDiscussionLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsDeleteDiscussionLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDeleteInOrg
     *
     * Delete a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsDeleteInOrg($org, $team_slug, string $contentType = self::contentTypes['teamsDeleteInOrg'][0])
    {
        $this->teamsDeleteInOrgWithHttpInfo($org, $team_slug, $contentType);
    }

    /**
     * Operation teamsDeleteInOrgWithHttpInfo
     *
     * Delete a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsDeleteInOrgWithHttpInfo($org, $team_slug, string $contentType = self::contentTypes['teamsDeleteInOrg'][0])
    {
        $request = $this->teamsDeleteInOrgRequest($org, $team_slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteInOrgAsync
     *
     * Delete a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteInOrgAsync($org, $team_slug, string $contentType = self::contentTypes['teamsDeleteInOrg'][0])
    {
        return $this->teamsDeleteInOrgAsyncWithHttpInfo($org, $team_slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteInOrgAsyncWithHttpInfo
     *
     * Delete a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsDeleteInOrgAsyncWithHttpInfo($org, $team_slug, string $contentType = self::contentTypes['teamsDeleteInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsDeleteInOrgRequest($org, $team_slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDeleteInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsDeleteInOrgRequest($org, $team_slug, string $contentType = self::contentTypes['teamsDeleteInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsDeleteInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsDeleteInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsDeleteLegacy
     *
     * Delete a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsDeleteLegacy($team_id, string $contentType = self::contentTypes['teamsDeleteLegacy'][0])
    {
        $this->teamsDeleteLegacyWithHttpInfo($team_id, $contentType);
    }

    /**
     * Operation teamsDeleteLegacyWithHttpInfo
     *
     * Delete a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsDeleteLegacyWithHttpInfo($team_id, string $contentType = self::contentTypes['teamsDeleteLegacy'][0])
    {
        $request = $this->teamsDeleteLegacyRequest($team_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsDeleteLegacyAsync
     *
     * Delete a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsDeleteLegacyAsync($team_id, string $contentType = self::contentTypes['teamsDeleteLegacy'][0])
    {
        return $this->teamsDeleteLegacyAsyncWithHttpInfo($team_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsDeleteLegacyAsyncWithHttpInfo
     *
     * Delete a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsDeleteLegacyAsyncWithHttpInfo($team_id, string $contentType = self::contentTypes['teamsDeleteLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsDeleteLegacyRequest($team_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsDeleteLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsDeleteLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsDeleteLegacyRequest($team_id, string $contentType = self::contentTypes['teamsDeleteLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsDeleteLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetByName
     *
     * Get a team by name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetByName'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function teamsGetByName($org, $team_slug, string $contentType = self::contentTypes['teamsGetByName'][0])
    {
        list($response) = $this->teamsGetByNameWithHttpInfo($org, $team_slug, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetByNameWithHttpInfo
     *
     * Get a team by name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetByName'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsGetByNameWithHttpInfo($org, $team_slug, string $contentType = self::contentTypes['teamsGetByName'][0])
    {
        $request = $this->teamsGetByNameRequest($org, $team_slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetByNameAsync
     *
     * Get a team by name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetByName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetByNameAsync($org, $team_slug, string $contentType = self::contentTypes['teamsGetByName'][0])
    {
        return $this->teamsGetByNameAsyncWithHttpInfo($org, $team_slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetByNameAsyncWithHttpInfo
     *
     * Get a team by name
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetByName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetByNameAsyncWithHttpInfo($org, $team_slug, string $contentType = self::contentTypes['teamsGetByName'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
        $request = $this->teamsGetByNameRequest($org, $team_slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetByName'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetByName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsGetByNameRequest($org, $team_slug, string $contentType = self::contentTypes['teamsGetByName'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsGetByName'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsGetByName'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetDiscussionCommentInOrg
     *
     * Get a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment
     */
    public function teamsGetDiscussionCommentInOrg($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentInOrg'][0])
    {
        list($response) = $this->teamsGetDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetDiscussionCommentInOrgWithHttpInfo
     *
     * Get a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsGetDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentInOrg'][0])
    {
        $request = $this->teamsGetDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetDiscussionCommentInOrgAsync
     *
     * Get a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetDiscussionCommentInOrgAsync($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentInOrg'][0])
    {
        return $this->teamsGetDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetDiscussionCommentInOrgAsyncWithHttpInfo
     *
     * Get a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
        $request = $this->teamsGetDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetDiscussionCommentInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsGetDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsGetDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsGetDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsGetDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'comment_number' is set
        if ($comment_number === null || (is_array($comment_number) && count($comment_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_number when calling teamsGetDiscussionCommentInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }
        // path params
        if ($comment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'comment_number' . '}',
                ObjectSerializer::toPathValue($comment_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetDiscussionCommentLegacy
     *
     * Get a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment
     * @deprecated
     */
    public function teamsGetDiscussionCommentLegacy($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentLegacy'][0])
    {
        list($response) = $this->teamsGetDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $comment_number, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetDiscussionCommentLegacyWithHttpInfo
     *
     * Get a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsGetDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentLegacy'][0])
    {
        $request = $this->teamsGetDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetDiscussionCommentLegacyAsync
     *
     * Get a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetDiscussionCommentLegacyAsync($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentLegacy'][0])
    {
        return $this->teamsGetDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $comment_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetDiscussionCommentLegacyAsyncWithHttpInfo
     *
     * Get a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
        $request = $this->teamsGetDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetDiscussionCommentLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsGetDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, string $contentType = self::contentTypes['teamsGetDiscussionCommentLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsGetDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsGetDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'comment_number' is set
        if ($comment_number === null || (is_array($comment_number) && count($comment_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_number when calling teamsGetDiscussionCommentLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }
        // path params
        if ($comment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'comment_number' . '}',
                ObjectSerializer::toPathValue($comment_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetDiscussionInOrg
     *
     * Get a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion
     */
    public function teamsGetDiscussionInOrg($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionInOrg'][0])
    {
        list($response) = $this->teamsGetDiscussionInOrgWithHttpInfo($org, $team_slug, $discussion_number, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetDiscussionInOrgWithHttpInfo
     *
     * Get a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsGetDiscussionInOrgWithHttpInfo($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionInOrg'][0])
    {
        $request = $this->teamsGetDiscussionInOrgRequest($org, $team_slug, $discussion_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetDiscussionInOrgAsync
     *
     * Get a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetDiscussionInOrgAsync($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionInOrg'][0])
    {
        return $this->teamsGetDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetDiscussionInOrgAsyncWithHttpInfo
     *
     * Get a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
        $request = $this->teamsGetDiscussionInOrgRequest($org, $team_slug, $discussion_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetDiscussionInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsGetDiscussionInOrgRequest($org, $team_slug, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsGetDiscussionInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsGetDiscussionInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsGetDiscussionInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetDiscussionLegacy
     *
     * Get a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion
     * @deprecated
     */
    public function teamsGetDiscussionLegacy($team_id, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionLegacy'][0])
    {
        list($response) = $this->teamsGetDiscussionLegacyWithHttpInfo($team_id, $discussion_number, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetDiscussionLegacyWithHttpInfo
     *
     * Get a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsGetDiscussionLegacyWithHttpInfo($team_id, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionLegacy'][0])
    {
        $request = $this->teamsGetDiscussionLegacyRequest($team_id, $discussion_number, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetDiscussionLegacyAsync
     *
     * Get a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetDiscussionLegacyAsync($team_id, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionLegacy'][0])
    {
        return $this->teamsGetDiscussionLegacyAsyncWithHttpInfo($team_id, $discussion_number, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetDiscussionLegacyAsyncWithHttpInfo
     *
     * Get a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetDiscussionLegacyAsyncWithHttpInfo($team_id, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
        $request = $this->teamsGetDiscussionLegacyRequest($team_id, $discussion_number, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetDiscussionLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsGetDiscussionLegacyRequest($team_id, $discussion_number, string $contentType = self::contentTypes['teamsGetDiscussionLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsGetDiscussionLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsGetDiscussionLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetLegacy
     *
     * Get a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsGetLegacy($team_id, string $contentType = self::contentTypes['teamsGetLegacy'][0])
    {
        list($response) = $this->teamsGetLegacyWithHttpInfo($team_id, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetLegacyWithHttpInfo
     *
     * Get a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsGetLegacyWithHttpInfo($team_id, string $contentType = self::contentTypes['teamsGetLegacy'][0])
    {
        $request = $this->teamsGetLegacyRequest($team_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetLegacyAsync
     *
     * Get a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetLegacyAsync($team_id, string $contentType = self::contentTypes['teamsGetLegacy'][0])
    {
        return $this->teamsGetLegacyAsyncWithHttpInfo($team_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetLegacyAsyncWithHttpInfo
     *
     * Get a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetLegacyAsyncWithHttpInfo($team_id, string $contentType = self::contentTypes['teamsGetLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
        $request = $this->teamsGetLegacyRequest($team_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsGetLegacyRequest($team_id, string $contentType = self::contentTypes['teamsGetLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsGetLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetMemberLegacy
     *
     * Get team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMemberLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsGetMemberLegacy($team_id, $username, string $contentType = self::contentTypes['teamsGetMemberLegacy'][0])
    {
        $this->teamsGetMemberLegacyWithHttpInfo($team_id, $username, $contentType);
    }

    /**
     * Operation teamsGetMemberLegacyWithHttpInfo
     *
     * Get team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMemberLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsGetMemberLegacyWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsGetMemberLegacy'][0])
    {
        $request = $this->teamsGetMemberLegacyRequest($team_id, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetMemberLegacyAsync
     *
     * Get team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetMemberLegacyAsync($team_id, $username, string $contentType = self::contentTypes['teamsGetMemberLegacy'][0])
    {
        return $this->teamsGetMemberLegacyAsyncWithHttpInfo($team_id, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetMemberLegacyAsyncWithHttpInfo
     *
     * Get team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetMemberLegacyAsyncWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsGetMemberLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsGetMemberLegacyRequest($team_id, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetMemberLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsGetMemberLegacyRequest($team_id, $username, string $contentType = self::contentTypes['teamsGetMemberLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsGetMemberLegacy'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsGetMemberLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/members/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetMembershipForUserInOrg
     *
     * Get team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership
     */
    public function teamsGetMembershipForUserInOrg($org, $team_slug, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserInOrg'][0])
    {
        list($response) = $this->teamsGetMembershipForUserInOrgWithHttpInfo($org, $team_slug, $username, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetMembershipForUserInOrgWithHttpInfo
     *
     * Get team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsGetMembershipForUserInOrgWithHttpInfo($org, $team_slug, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserInOrg'][0])
    {
        $request = $this->teamsGetMembershipForUserInOrgRequest($org, $team_slug, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetMembershipForUserInOrgAsync
     *
     * Get team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetMembershipForUserInOrgAsync($org, $team_slug, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserInOrg'][0])
    {
        return $this->teamsGetMembershipForUserInOrgAsyncWithHttpInfo($org, $team_slug, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetMembershipForUserInOrgAsyncWithHttpInfo
     *
     * Get team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsGetMembershipForUserInOrgAsyncWithHttpInfo($org, $team_slug, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
        $request = $this->teamsGetMembershipForUserInOrgRequest($org, $team_slug, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetMembershipForUserInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsGetMembershipForUserInOrgRequest($org, $team_slug, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsGetMembershipForUserInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsGetMembershipForUserInOrg'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsGetMembershipForUserInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/memberships/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsGetMembershipForUserLegacy
     *
     * Get team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsGetMembershipForUserLegacy($team_id, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserLegacy'][0])
    {
        list($response) = $this->teamsGetMembershipForUserLegacyWithHttpInfo($team_id, $username, $contentType);
        return $response;
    }

    /**
     * Operation teamsGetMembershipForUserLegacyWithHttpInfo
     *
     * Get team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsGetMembershipForUserLegacyWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserLegacy'][0])
    {
        $request = $this->teamsGetMembershipForUserLegacyRequest($team_id, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsGetMembershipForUserLegacyAsync
     *
     * Get team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetMembershipForUserLegacyAsync($team_id, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserLegacy'][0])
    {
        return $this->teamsGetMembershipForUserLegacyAsyncWithHttpInfo($team_id, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsGetMembershipForUserLegacyAsyncWithHttpInfo
     *
     * Get team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsGetMembershipForUserLegacyAsyncWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamMembership';
        $request = $this->teamsGetMembershipForUserLegacyRequest($team_id, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsGetMembershipForUserLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsGetMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsGetMembershipForUserLegacyRequest($team_id, $username, string $contentType = self::contentTypes['teamsGetMembershipForUserLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsGetMembershipForUserLegacy'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsGetMembershipForUserLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/memberships/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsList
     *
     * List teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsList'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function teamsList($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsList'][0])
    {
        list($response) = $this->teamsListWithHttpInfo($org, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListWithHttpInfo
     *
     * List teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsList'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsList'][0])
    {
        $request = $this->teamsListRequest($org, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListAsync
     *
     * List teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListAsync($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsList'][0])
    {
        return $this->teamsListAsyncWithHttpInfo($org, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListAsyncWithHttpInfo
     *
     * List teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListAsyncWithHttpInfo($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsList'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]';
        $request = $this->teamsListRequest($org, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsList'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListRequest($org, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsList'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsList'
            );
        }




        $resourcePath = '/orgs/{org}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListChildInOrg
     *
     * List child teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]
     */
    public function teamsListChildInOrg($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildInOrg'][0])
    {
        list($response) = $this->teamsListChildInOrgWithHttpInfo($org, $team_slug, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListChildInOrgWithHttpInfo
     *
     * List child teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListChildInOrgWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildInOrg'][0])
    {
        $request = $this->teamsListChildInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListChildInOrgAsync
     *
     * List child teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListChildInOrgAsync($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildInOrg'][0])
    {
        return $this->teamsListChildInOrgAsyncWithHttpInfo($org, $team_slug, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListChildInOrgAsyncWithHttpInfo
     *
     * List child teams
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListChildInOrgAsyncWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]';
        $request = $this->teamsListChildInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListChildInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListChildInOrgRequest($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListChildInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListChildInOrg'
            );
        }




        $resourcePath = '/orgs/{org}/teams/{team_slug}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListChildLegacy
     *
     * List child teams (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError
     * @deprecated
     */
    public function teamsListChildLegacy($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildLegacy'][0])
    {
        list($response) = $this->teamsListChildLegacyWithHttpInfo($team_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListChildLegacyWithHttpInfo
     *
     * List child teams (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListChildLegacyWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildLegacy'][0])
    {
        $request = $this->teamsListChildLegacyRequest($team_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListChildLegacyAsync
     *
     * List child teams (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListChildLegacyAsync($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildLegacy'][0])
    {
        return $this->teamsListChildLegacyAsyncWithHttpInfo($team_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListChildLegacyAsyncWithHttpInfo
     *
     * List child teams (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListChildLegacyAsyncWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\Team[]';
        $request = $this->teamsListChildLegacyRequest($team_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListChildLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListChildLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListChildLegacyRequest($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListChildLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListChildLegacy'
            );
        }




        $resourcePath = '/teams/{team_id}/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListDiscussionCommentsInOrg
     *
     * List discussion comments
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]
     */
    public function teamsListDiscussionCommentsInOrg($org, $team_slug, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsInOrg'][0])
    {
        list($response) = $this->teamsListDiscussionCommentsInOrgWithHttpInfo($org, $team_slug, $discussion_number, $direction, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListDiscussionCommentsInOrgWithHttpInfo
     *
     * List discussion comments
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListDiscussionCommentsInOrgWithHttpInfo($org, $team_slug, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsInOrg'][0])
    {
        $request = $this->teamsListDiscussionCommentsInOrgRequest($org, $team_slug, $discussion_number, $direction, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListDiscussionCommentsInOrgAsync
     *
     * List discussion comments
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListDiscussionCommentsInOrgAsync($org, $team_slug, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsInOrg'][0])
    {
        return $this->teamsListDiscussionCommentsInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $direction, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListDiscussionCommentsInOrgAsyncWithHttpInfo
     *
     * List discussion comments
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListDiscussionCommentsInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]';
        $request = $this->teamsListDiscussionCommentsInOrgRequest($org, $team_slug, $discussion_number, $direction, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListDiscussionCommentsInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListDiscussionCommentsInOrgRequest($org, $team_slug, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListDiscussionCommentsInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListDiscussionCommentsInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsListDiscussionCommentsInOrg'
            );
        }





        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListDiscussionCommentsLegacy
     *
     * List discussion comments (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]
     * @deprecated
     */
    public function teamsListDiscussionCommentsLegacy($team_id, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsLegacy'][0])
    {
        list($response) = $this->teamsListDiscussionCommentsLegacyWithHttpInfo($team_id, $discussion_number, $direction, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListDiscussionCommentsLegacyWithHttpInfo
     *
     * List discussion comments (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListDiscussionCommentsLegacyWithHttpInfo($team_id, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsLegacy'][0])
    {
        $request = $this->teamsListDiscussionCommentsLegacyRequest($team_id, $discussion_number, $direction, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListDiscussionCommentsLegacyAsync
     *
     * List discussion comments (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListDiscussionCommentsLegacyAsync($team_id, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsLegacy'][0])
    {
        return $this->teamsListDiscussionCommentsLegacyAsyncWithHttpInfo($team_id, $discussion_number, $direction, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListDiscussionCommentsLegacyAsyncWithHttpInfo
     *
     * List discussion comments (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListDiscussionCommentsLegacyAsyncWithHttpInfo($team_id, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment[]';
        $request = $this->teamsListDiscussionCommentsLegacyRequest($team_id, $discussion_number, $direction, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListDiscussionCommentsLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionCommentsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListDiscussionCommentsLegacyRequest($team_id, $discussion_number, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionCommentsLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListDiscussionCommentsLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsListDiscussionCommentsLegacy'
            );
        }





        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}/comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListDiscussionsInOrg
     *
     * List discussions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $pinned Pinned discussions only filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]
     */
    public function teamsListDiscussionsInOrg($org, $team_slug, $direction = 'desc', $per_page = 30, $page = 1, $pinned = null, string $contentType = self::contentTypes['teamsListDiscussionsInOrg'][0])
    {
        list($response) = $this->teamsListDiscussionsInOrgWithHttpInfo($org, $team_slug, $direction, $per_page, $page, $pinned, $contentType);
        return $response;
    }

    /**
     * Operation teamsListDiscussionsInOrgWithHttpInfo
     *
     * List discussions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $pinned Pinned discussions only filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListDiscussionsInOrgWithHttpInfo($org, $team_slug, $direction = 'desc', $per_page = 30, $page = 1, $pinned = null, string $contentType = self::contentTypes['teamsListDiscussionsInOrg'][0])
    {
        $request = $this->teamsListDiscussionsInOrgRequest($org, $team_slug, $direction, $per_page, $page, $pinned, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListDiscussionsInOrgAsync
     *
     * List discussions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $pinned Pinned discussions only filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListDiscussionsInOrgAsync($org, $team_slug, $direction = 'desc', $per_page = 30, $page = 1, $pinned = null, string $contentType = self::contentTypes['teamsListDiscussionsInOrg'][0])
    {
        return $this->teamsListDiscussionsInOrgAsyncWithHttpInfo($org, $team_slug, $direction, $per_page, $page, $pinned, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListDiscussionsInOrgAsyncWithHttpInfo
     *
     * List discussions
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $pinned Pinned discussions only filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListDiscussionsInOrgAsyncWithHttpInfo($org, $team_slug, $direction = 'desc', $per_page = 30, $page = 1, $pinned = null, string $contentType = self::contentTypes['teamsListDiscussionsInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]';
        $request = $this->teamsListDiscussionsInOrgRequest($org, $team_slug, $direction, $per_page, $page, $pinned, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListDiscussionsInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $pinned Pinned discussions only filter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListDiscussionsInOrgRequest($org, $team_slug, $direction = 'desc', $per_page = 30, $page = 1, $pinned = null, string $contentType = self::contentTypes['teamsListDiscussionsInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListDiscussionsInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListDiscussionsInOrg'
            );
        }






        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pinned,
            'pinned', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListDiscussionsLegacy
     *
     * List discussions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]
     * @deprecated
     */
    public function teamsListDiscussionsLegacy($team_id, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionsLegacy'][0])
    {
        list($response) = $this->teamsListDiscussionsLegacyWithHttpInfo($team_id, $direction, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListDiscussionsLegacyWithHttpInfo
     *
     * List discussions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListDiscussionsLegacyWithHttpInfo($team_id, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionsLegacy'][0])
    {
        $request = $this->teamsListDiscussionsLegacyRequest($team_id, $direction, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListDiscussionsLegacyAsync
     *
     * List discussions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListDiscussionsLegacyAsync($team_id, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionsLegacy'][0])
    {
        return $this->teamsListDiscussionsLegacyAsyncWithHttpInfo($team_id, $direction, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListDiscussionsLegacyAsyncWithHttpInfo
     *
     * List discussions (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListDiscussionsLegacyAsyncWithHttpInfo($team_id, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionsLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion[]';
        $request = $this->teamsListDiscussionsLegacyRequest($team_id, $direction, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListDiscussionsLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $direction The direction to sort the results by. (optional, default to 'desc')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListDiscussionsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListDiscussionsLegacyRequest($team_id, $direction = 'desc', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListDiscussionsLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListDiscussionsLegacy'
            );
        }





        $resourcePath = '/teams/{team_id}/discussions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $direction,
            'direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListForAuthenticatedUser
     *
     * List teams for the authenticated user
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListForAuthenticatedUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function teamsListForAuthenticatedUser($per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListForAuthenticatedUser'][0])
    {
        list($response) = $this->teamsListForAuthenticatedUserWithHttpInfo($per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListForAuthenticatedUserWithHttpInfo
     *
     * List teams for the authenticated user
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListForAuthenticatedUser'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListForAuthenticatedUserWithHttpInfo($per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListForAuthenticatedUser'][0])
    {
        $request = $this->teamsListForAuthenticatedUserRequest($per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListForAuthenticatedUserAsync
     *
     * List teams for the authenticated user
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListForAuthenticatedUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListForAuthenticatedUserAsync($per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListForAuthenticatedUser'][0])
    {
        return $this->teamsListForAuthenticatedUserAsyncWithHttpInfo($per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListForAuthenticatedUserAsyncWithHttpInfo
     *
     * List teams for the authenticated user
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListForAuthenticatedUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListForAuthenticatedUserAsyncWithHttpInfo($per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListForAuthenticatedUser'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull[]';
        $request = $this->teamsListForAuthenticatedUserRequest($per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListForAuthenticatedUser'
     *
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListForAuthenticatedUser'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListForAuthenticatedUserRequest($per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListForAuthenticatedUser'][0])
    {




        $resourcePath = '/user/teams';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListMembersInOrg
     *
     * List team members
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]
     */
    public function teamsListMembersInOrg($org, $team_slug, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersInOrg'][0])
    {
        list($response) = $this->teamsListMembersInOrgWithHttpInfo($org, $team_slug, $role, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListMembersInOrgWithHttpInfo
     *
     * List team members
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListMembersInOrgWithHttpInfo($org, $team_slug, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersInOrg'][0])
    {
        $request = $this->teamsListMembersInOrgRequest($org, $team_slug, $role, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListMembersInOrgAsync
     *
     * List team members
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListMembersInOrgAsync($org, $team_slug, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersInOrg'][0])
    {
        return $this->teamsListMembersInOrgAsyncWithHttpInfo($org, $team_slug, $role, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListMembersInOrgAsyncWithHttpInfo
     *
     * List team members
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListMembersInOrgAsyncWithHttpInfo($org, $team_slug, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]';
        $request = $this->teamsListMembersInOrgRequest($org, $team_slug, $role, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListMembersInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListMembersInOrgRequest($org, $team_slug, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListMembersInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListMembersInOrg'
            );
        }





        $resourcePath = '/orgs/{org}/teams/{team_slug}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListMembersLegacy
     *
     * List team members (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsListMembersLegacy($team_id, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersLegacy'][0])
    {
        list($response) = $this->teamsListMembersLegacyWithHttpInfo($team_id, $role, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListMembersLegacyWithHttpInfo
     *
     * List team members (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListMembersLegacyWithHttpInfo($team_id, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersLegacy'][0])
    {
        $request = $this->teamsListMembersLegacyRequest($team_id, $role, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListMembersLegacyAsync
     *
     * List team members (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListMembersLegacyAsync($team_id, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersLegacy'][0])
    {
        return $this->teamsListMembersLegacyAsyncWithHttpInfo($team_id, $role, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListMembersLegacyAsyncWithHttpInfo
     *
     * List team members (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListMembersLegacyAsyncWithHttpInfo($team_id, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\SimpleUser[]';
        $request = $this->teamsListMembersLegacyRequest($team_id, $role, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListMembersLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $role Filters members returned by their role in the team. (optional, default to 'all')
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListMembersLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListMembersLegacyRequest($team_id, $role = 'all', $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListMembersLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListMembersLegacy'
            );
        }





        $resourcePath = '/teams/{team_id}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $role,
            'role', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListPendingInvitationsInOrg
     *
     * List pending team invitations
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]
     */
    public function teamsListPendingInvitationsInOrg($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsInOrg'][0])
    {
        list($response) = $this->teamsListPendingInvitationsInOrgWithHttpInfo($org, $team_slug, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListPendingInvitationsInOrgWithHttpInfo
     *
     * List pending team invitations
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListPendingInvitationsInOrgWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsInOrg'][0])
    {
        $request = $this->teamsListPendingInvitationsInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListPendingInvitationsInOrgAsync
     *
     * List pending team invitations
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListPendingInvitationsInOrgAsync($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsInOrg'][0])
    {
        return $this->teamsListPendingInvitationsInOrgAsyncWithHttpInfo($org, $team_slug, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListPendingInvitationsInOrgAsyncWithHttpInfo
     *
     * List pending team invitations
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListPendingInvitationsInOrgAsyncWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]';
        $request = $this->teamsListPendingInvitationsInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListPendingInvitationsInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListPendingInvitationsInOrgRequest($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListPendingInvitationsInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListPendingInvitationsInOrg'
            );
        }




        $resourcePath = '/orgs/{org}/teams/{team_slug}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListPendingInvitationsLegacy
     *
     * List pending team invitations (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]
     * @deprecated
     */
    public function teamsListPendingInvitationsLegacy($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsLegacy'][0])
    {
        list($response) = $this->teamsListPendingInvitationsLegacyWithHttpInfo($team_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListPendingInvitationsLegacyWithHttpInfo
     *
     * List pending team invitations (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListPendingInvitationsLegacyWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsLegacy'][0])
    {
        $request = $this->teamsListPendingInvitationsLegacyRequest($team_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListPendingInvitationsLegacyAsync
     *
     * List pending team invitations (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListPendingInvitationsLegacyAsync($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsLegacy'][0])
    {
        return $this->teamsListPendingInvitationsLegacyAsyncWithHttpInfo($team_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListPendingInvitationsLegacyAsyncWithHttpInfo
     *
     * List pending team invitations (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListPendingInvitationsLegacyAsyncWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\OrganizationInvitation[]';
        $request = $this->teamsListPendingInvitationsLegacyRequest($team_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListPendingInvitationsLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListPendingInvitationsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListPendingInvitationsLegacyRequest($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListPendingInvitationsLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListPendingInvitationsLegacy'
            );
        }




        $resourcePath = '/teams/{team_id}/invitations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListProjectsInOrg
     *
     * List team projects
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]
     */
    public function teamsListProjectsInOrg($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsInOrg'][0])
    {
        list($response) = $this->teamsListProjectsInOrgWithHttpInfo($org, $team_slug, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListProjectsInOrgWithHttpInfo
     *
     * List team projects
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListProjectsInOrgWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsInOrg'][0])
    {
        $request = $this->teamsListProjectsInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListProjectsInOrgAsync
     *
     * List team projects
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListProjectsInOrgAsync($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsInOrg'][0])
    {
        return $this->teamsListProjectsInOrgAsyncWithHttpInfo($org, $team_slug, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListProjectsInOrgAsyncWithHttpInfo
     *
     * List team projects
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListProjectsInOrgAsyncWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]';
        $request = $this->teamsListProjectsInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListProjectsInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListProjectsInOrgRequest($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListProjectsInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListProjectsInOrg'
            );
        }




        $resourcePath = '/orgs/{org}/teams/{team_slug}/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListProjectsLegacy
     *
     * List team projects (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsListProjectsLegacy($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsLegacy'][0])
    {
        list($response) = $this->teamsListProjectsLegacyWithHttpInfo($team_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListProjectsLegacyWithHttpInfo
     *
     * List team projects (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListProjectsLegacyWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsLegacy'][0])
    {
        $request = $this->teamsListProjectsLegacyRequest($team_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListProjectsLegacyAsync
     *
     * List team projects (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListProjectsLegacyAsync($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsLegacy'][0])
    {
        return $this->teamsListProjectsLegacyAsyncWithHttpInfo($team_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListProjectsLegacyAsyncWithHttpInfo
     *
     * List team projects (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListProjectsLegacyAsyncWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamProject[]';
        $request = $this->teamsListProjectsLegacyRequest($team_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListProjectsLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListProjectsLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListProjectsLegacyRequest($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListProjectsLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListProjectsLegacy'
            );
        }




        $resourcePath = '/teams/{team_id}/projects';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListReposInOrg
     *
     * List team repositories
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]
     */
    public function teamsListReposInOrg($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposInOrg'][0])
    {
        list($response) = $this->teamsListReposInOrgWithHttpInfo($org, $team_slug, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListReposInOrgWithHttpInfo
     *
     * List team repositories
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[], HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsListReposInOrgWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposInOrg'][0])
    {
        $request = $this->teamsListReposInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListReposInOrgAsync
     *
     * List team repositories
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListReposInOrgAsync($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposInOrg'][0])
    {
        return $this->teamsListReposInOrgAsyncWithHttpInfo($org, $team_slug, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListReposInOrgAsyncWithHttpInfo
     *
     * List team repositories
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsListReposInOrgAsyncWithHttpInfo($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]';
        $request = $this->teamsListReposInOrgRequest($org, $team_slug, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListReposInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsListReposInOrgRequest($org, $team_slug, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsListReposInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsListReposInOrg'
            );
        }




        $resourcePath = '/orgs/{org}/teams/{team_slug}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsListReposLegacy
     *
     * List team repositories (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsListReposLegacy($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposLegacy'][0])
    {
        list($response) = $this->teamsListReposLegacyWithHttpInfo($team_id, $per_page, $page, $contentType);
        return $response;
    }

    /**
     * Operation teamsListReposLegacyWithHttpInfo
     *
     * List team repositories (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsListReposLegacyWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposLegacy'][0])
    {
        $request = $this->teamsListReposLegacyRequest($team_id, $per_page, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsListReposLegacyAsync
     *
     * List team repositories (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListReposLegacyAsync($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposLegacy'][0])
    {
        return $this->teamsListReposLegacyAsyncWithHttpInfo($team_id, $per_page, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsListReposLegacyAsyncWithHttpInfo
     *
     * List team repositories (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsListReposLegacyAsyncWithHttpInfo($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\MinimalRepository[]';
        $request = $this->teamsListReposLegacyRequest($team_id, $per_page, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsListReposLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $per_page The number of results per page (max 100). For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 30)
     * @param  int $page The page number of the results to fetch. For more information, see \&quot;[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\&quot; (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsListReposLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsListReposLegacyRequest($team_id, $per_page = 30, $page = 1, string $contentType = self::contentTypes['teamsListReposLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsListReposLegacy'
            );
        }




        $resourcePath = '/teams/{team_id}/repos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $per_page,
            'per_page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveMemberLegacy
     *
     * Remove team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMemberLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsRemoveMemberLegacy($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMemberLegacy'][0])
    {
        $this->teamsRemoveMemberLegacyWithHttpInfo($team_id, $username, $contentType);
    }

    /**
     * Operation teamsRemoveMemberLegacyWithHttpInfo
     *
     * Remove team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMemberLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsRemoveMemberLegacyWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMemberLegacy'][0])
    {
        $request = $this->teamsRemoveMemberLegacyRequest($team_id, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveMemberLegacyAsync
     *
     * Remove team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveMemberLegacyAsync($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMemberLegacy'][0])
    {
        return $this->teamsRemoveMemberLegacyAsyncWithHttpInfo($team_id, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveMemberLegacyAsyncWithHttpInfo
     *
     * Remove team member (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveMemberLegacyAsyncWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMemberLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveMemberLegacyRequest($team_id, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveMemberLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMemberLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsRemoveMemberLegacyRequest($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMemberLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsRemoveMemberLegacy'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsRemoveMemberLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/members/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveMembershipForUserInOrg
     *
     * Remove team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsRemoveMembershipForUserInOrg($org, $team_slug, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserInOrg'][0])
    {
        $this->teamsRemoveMembershipForUserInOrgWithHttpInfo($org, $team_slug, $username, $contentType);
    }

    /**
     * Operation teamsRemoveMembershipForUserInOrgWithHttpInfo
     *
     * Remove team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsRemoveMembershipForUserInOrgWithHttpInfo($org, $team_slug, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserInOrg'][0])
    {
        $request = $this->teamsRemoveMembershipForUserInOrgRequest($org, $team_slug, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveMembershipForUserInOrgAsync
     *
     * Remove team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveMembershipForUserInOrgAsync($org, $team_slug, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserInOrg'][0])
    {
        return $this->teamsRemoveMembershipForUserInOrgAsyncWithHttpInfo($org, $team_slug, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveMembershipForUserInOrgAsyncWithHttpInfo
     *
     * Remove team membership for a user
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveMembershipForUserInOrgAsyncWithHttpInfo($org, $team_slug, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveMembershipForUserInOrgRequest($org, $team_slug, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveMembershipForUserInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsRemoveMembershipForUserInOrgRequest($org, $team_slug, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsRemoveMembershipForUserInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsRemoveMembershipForUserInOrg'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsRemoveMembershipForUserInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/memberships/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveMembershipForUserLegacy
     *
     * Remove team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsRemoveMembershipForUserLegacy($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserLegacy'][0])
    {
        $this->teamsRemoveMembershipForUserLegacyWithHttpInfo($team_id, $username, $contentType);
    }

    /**
     * Operation teamsRemoveMembershipForUserLegacyWithHttpInfo
     *
     * Remove team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsRemoveMembershipForUserLegacyWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserLegacy'][0])
    {
        $request = $this->teamsRemoveMembershipForUserLegacyRequest($team_id, $username, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveMembershipForUserLegacyAsync
     *
     * Remove team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveMembershipForUserLegacyAsync($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserLegacy'][0])
    {
        return $this->teamsRemoveMembershipForUserLegacyAsyncWithHttpInfo($team_id, $username, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveMembershipForUserLegacyAsyncWithHttpInfo
     *
     * Remove team membership for a user (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveMembershipForUserLegacyAsyncWithHttpInfo($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveMembershipForUserLegacyRequest($team_id, $username, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveMembershipForUserLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $username The handle for the GitHub user account. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveMembershipForUserLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsRemoveMembershipForUserLegacyRequest($team_id, $username, string $contentType = self::contentTypes['teamsRemoveMembershipForUserLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsRemoveMembershipForUserLegacy'
            );
        }

        // verify the required parameter 'username' is set
        if ($username === null || (is_array($username) && count($username) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $username when calling teamsRemoveMembershipForUserLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/memberships/{username}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($username !== null) {
            $resourcePath = str_replace(
                '{' . 'username' . '}',
                ObjectSerializer::toPathValue($username),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveProjectInOrg
     *
     * Remove a project from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsRemoveProjectInOrg($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectInOrg'][0])
    {
        $this->teamsRemoveProjectInOrgWithHttpInfo($org, $team_slug, $project_id, $contentType);
    }

    /**
     * Operation teamsRemoveProjectInOrgWithHttpInfo
     *
     * Remove a project from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsRemoveProjectInOrgWithHttpInfo($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectInOrg'][0])
    {
        $request = $this->teamsRemoveProjectInOrgRequest($org, $team_slug, $project_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveProjectInOrgAsync
     *
     * Remove a project from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveProjectInOrgAsync($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectInOrg'][0])
    {
        return $this->teamsRemoveProjectInOrgAsyncWithHttpInfo($org, $team_slug, $project_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveProjectInOrgAsyncWithHttpInfo
     *
     * Remove a project from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveProjectInOrgAsyncWithHttpInfo($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveProjectInOrgRequest($org, $team_slug, $project_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveProjectInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsRemoveProjectInOrgRequest($org, $team_slug, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsRemoveProjectInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsRemoveProjectInOrg'
            );
        }

        // verify the required parameter 'project_id' is set
        if ($project_id === null || (is_array($project_id) && count($project_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_id when calling teamsRemoveProjectInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/projects/{project_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_id !== null) {
            $resourcePath = str_replace(
                '{' . 'project_id' . '}',
                ObjectSerializer::toPathValue($project_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveProjectLegacy
     *
     * Remove a project from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsRemoveProjectLegacy($team_id, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectLegacy'][0])
    {
        $this->teamsRemoveProjectLegacyWithHttpInfo($team_id, $project_id, $contentType);
    }

    /**
     * Operation teamsRemoveProjectLegacyWithHttpInfo
     *
     * Remove a project from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsRemoveProjectLegacyWithHttpInfo($team_id, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectLegacy'][0])
    {
        $request = $this->teamsRemoveProjectLegacyRequest($team_id, $project_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveProjectLegacyAsync
     *
     * Remove a project from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveProjectLegacyAsync($team_id, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectLegacy'][0])
    {
        return $this->teamsRemoveProjectLegacyAsyncWithHttpInfo($team_id, $project_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveProjectLegacyAsyncWithHttpInfo
     *
     * Remove a project from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveProjectLegacyAsyncWithHttpInfo($team_id, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveProjectLegacyRequest($team_id, $project_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveProjectLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $project_id The unique identifier of the project. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveProjectLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsRemoveProjectLegacyRequest($team_id, $project_id, string $contentType = self::contentTypes['teamsRemoveProjectLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsRemoveProjectLegacy'
            );
        }

        // verify the required parameter 'project_id' is set
        if ($project_id === null || (is_array($project_id) && count($project_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $project_id when calling teamsRemoveProjectLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/projects/{project_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($project_id !== null) {
            $resourcePath = str_replace(
                '{' . 'project_id' . '}',
                ObjectSerializer::toPathValue($project_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveRepoInOrg
     *
     * Remove a repository from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function teamsRemoveRepoInOrg($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoInOrg'][0])
    {
        $this->teamsRemoveRepoInOrgWithHttpInfo($org, $team_slug, $owner, $repo, $contentType);
    }

    /**
     * Operation teamsRemoveRepoInOrgWithHttpInfo
     *
     * Remove a repository from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsRemoveRepoInOrgWithHttpInfo($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoInOrg'][0])
    {
        $request = $this->teamsRemoveRepoInOrgRequest($org, $team_slug, $owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveRepoInOrgAsync
     *
     * Remove a repository from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveRepoInOrgAsync($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoInOrg'][0])
    {
        return $this->teamsRemoveRepoInOrgAsyncWithHttpInfo($org, $team_slug, $owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveRepoInOrgAsyncWithHttpInfo
     *
     * Remove a repository from a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsRemoveRepoInOrgAsyncWithHttpInfo($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoInOrg'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveRepoInOrgRequest($org, $team_slug, $owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveRepoInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsRemoveRepoInOrgRequest($org, $team_slug, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsRemoveRepoInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsRemoveRepoInOrg'
            );
        }

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling teamsRemoveRepoInOrg'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling teamsRemoveRepoInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsRemoveRepoLegacy
     *
     * Remove a repository from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     * @deprecated
     */
    public function teamsRemoveRepoLegacy($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoLegacy'][0])
    {
        $this->teamsRemoveRepoLegacyWithHttpInfo($team_id, $owner, $repo, $contentType);
    }

    /**
     * Operation teamsRemoveRepoLegacyWithHttpInfo
     *
     * Remove a repository from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsRemoveRepoLegacyWithHttpInfo($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoLegacy'][0])
    {
        $request = $this->teamsRemoveRepoLegacyRequest($team_id, $owner, $repo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation teamsRemoveRepoLegacyAsync
     *
     * Remove a repository from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveRepoLegacyAsync($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoLegacy'][0])
    {
        return $this->teamsRemoveRepoLegacyAsyncWithHttpInfo($team_id, $owner, $repo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsRemoveRepoLegacyAsyncWithHttpInfo
     *
     * Remove a repository from a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsRemoveRepoLegacyAsyncWithHttpInfo($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoLegacy'][0])
    {
        $returnType = '';
        $request = $this->teamsRemoveRepoLegacyRequest($team_id, $owner, $repo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsRemoveRepoLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  string $owner The account owner of the repository. The name is not case sensitive. (required)
     * @param  string $repo The name of the repository without the &#x60;.git&#x60; extension. The name is not case sensitive. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsRemoveRepoLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsRemoveRepoLegacyRequest($team_id, $owner, $repo, string $contentType = self::contentTypes['teamsRemoveRepoLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsRemoveRepoLegacy'
            );
        }

        // verify the required parameter 'owner' is set
        if ($owner === null || (is_array($owner) && count($owner) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $owner when calling teamsRemoveRepoLegacy'
            );
        }

        // verify the required parameter 'repo' is set
        if ($repo === null || (is_array($repo) && count($repo) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $repo when calling teamsRemoveRepoLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/repos/{owner}/{repo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($owner !== null) {
            $resourcePath = str_replace(
                '{' . 'owner' . '}',
                ObjectSerializer::toPathValue($owner),
                $resourcePath
            );
        }
        // path params
        if ($repo !== null) {
            $resourcePath = str_replace(
                '{' . 'repo' . '}',
                ObjectSerializer::toPathValue($repo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdateDiscussionCommentInOrg
     *
     * Update a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment
     */
    public function teamsUpdateDiscussionCommentInOrg($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentInOrg'][0])
    {
        list($response) = $this->teamsUpdateDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsUpdateDiscussionCommentInOrgWithHttpInfo
     *
     * Update a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsUpdateDiscussionCommentInOrgWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentInOrg'][0])
    {
        $request = $this->teamsUpdateDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateDiscussionCommentInOrgAsync
     *
     * Update a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateDiscussionCommentInOrgAsync($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentInOrg'][0])
    {
        return $this->teamsUpdateDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateDiscussionCommentInOrgAsyncWithHttpInfo
     *
     * Update a discussion comment
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateDiscussionCommentInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
        $request = $this->teamsUpdateDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdateDiscussionCommentInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsUpdateDiscussionCommentInOrgRequest($org, $team_slug, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsUpdateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsUpdateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsUpdateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'comment_number' is set
        if ($comment_number === null || (is_array($comment_number) && count($comment_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_number when calling teamsUpdateDiscussionCommentInOrg'
            );
        }

        // verify the required parameter 'teams_create_discussion_comment_in_org_request' is set
        if ($teams_create_discussion_comment_in_org_request === null || (is_array($teams_create_discussion_comment_in_org_request) && count($teams_create_discussion_comment_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_discussion_comment_in_org_request when calling teamsUpdateDiscussionCommentInOrg'
            );
        }


        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }
        // path params
        if ($comment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'comment_number' . '}',
                ObjectSerializer::toPathValue($comment_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_discussion_comment_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_discussion_comment_in_org_request));
            } else {
                $httpBody = $teams_create_discussion_comment_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdateDiscussionCommentLegacy
     *
     * Update a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment
     * @deprecated
     */
    public function teamsUpdateDiscussionCommentLegacy($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentLegacy'][0])
    {
        list($response) = $this->teamsUpdateDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsUpdateDiscussionCommentLegacyWithHttpInfo
     *
     * Update a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsUpdateDiscussionCommentLegacyWithHttpInfo($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentLegacy'][0])
    {
        $request = $this->teamsUpdateDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateDiscussionCommentLegacyAsync
     *
     * Update a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsUpdateDiscussionCommentLegacyAsync($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentLegacy'][0])
    {
        return $this->teamsUpdateDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateDiscussionCommentLegacyAsyncWithHttpInfo
     *
     * Update a discussion comment (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsUpdateDiscussionCommentLegacyAsyncWithHttpInfo($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussionComment';
        $request = $this->teamsUpdateDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdateDiscussionCommentLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  int $comment_number The number that identifies the comment. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsCreateDiscussionCommentInOrgRequest $teams_create_discussion_comment_in_org_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionCommentLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsUpdateDiscussionCommentLegacyRequest($team_id, $discussion_number, $comment_number, $teams_create_discussion_comment_in_org_request, string $contentType = self::contentTypes['teamsUpdateDiscussionCommentLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsUpdateDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsUpdateDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'comment_number' is set
        if ($comment_number === null || (is_array($comment_number) && count($comment_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $comment_number when calling teamsUpdateDiscussionCommentLegacy'
            );
        }

        // verify the required parameter 'teams_create_discussion_comment_in_org_request' is set
        if ($teams_create_discussion_comment_in_org_request === null || (is_array($teams_create_discussion_comment_in_org_request) && count($teams_create_discussion_comment_in_org_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_create_discussion_comment_in_org_request when calling teamsUpdateDiscussionCommentLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }
        // path params
        if ($comment_number !== null) {
            $resourcePath = str_replace(
                '{' . 'comment_number' . '}',
                ObjectSerializer::toPathValue($comment_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_create_discussion_comment_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_create_discussion_comment_in_org_request));
            } else {
                $httpBody = $teams_create_discussion_comment_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdateDiscussionInOrg
     *
     * Update a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion
     */
    public function teamsUpdateDiscussionInOrg($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionInOrg'][0])
    {
        list($response) = $this->teamsUpdateDiscussionInOrgWithHttpInfo($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsUpdateDiscussionInOrgWithHttpInfo
     *
     * Update a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsUpdateDiscussionInOrgWithHttpInfo($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionInOrg'][0])
    {
        $request = $this->teamsUpdateDiscussionInOrgRequest($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateDiscussionInOrgAsync
     *
     * Update a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateDiscussionInOrgAsync($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionInOrg'][0])
    {
        return $this->teamsUpdateDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateDiscussionInOrgAsyncWithHttpInfo
     *
     * Update a discussion
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateDiscussionInOrgAsyncWithHttpInfo($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
        $request = $this->teamsUpdateDiscussionInOrgRequest($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdateDiscussionInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsUpdateDiscussionInOrgRequest($org, $team_slug, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsUpdateDiscussionInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsUpdateDiscussionInOrg'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsUpdateDiscussionInOrg'
            );
        }



        $resourcePath = '/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_update_discussion_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_update_discussion_in_org_request));
            } else {
                $httpBody = $teams_update_discussion_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdateDiscussionLegacy
     *
     * Update a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion
     * @deprecated
     */
    public function teamsUpdateDiscussionLegacy($team_id, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionLegacy'][0])
    {
        list($response) = $this->teamsUpdateDiscussionLegacyWithHttpInfo($team_id, $discussion_number, $teams_update_discussion_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsUpdateDiscussionLegacyWithHttpInfo
     *
     * Update a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsUpdateDiscussionLegacyWithHttpInfo($team_id, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionLegacy'][0])
    {
        $request = $this->teamsUpdateDiscussionLegacyRequest($team_id, $discussion_number, $teams_update_discussion_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateDiscussionLegacyAsync
     *
     * Update a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsUpdateDiscussionLegacyAsync($team_id, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionLegacy'][0])
    {
        return $this->teamsUpdateDiscussionLegacyAsyncWithHttpInfo($team_id, $discussion_number, $teams_update_discussion_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateDiscussionLegacyAsyncWithHttpInfo
     *
     * Update a discussion (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsUpdateDiscussionLegacyAsyncWithHttpInfo($team_id, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamDiscussion';
        $request = $this->teamsUpdateDiscussionLegacyRequest($team_id, $discussion_number, $teams_update_discussion_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdateDiscussionLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  int $discussion_number The number that identifies the discussion. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateDiscussionInOrgRequest $teams_update_discussion_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateDiscussionLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsUpdateDiscussionLegacyRequest($team_id, $discussion_number, $teams_update_discussion_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateDiscussionLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsUpdateDiscussionLegacy'
            );
        }

        // verify the required parameter 'discussion_number' is set
        if ($discussion_number === null || (is_array($discussion_number) && count($discussion_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $discussion_number when calling teamsUpdateDiscussionLegacy'
            );
        }



        $resourcePath = '/teams/{team_id}/discussions/{discussion_number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }
        // path params
        if ($discussion_number !== null) {
            $resourcePath = str_replace(
                '{' . 'discussion_number' . '}',
                ObjectSerializer::toPathValue($discussion_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_update_discussion_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_update_discussion_in_org_request));
            } else {
                $httpBody = $teams_update_discussion_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdateInOrg
     *
     * Update a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateInOrgRequest $teams_update_in_org_request teams_update_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     */
    public function teamsUpdateInOrg($org, $team_slug, $teams_update_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateInOrg'][0])
    {
        list($response) = $this->teamsUpdateInOrgWithHttpInfo($org, $team_slug, $teams_update_in_org_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsUpdateInOrgWithHttpInfo
     *
     * Update a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateInOrgRequest $teams_update_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateInOrg'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     */
    public function teamsUpdateInOrgWithHttpInfo($org, $team_slug, $teams_update_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateInOrg'][0])
    {
        $request = $this->teamsUpdateInOrgRequest($org, $team_slug, $teams_update_in_org_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateInOrgAsync
     *
     * Update a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateInOrgRequest $teams_update_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateInOrgAsync($org, $team_slug, $teams_update_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateInOrg'][0])
    {
        return $this->teamsUpdateInOrgAsyncWithHttpInfo($org, $team_slug, $teams_update_in_org_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateInOrgAsyncWithHttpInfo
     *
     * Update a team
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateInOrgRequest $teams_update_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function teamsUpdateInOrgAsyncWithHttpInfo($org, $team_slug, $teams_update_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateInOrg'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
        $request = $this->teamsUpdateInOrgRequest($org, $team_slug, $teams_update_in_org_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdateInOrg'
     *
     * @param  string $org The organization name. The name is not case sensitive. (required)
     * @param  string $team_slug The slug of the team name. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateInOrgRequest $teams_update_in_org_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateInOrg'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function teamsUpdateInOrgRequest($org, $team_slug, $teams_update_in_org_request = null, string $contentType = self::contentTypes['teamsUpdateInOrg'][0])
    {

        // verify the required parameter 'org' is set
        if ($org === null || (is_array($org) && count($org) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $org when calling teamsUpdateInOrg'
            );
        }

        // verify the required parameter 'team_slug' is set
        if ($team_slug === null || (is_array($team_slug) && count($team_slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_slug when calling teamsUpdateInOrg'
            );
        }



        $resourcePath = '/orgs/{org}/teams/{team_slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($org !== null) {
            $resourcePath = str_replace(
                '{' . 'org' . '}',
                ObjectSerializer::toPathValue($org),
                $resourcePath
            );
        }
        // path params
        if ($team_slug !== null) {
            $resourcePath = str_replace(
                '{' . 'team_slug' . '}',
                ObjectSerializer::toPathValue($team_slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_update_in_org_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_update_in_org_request));
            } else {
                $httpBody = $teams_update_in_org_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation teamsUpdateLegacy
     *
     * Update a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateLegacyRequest $teams_update_legacy_request teams_update_legacy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError
     * @deprecated
     */
    public function teamsUpdateLegacy($team_id, $teams_update_legacy_request, string $contentType = self::contentTypes['teamsUpdateLegacy'][0])
    {
        list($response) = $this->teamsUpdateLegacyWithHttpInfo($team_id, $teams_update_legacy_request, $contentType);
        return $response;
    }

    /**
     * Operation teamsUpdateLegacyWithHttpInfo
     *
     * Update a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateLegacyRequest $teams_update_legacy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateLegacy'] to see the possible values for this operation
     *
     * @throws \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError|\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function teamsUpdateLegacyWithHttpInfo($team_id, $teams_update_legacy_request, string $contentType = self::contentTypes['teamsUpdateLegacy'][0])
    {
        $request = $this->teamsUpdateLegacyRequest($team_id, $teams_update_legacy_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\BasicError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation teamsUpdateLegacyAsync
     *
     * Update a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateLegacyRequest $teams_update_legacy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsUpdateLegacyAsync($team_id, $teams_update_legacy_request, string $contentType = self::contentTypes['teamsUpdateLegacy'][0])
    {
        return $this->teamsUpdateLegacyAsyncWithHttpInfo($team_id, $teams_update_legacy_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation teamsUpdateLegacyAsyncWithHttpInfo
     *
     * Update a team (Legacy)
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateLegacyRequest $teams_update_legacy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function teamsUpdateLegacyAsyncWithHttpInfo($team_id, $teams_update_legacy_request, string $contentType = self::contentTypes['teamsUpdateLegacy'][0])
    {
        $returnType = '\System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamFull';
        $request = $this->teamsUpdateLegacyRequest($team_id, $teams_update_legacy_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'teamsUpdateLegacy'
     *
     * @param  int $team_id The unique identifier of the team. (required)
     * @param  \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model\TeamsUpdateLegacyRequest $teams_update_legacy_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['teamsUpdateLegacy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function teamsUpdateLegacyRequest($team_id, $teams_update_legacy_request, string $contentType = self::contentTypes['teamsUpdateLegacy'][0])
    {

        // verify the required parameter 'team_id' is set
        if ($team_id === null || (is_array($team_id) && count($team_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $team_id when calling teamsUpdateLegacy'
            );
        }

        // verify the required parameter 'teams_update_legacy_request' is set
        if ($teams_update_legacy_request === null || (is_array($teams_update_legacy_request) && count($teams_update_legacy_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $teams_update_legacy_request when calling teamsUpdateLegacy'
            );
        }


        $resourcePath = '/teams/{team_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($team_id !== null) {
            $resourcePath = str_replace(
                '{' . 'team_id' . '}',
                ObjectSerializer::toPathValue($team_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($teams_update_legacy_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($teams_update_legacy_request));
            } else {
                $httpBody = $teams_update_legacy_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
