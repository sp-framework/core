<?php
/**
 * OrgsUpdateRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model;

use \ArrayAccess;
use \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ObjectSerializer;

/**
 * OrgsUpdateRequest Class Doc Comment
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class OrgsUpdateRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'orgs_update_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'billing_email' => 'string',
        'company' => 'string',
        'email' => 'string',
        'twitter_username' => 'string',
        'location' => 'string',
        'name' => 'string',
        'description' => 'string',
        'has_organization_projects' => 'bool',
        'has_repository_projects' => 'bool',
        'default_repository_permission' => 'string',
        'members_can_create_repositories' => 'bool',
        'members_can_create_internal_repositories' => 'bool',
        'members_can_create_private_repositories' => 'bool',
        'members_can_create_public_repositories' => 'bool',
        'members_allowed_repository_creation_type' => 'string',
        'members_can_create_pages' => 'bool',
        'members_can_fork_private_repositories' => 'bool',
        'web_commit_signoff_required' => 'bool',
        'blog' => 'string',
        'advanced_security_enabled_for_new_repositories' => 'bool',
        'dependabot_alerts_enabled_for_new_repositories' => 'bool',
        'dependabot_security_updates_enabled_for_new_repositories' => 'bool',
        'dependency_graph_enabled_for_new_repositories' => 'bool',
        'secret_scanning_enabled_for_new_repositories' => 'bool',
        'secret_scanning_push_protection_enabled_for_new_repositories' => 'bool',
        'secret_scanning_push_protection_custom_link_enabled' => 'bool',
        'secret_scanning_push_protection_custom_link' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'billing_email' => null,
        'company' => null,
        'email' => null,
        'twitter_username' => null,
        'location' => null,
        'name' => null,
        'description' => null,
        'has_organization_projects' => null,
        'has_repository_projects' => null,
        'default_repository_permission' => null,
        'members_can_create_repositories' => null,
        'members_can_create_internal_repositories' => null,
        'members_can_create_private_repositories' => null,
        'members_can_create_public_repositories' => null,
        'members_allowed_repository_creation_type' => null,
        'members_can_create_pages' => null,
        'members_can_fork_private_repositories' => null,
        'web_commit_signoff_required' => null,
        'blog' => null,
        'advanced_security_enabled_for_new_repositories' => null,
        'dependabot_alerts_enabled_for_new_repositories' => null,
        'dependabot_security_updates_enabled_for_new_repositories' => null,
        'dependency_graph_enabled_for_new_repositories' => null,
        'secret_scanning_enabled_for_new_repositories' => null,
        'secret_scanning_push_protection_enabled_for_new_repositories' => null,
        'secret_scanning_push_protection_custom_link_enabled' => null,
        'secret_scanning_push_protection_custom_link' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'billing_email' => false,
        'company' => false,
        'email' => false,
        'twitter_username' => false,
        'location' => false,
        'name' => false,
        'description' => false,
        'has_organization_projects' => false,
        'has_repository_projects' => false,
        'default_repository_permission' => false,
        'members_can_create_repositories' => false,
        'members_can_create_internal_repositories' => false,
        'members_can_create_private_repositories' => false,
        'members_can_create_public_repositories' => false,
        'members_allowed_repository_creation_type' => false,
        'members_can_create_pages' => false,
        'members_can_fork_private_repositories' => false,
        'web_commit_signoff_required' => false,
        'blog' => false,
        'advanced_security_enabled_for_new_repositories' => false,
        'dependabot_alerts_enabled_for_new_repositories' => false,
        'dependabot_security_updates_enabled_for_new_repositories' => false,
        'dependency_graph_enabled_for_new_repositories' => false,
        'secret_scanning_enabled_for_new_repositories' => false,
        'secret_scanning_push_protection_enabled_for_new_repositories' => false,
        'secret_scanning_push_protection_custom_link_enabled' => false,
        'secret_scanning_push_protection_custom_link' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'billing_email' => 'billing_email',
        'company' => 'company',
        'email' => 'email',
        'twitter_username' => 'twitter_username',
        'location' => 'location',
        'name' => 'name',
        'description' => 'description',
        'has_organization_projects' => 'has_organization_projects',
        'has_repository_projects' => 'has_repository_projects',
        'default_repository_permission' => 'default_repository_permission',
        'members_can_create_repositories' => 'members_can_create_repositories',
        'members_can_create_internal_repositories' => 'members_can_create_internal_repositories',
        'members_can_create_private_repositories' => 'members_can_create_private_repositories',
        'members_can_create_public_repositories' => 'members_can_create_public_repositories',
        'members_allowed_repository_creation_type' => 'members_allowed_repository_creation_type',
        'members_can_create_pages' => 'members_can_create_pages',
        'members_can_fork_private_repositories' => 'members_can_fork_private_repositories',
        'web_commit_signoff_required' => 'web_commit_signoff_required',
        'blog' => 'blog',
        'advanced_security_enabled_for_new_repositories' => 'advanced_security_enabled_for_new_repositories',
        'dependabot_alerts_enabled_for_new_repositories' => 'dependabot_alerts_enabled_for_new_repositories',
        'dependabot_security_updates_enabled_for_new_repositories' => 'dependabot_security_updates_enabled_for_new_repositories',
        'dependency_graph_enabled_for_new_repositories' => 'dependency_graph_enabled_for_new_repositories',
        'secret_scanning_enabled_for_new_repositories' => 'secret_scanning_enabled_for_new_repositories',
        'secret_scanning_push_protection_enabled_for_new_repositories' => 'secret_scanning_push_protection_enabled_for_new_repositories',
        'secret_scanning_push_protection_custom_link_enabled' => 'secret_scanning_push_protection_custom_link_enabled',
        'secret_scanning_push_protection_custom_link' => 'secret_scanning_push_protection_custom_link'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'billing_email' => 'setBillingEmail',
        'company' => 'setCompany',
        'email' => 'setEmail',
        'twitter_username' => 'setTwitterUsername',
        'location' => 'setLocation',
        'name' => 'setName',
        'description' => 'setDescription',
        'has_organization_projects' => 'setHasOrganizationProjects',
        'has_repository_projects' => 'setHasRepositoryProjects',
        'default_repository_permission' => 'setDefaultRepositoryPermission',
        'members_can_create_repositories' => 'setMembersCanCreateRepositories',
        'members_can_create_internal_repositories' => 'setMembersCanCreateInternalRepositories',
        'members_can_create_private_repositories' => 'setMembersCanCreatePrivateRepositories',
        'members_can_create_public_repositories' => 'setMembersCanCreatePublicRepositories',
        'members_allowed_repository_creation_type' => 'setMembersAllowedRepositoryCreationType',
        'members_can_create_pages' => 'setMembersCanCreatePages',
        'members_can_fork_private_repositories' => 'setMembersCanForkPrivateRepositories',
        'web_commit_signoff_required' => 'setWebCommitSignoffRequired',
        'blog' => 'setBlog',
        'advanced_security_enabled_for_new_repositories' => 'setAdvancedSecurityEnabledForNewRepositories',
        'dependabot_alerts_enabled_for_new_repositories' => 'setDependabotAlertsEnabledForNewRepositories',
        'dependabot_security_updates_enabled_for_new_repositories' => 'setDependabotSecurityUpdatesEnabledForNewRepositories',
        'dependency_graph_enabled_for_new_repositories' => 'setDependencyGraphEnabledForNewRepositories',
        'secret_scanning_enabled_for_new_repositories' => 'setSecretScanningEnabledForNewRepositories',
        'secret_scanning_push_protection_enabled_for_new_repositories' => 'setSecretScanningPushProtectionEnabledForNewRepositories',
        'secret_scanning_push_protection_custom_link_enabled' => 'setSecretScanningPushProtectionCustomLinkEnabled',
        'secret_scanning_push_protection_custom_link' => 'setSecretScanningPushProtectionCustomLink'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'billing_email' => 'getBillingEmail',
        'company' => 'getCompany',
        'email' => 'getEmail',
        'twitter_username' => 'getTwitterUsername',
        'location' => 'getLocation',
        'name' => 'getName',
        'description' => 'getDescription',
        'has_organization_projects' => 'getHasOrganizationProjects',
        'has_repository_projects' => 'getHasRepositoryProjects',
        'default_repository_permission' => 'getDefaultRepositoryPermission',
        'members_can_create_repositories' => 'getMembersCanCreateRepositories',
        'members_can_create_internal_repositories' => 'getMembersCanCreateInternalRepositories',
        'members_can_create_private_repositories' => 'getMembersCanCreatePrivateRepositories',
        'members_can_create_public_repositories' => 'getMembersCanCreatePublicRepositories',
        'members_allowed_repository_creation_type' => 'getMembersAllowedRepositoryCreationType',
        'members_can_create_pages' => 'getMembersCanCreatePages',
        'members_can_fork_private_repositories' => 'getMembersCanForkPrivateRepositories',
        'web_commit_signoff_required' => 'getWebCommitSignoffRequired',
        'blog' => 'getBlog',
        'advanced_security_enabled_for_new_repositories' => 'getAdvancedSecurityEnabledForNewRepositories',
        'dependabot_alerts_enabled_for_new_repositories' => 'getDependabotAlertsEnabledForNewRepositories',
        'dependabot_security_updates_enabled_for_new_repositories' => 'getDependabotSecurityUpdatesEnabledForNewRepositories',
        'dependency_graph_enabled_for_new_repositories' => 'getDependencyGraphEnabledForNewRepositories',
        'secret_scanning_enabled_for_new_repositories' => 'getSecretScanningEnabledForNewRepositories',
        'secret_scanning_push_protection_enabled_for_new_repositories' => 'getSecretScanningPushProtectionEnabledForNewRepositories',
        'secret_scanning_push_protection_custom_link_enabled' => 'getSecretScanningPushProtectionCustomLinkEnabled',
        'secret_scanning_push_protection_custom_link' => 'getSecretScanningPushProtectionCustomLink'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const DEFAULT_REPOSITORY_PERMISSION_READ = 'read';
    public const DEFAULT_REPOSITORY_PERMISSION_WRITE = 'write';
    public const DEFAULT_REPOSITORY_PERMISSION_ADMIN = 'admin';
    public const DEFAULT_REPOSITORY_PERMISSION_NONE = 'none';
    public const MEMBERS_ALLOWED_REPOSITORY_CREATION_TYPE_ALL = 'all';
    public const MEMBERS_ALLOWED_REPOSITORY_CREATION_TYPE__PRIVATE = 'private';
    public const MEMBERS_ALLOWED_REPOSITORY_CREATION_TYPE_NONE = 'none';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDefaultRepositoryPermissionAllowableValues()
    {
        return [
            self::DEFAULT_REPOSITORY_PERMISSION_READ,
            self::DEFAULT_REPOSITORY_PERMISSION_WRITE,
            self::DEFAULT_REPOSITORY_PERMISSION_ADMIN,
            self::DEFAULT_REPOSITORY_PERMISSION_NONE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMembersAllowedRepositoryCreationTypeAllowableValues()
    {
        return [
            self::MEMBERS_ALLOWED_REPOSITORY_CREATION_TYPE_ALL,
            self::MEMBERS_ALLOWED_REPOSITORY_CREATION_TYPE__PRIVATE,
            self::MEMBERS_ALLOWED_REPOSITORY_CREATION_TYPE_NONE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('billing_email', $data ?? [], null);
        $this->setIfExists('company', $data ?? [], null);
        $this->setIfExists('email', $data ?? [], null);
        $this->setIfExists('twitter_username', $data ?? [], null);
        $this->setIfExists('location', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('has_organization_projects', $data ?? [], null);
        $this->setIfExists('has_repository_projects', $data ?? [], null);
        $this->setIfExists('default_repository_permission', $data ?? [], 'read');
        $this->setIfExists('members_can_create_repositories', $data ?? [], true);
        $this->setIfExists('members_can_create_internal_repositories', $data ?? [], null);
        $this->setIfExists('members_can_create_private_repositories', $data ?? [], null);
        $this->setIfExists('members_can_create_public_repositories', $data ?? [], null);
        $this->setIfExists('members_allowed_repository_creation_type', $data ?? [], null);
        $this->setIfExists('members_can_create_pages', $data ?? [], true);
        $this->setIfExists('members_can_fork_private_repositories', $data ?? [], false);
        $this->setIfExists('web_commit_signoff_required', $data ?? [], false);
        $this->setIfExists('blog', $data ?? [], null);
        $this->setIfExists('advanced_security_enabled_for_new_repositories', $data ?? [], null);
        $this->setIfExists('dependabot_alerts_enabled_for_new_repositories', $data ?? [], null);
        $this->setIfExists('dependabot_security_updates_enabled_for_new_repositories', $data ?? [], null);
        $this->setIfExists('dependency_graph_enabled_for_new_repositories', $data ?? [], null);
        $this->setIfExists('secret_scanning_enabled_for_new_repositories', $data ?? [], null);
        $this->setIfExists('secret_scanning_push_protection_enabled_for_new_repositories', $data ?? [], null);
        $this->setIfExists('secret_scanning_push_protection_custom_link_enabled', $data ?? [], null);
        $this->setIfExists('secret_scanning_push_protection_custom_link', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDefaultRepositoryPermissionAllowableValues();
        if (!is_null($this->container['default_repository_permission']) && !in_array($this->container['default_repository_permission'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'default_repository_permission', must be one of '%s'",
                $this->container['default_repository_permission'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getMembersAllowedRepositoryCreationTypeAllowableValues();
        if (!is_null($this->container['members_allowed_repository_creation_type']) && !in_array($this->container['members_allowed_repository_creation_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'members_allowed_repository_creation_type', must be one of '%s'",
                $this->container['members_allowed_repository_creation_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets billing_email
     *
     * @return string|null
     */
    public function getBillingEmail()
    {
        return $this->container['billing_email'];
    }

    /**
     * Sets billing_email
     *
     * @param string|null $billing_email Billing email address. This address is not publicized.
     *
     * @return self
     */
    public function setBillingEmail($billing_email)
    {
        if (is_null($billing_email)) {
            throw new \InvalidArgumentException('non-nullable billing_email cannot be null');
        }
        $this->container['billing_email'] = $billing_email;

        return $this;
    }

    /**
     * Gets company
     *
     * @return string|null
     */
    public function getCompany()
    {
        return $this->container['company'];
    }

    /**
     * Sets company
     *
     * @param string|null $company The company name.
     *
     * @return self
     */
    public function setCompany($company)
    {
        if (is_null($company)) {
            throw new \InvalidArgumentException('non-nullable company cannot be null');
        }
        $this->container['company'] = $company;

        return $this;
    }

    /**
     * Gets email
     *
     * @return string|null
     */
    public function getEmail()
    {
        return $this->container['email'];
    }

    /**
     * Sets email
     *
     * @param string|null $email The publicly visible email address.
     *
     * @return self
     */
    public function setEmail($email)
    {
        if (is_null($email)) {
            throw new \InvalidArgumentException('non-nullable email cannot be null');
        }
        $this->container['email'] = $email;

        return $this;
    }

    /**
     * Gets twitter_username
     *
     * @return string|null
     */
    public function getTwitterUsername()
    {
        return $this->container['twitter_username'];
    }

    /**
     * Sets twitter_username
     *
     * @param string|null $twitter_username The Twitter username of the company.
     *
     * @return self
     */
    public function setTwitterUsername($twitter_username)
    {
        if (is_null($twitter_username)) {
            throw new \InvalidArgumentException('non-nullable twitter_username cannot be null');
        }
        $this->container['twitter_username'] = $twitter_username;

        return $this;
    }

    /**
     * Gets location
     *
     * @return string|null
     */
    public function getLocation()
    {
        return $this->container['location'];
    }

    /**
     * Sets location
     *
     * @param string|null $location The location.
     *
     * @return self
     */
    public function setLocation($location)
    {
        if (is_null($location)) {
            throw new \InvalidArgumentException('non-nullable location cannot be null');
        }
        $this->container['location'] = $location;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The shorthand name of the company.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description The description of the company. The maximum size is 160 characters.
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            throw new \InvalidArgumentException('non-nullable description cannot be null');
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets has_organization_projects
     *
     * @return bool|null
     */
    public function getHasOrganizationProjects()
    {
        return $this->container['has_organization_projects'];
    }

    /**
     * Sets has_organization_projects
     *
     * @param bool|null $has_organization_projects Whether an organization can use organization projects.
     *
     * @return self
     */
    public function setHasOrganizationProjects($has_organization_projects)
    {
        if (is_null($has_organization_projects)) {
            throw new \InvalidArgumentException('non-nullable has_organization_projects cannot be null');
        }
        $this->container['has_organization_projects'] = $has_organization_projects;

        return $this;
    }

    /**
     * Gets has_repository_projects
     *
     * @return bool|null
     */
    public function getHasRepositoryProjects()
    {
        return $this->container['has_repository_projects'];
    }

    /**
     * Sets has_repository_projects
     *
     * @param bool|null $has_repository_projects Whether repositories that belong to the organization can use repository projects.
     *
     * @return self
     */
    public function setHasRepositoryProjects($has_repository_projects)
    {
        if (is_null($has_repository_projects)) {
            throw new \InvalidArgumentException('non-nullable has_repository_projects cannot be null');
        }
        $this->container['has_repository_projects'] = $has_repository_projects;

        return $this;
    }

    /**
     * Gets default_repository_permission
     *
     * @return string|null
     */
    public function getDefaultRepositoryPermission()
    {
        return $this->container['default_repository_permission'];
    }

    /**
     * Sets default_repository_permission
     *
     * @param string|null $default_repository_permission Default permission level members have for organization repositories.
     *
     * @return self
     */
    public function setDefaultRepositoryPermission($default_repository_permission)
    {
        if (is_null($default_repository_permission)) {
            throw new \InvalidArgumentException('non-nullable default_repository_permission cannot be null');
        }
        $allowedValues = $this->getDefaultRepositoryPermissionAllowableValues();
        if (!in_array($default_repository_permission, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'default_repository_permission', must be one of '%s'",
                    $default_repository_permission,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['default_repository_permission'] = $default_repository_permission;

        return $this;
    }

    /**
     * Gets members_can_create_repositories
     *
     * @return bool|null
     */
    public function getMembersCanCreateRepositories()
    {
        return $this->container['members_can_create_repositories'];
    }

    /**
     * Sets members_can_create_repositories
     *
     * @param bool|null $members_can_create_repositories Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.
     *
     * @return self
     */
    public function setMembersCanCreateRepositories($members_can_create_repositories)
    {
        if (is_null($members_can_create_repositories)) {
            throw new \InvalidArgumentException('non-nullable members_can_create_repositories cannot be null');
        }
        $this->container['members_can_create_repositories'] = $members_can_create_repositories;

        return $this;
    }

    /**
     * Gets members_can_create_internal_repositories
     *
     * @return bool|null
     */
    public function getMembersCanCreateInternalRepositories()
    {
        return $this->container['members_can_create_internal_repositories'];
    }

    /**
     * Sets members_can_create_internal_repositories
     *
     * @param bool|null $members_can_create_internal_repositories Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/enterprise-server@3.12/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.
     *
     * @return self
     */
    public function setMembersCanCreateInternalRepositories($members_can_create_internal_repositories)
    {
        if (is_null($members_can_create_internal_repositories)) {
            throw new \InvalidArgumentException('non-nullable members_can_create_internal_repositories cannot be null');
        }
        $this->container['members_can_create_internal_repositories'] = $members_can_create_internal_repositories;

        return $this;
    }

    /**
     * Gets members_can_create_private_repositories
     *
     * @return bool|null
     */
    public function getMembersCanCreatePrivateRepositories()
    {
        return $this->container['members_can_create_private_repositories'];
    }

    /**
     * Sets members_can_create_private_repositories
     *
     * @param bool|null $members_can_create_private_repositories Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/enterprise-server@3.12/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.
     *
     * @return self
     */
    public function setMembersCanCreatePrivateRepositories($members_can_create_private_repositories)
    {
        if (is_null($members_can_create_private_repositories)) {
            throw new \InvalidArgumentException('non-nullable members_can_create_private_repositories cannot be null');
        }
        $this->container['members_can_create_private_repositories'] = $members_can_create_private_repositories;

        return $this;
    }

    /**
     * Gets members_can_create_public_repositories
     *
     * @return bool|null
     */
    public function getMembersCanCreatePublicRepositories()
    {
        return $this->container['members_can_create_public_repositories'];
    }

    /**
     * Sets members_can_create_public_repositories
     *
     * @param bool|null $members_can_create_public_repositories Whether organization members can create public repositories, which are visible to anyone. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/enterprise-server@3.12/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.
     *
     * @return self
     */
    public function setMembersCanCreatePublicRepositories($members_can_create_public_repositories)
    {
        if (is_null($members_can_create_public_repositories)) {
            throw new \InvalidArgumentException('non-nullable members_can_create_public_repositories cannot be null');
        }
        $this->container['members_can_create_public_repositories'] = $members_can_create_public_repositories;

        return $this;
    }

    /**
     * Gets members_allowed_repository_creation_type
     *
     * @return string|null
     */
    public function getMembersAllowedRepositoryCreationType()
    {
        return $this->container['members_allowed_repository_creation_type'];
    }

    /**
     * Sets members_allowed_repository_creation_type
     *
     * @param string|null $members_allowed_repository_creation_type Specifies which types of repositories non-admin organization members can create.  **Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
     *
     * @return self
     */
    public function setMembersAllowedRepositoryCreationType($members_allowed_repository_creation_type)
    {
        if (is_null($members_allowed_repository_creation_type)) {
            throw new \InvalidArgumentException('non-nullable members_allowed_repository_creation_type cannot be null');
        }
        $allowedValues = $this->getMembersAllowedRepositoryCreationTypeAllowableValues();
        if (!in_array($members_allowed_repository_creation_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'members_allowed_repository_creation_type', must be one of '%s'",
                    $members_allowed_repository_creation_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['members_allowed_repository_creation_type'] = $members_allowed_repository_creation_type;

        return $this;
    }

    /**
     * Gets members_can_create_pages
     *
     * @return bool|null
     */
    public function getMembersCanCreatePages()
    {
        return $this->container['members_can_create_pages'];
    }

    /**
     * Sets members_can_create_pages
     *
     * @param bool|null $members_can_create_pages Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
     *
     * @return self
     */
    public function setMembersCanCreatePages($members_can_create_pages)
    {
        if (is_null($members_can_create_pages)) {
            throw new \InvalidArgumentException('non-nullable members_can_create_pages cannot be null');
        }
        $this->container['members_can_create_pages'] = $members_can_create_pages;

        return $this;
    }

    /**
     * Gets members_can_fork_private_repositories
     *
     * @return bool|null
     */
    public function getMembersCanForkPrivateRepositories()
    {
        return $this->container['members_can_fork_private_repositories'];
    }

    /**
     * Sets members_can_fork_private_repositories
     *
     * @param bool|null $members_can_fork_private_repositories Whether organization members can fork private organization repositories.
     *
     * @return self
     */
    public function setMembersCanForkPrivateRepositories($members_can_fork_private_repositories)
    {
        if (is_null($members_can_fork_private_repositories)) {
            throw new \InvalidArgumentException('non-nullable members_can_fork_private_repositories cannot be null');
        }
        $this->container['members_can_fork_private_repositories'] = $members_can_fork_private_repositories;

        return $this;
    }

    /**
     * Gets web_commit_signoff_required
     *
     * @return bool|null
     */
    public function getWebCommitSignoffRequired()
    {
        return $this->container['web_commit_signoff_required'];
    }

    /**
     * Sets web_commit_signoff_required
     *
     * @param bool|null $web_commit_signoff_required Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
     *
     * @return self
     */
    public function setWebCommitSignoffRequired($web_commit_signoff_required)
    {
        if (is_null($web_commit_signoff_required)) {
            throw new \InvalidArgumentException('non-nullable web_commit_signoff_required cannot be null');
        }
        $this->container['web_commit_signoff_required'] = $web_commit_signoff_required;

        return $this;
    }

    /**
     * Gets blog
     *
     * @return string|null
     */
    public function getBlog()
    {
        return $this->container['blog'];
    }

    /**
     * Sets blog
     *
     * @param string|null $blog blog
     *
     * @return self
     */
    public function setBlog($blog)
    {
        if (is_null($blog)) {
            throw new \InvalidArgumentException('non-nullable blog cannot be null');
        }
        $this->container['blog'] = $blog;

        return $this;
    }

    /**
     * Gets advanced_security_enabled_for_new_repositories
     *
     * @return bool|null
     */
    public function getAdvancedSecurityEnabledForNewRepositories()
    {
        return $this->container['advanced_security_enabled_for_new_repositories'];
    }

    /**
     * Sets advanced_security_enabled_for_new_repositories
     *
     * @param bool|null $advanced_security_enabled_for_new_repositories Whether GitHub Advanced Security is automatically enabled for new repositories.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.12/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
     *
     * @return self
     */
    public function setAdvancedSecurityEnabledForNewRepositories($advanced_security_enabled_for_new_repositories)
    {
        if (is_null($advanced_security_enabled_for_new_repositories)) {
            throw new \InvalidArgumentException('non-nullable advanced_security_enabled_for_new_repositories cannot be null');
        }
        $this->container['advanced_security_enabled_for_new_repositories'] = $advanced_security_enabled_for_new_repositories;

        return $this;
    }

    /**
     * Gets dependabot_alerts_enabled_for_new_repositories
     *
     * @return bool|null
     */
    public function getDependabotAlertsEnabledForNewRepositories()
    {
        return $this->container['dependabot_alerts_enabled_for_new_repositories'];
    }

    /**
     * Sets dependabot_alerts_enabled_for_new_repositories
     *
     * @param bool|null $dependabot_alerts_enabled_for_new_repositories Whether Dependabot alerts is automatically enabled for new repositories.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.12/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
     *
     * @return self
     */
    public function setDependabotAlertsEnabledForNewRepositories($dependabot_alerts_enabled_for_new_repositories)
    {
        if (is_null($dependabot_alerts_enabled_for_new_repositories)) {
            throw new \InvalidArgumentException('non-nullable dependabot_alerts_enabled_for_new_repositories cannot be null');
        }
        $this->container['dependabot_alerts_enabled_for_new_repositories'] = $dependabot_alerts_enabled_for_new_repositories;

        return $this;
    }

    /**
     * Gets dependabot_security_updates_enabled_for_new_repositories
     *
     * @return bool|null
     */
    public function getDependabotSecurityUpdatesEnabledForNewRepositories()
    {
        return $this->container['dependabot_security_updates_enabled_for_new_repositories'];
    }

    /**
     * Sets dependabot_security_updates_enabled_for_new_repositories
     *
     * @param bool|null $dependabot_security_updates_enabled_for_new_repositories Whether Dependabot security updates is automatically enabled for new repositories.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.12/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
     *
     * @return self
     */
    public function setDependabotSecurityUpdatesEnabledForNewRepositories($dependabot_security_updates_enabled_for_new_repositories)
    {
        if (is_null($dependabot_security_updates_enabled_for_new_repositories)) {
            throw new \InvalidArgumentException('non-nullable dependabot_security_updates_enabled_for_new_repositories cannot be null');
        }
        $this->container['dependabot_security_updates_enabled_for_new_repositories'] = $dependabot_security_updates_enabled_for_new_repositories;

        return $this;
    }

    /**
     * Gets dependency_graph_enabled_for_new_repositories
     *
     * @return bool|null
     */
    public function getDependencyGraphEnabledForNewRepositories()
    {
        return $this->container['dependency_graph_enabled_for_new_repositories'];
    }

    /**
     * Sets dependency_graph_enabled_for_new_repositories
     *
     * @param bool|null $dependency_graph_enabled_for_new_repositories Whether dependency graph is automatically enabled for new repositories.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.12/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
     *
     * @return self
     */
    public function setDependencyGraphEnabledForNewRepositories($dependency_graph_enabled_for_new_repositories)
    {
        if (is_null($dependency_graph_enabled_for_new_repositories)) {
            throw new \InvalidArgumentException('non-nullable dependency_graph_enabled_for_new_repositories cannot be null');
        }
        $this->container['dependency_graph_enabled_for_new_repositories'] = $dependency_graph_enabled_for_new_repositories;

        return $this;
    }

    /**
     * Gets secret_scanning_enabled_for_new_repositories
     *
     * @return bool|null
     */
    public function getSecretScanningEnabledForNewRepositories()
    {
        return $this->container['secret_scanning_enabled_for_new_repositories'];
    }

    /**
     * Sets secret_scanning_enabled_for_new_repositories
     *
     * @param bool|null $secret_scanning_enabled_for_new_repositories Whether secret scanning is automatically enabled for new repositories.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.12/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
     *
     * @return self
     */
    public function setSecretScanningEnabledForNewRepositories($secret_scanning_enabled_for_new_repositories)
    {
        if (is_null($secret_scanning_enabled_for_new_repositories)) {
            throw new \InvalidArgumentException('non-nullable secret_scanning_enabled_for_new_repositories cannot be null');
        }
        $this->container['secret_scanning_enabled_for_new_repositories'] = $secret_scanning_enabled_for_new_repositories;

        return $this;
    }

    /**
     * Gets secret_scanning_push_protection_enabled_for_new_repositories
     *
     * @return bool|null
     */
    public function getSecretScanningPushProtectionEnabledForNewRepositories()
    {
        return $this->container['secret_scanning_push_protection_enabled_for_new_repositories'];
    }

    /**
     * Sets secret_scanning_push_protection_enabled_for_new_repositories
     *
     * @param bool|null $secret_scanning_push_protection_enabled_for_new_repositories Whether secret scanning push protection is automatically enabled for new repositories.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.12/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
     *
     * @return self
     */
    public function setSecretScanningPushProtectionEnabledForNewRepositories($secret_scanning_push_protection_enabled_for_new_repositories)
    {
        if (is_null($secret_scanning_push_protection_enabled_for_new_repositories)) {
            throw new \InvalidArgumentException('non-nullable secret_scanning_push_protection_enabled_for_new_repositories cannot be null');
        }
        $this->container['secret_scanning_push_protection_enabled_for_new_repositories'] = $secret_scanning_push_protection_enabled_for_new_repositories;

        return $this;
    }

    /**
     * Gets secret_scanning_push_protection_custom_link_enabled
     *
     * @return bool|null
     */
    public function getSecretScanningPushProtectionCustomLinkEnabled()
    {
        return $this->container['secret_scanning_push_protection_custom_link_enabled'];
    }

    /**
     * Sets secret_scanning_push_protection_custom_link_enabled
     *
     * @param bool|null $secret_scanning_push_protection_custom_link_enabled Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
     *
     * @return self
     */
    public function setSecretScanningPushProtectionCustomLinkEnabled($secret_scanning_push_protection_custom_link_enabled)
    {
        if (is_null($secret_scanning_push_protection_custom_link_enabled)) {
            throw new \InvalidArgumentException('non-nullable secret_scanning_push_protection_custom_link_enabled cannot be null');
        }
        $this->container['secret_scanning_push_protection_custom_link_enabled'] = $secret_scanning_push_protection_custom_link_enabled;

        return $this;
    }

    /**
     * Gets secret_scanning_push_protection_custom_link
     *
     * @return string|null
     */
    public function getSecretScanningPushProtectionCustomLink()
    {
        return $this->container['secret_scanning_push_protection_custom_link'];
    }

    /**
     * Sets secret_scanning_push_protection_custom_link
     *
     * @param string|null $secret_scanning_push_protection_custom_link If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.
     *
     * @return self
     */
    public function setSecretScanningPushProtectionCustomLink($secret_scanning_push_protection_custom_link)
    {
        if (is_null($secret_scanning_push_protection_custom_link)) {
            throw new \InvalidArgumentException('non-nullable secret_scanning_push_protection_custom_link cannot be null');
        }
        $this->container['secret_scanning_push_protection_custom_link'] = $secret_scanning_push_protection_custom_link;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


