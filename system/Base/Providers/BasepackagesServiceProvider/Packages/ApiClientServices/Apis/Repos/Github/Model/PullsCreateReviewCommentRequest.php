<?php
/**
 * PullsCreateReviewCommentRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * The version of the OpenAPI document: 1.1.4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\Model;

use \ArrayAccess;
use \System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github\ObjectSerializer;

/**
 * PullsCreateReviewCommentRequest Class Doc Comment
 *
 * @category Class
 * @package  System\Base\Providers\BasepackagesServiceProvider\Packages\ApiClientServices\Apis\Repos\Github
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class PullsCreateReviewCommentRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'pulls_create_review_comment_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'body' => 'string',
        'commit_id' => 'string',
        'path' => 'string',
        'position' => 'int',
        'side' => 'string',
        'line' => 'int',
        'start_line' => 'int',
        'start_side' => 'string',
        'in_reply_to' => 'int',
        'subject_type' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'body' => null,
        'commit_id' => null,
        'path' => null,
        'position' => null,
        'side' => null,
        'line' => null,
        'start_line' => null,
        'start_side' => null,
        'in_reply_to' => null,
        'subject_type' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'body' => false,
        'commit_id' => false,
        'path' => false,
        'position' => false,
        'side' => false,
        'line' => false,
        'start_line' => false,
        'start_side' => false,
        'in_reply_to' => false,
        'subject_type' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'body' => 'body',
        'commit_id' => 'commit_id',
        'path' => 'path',
        'position' => 'position',
        'side' => 'side',
        'line' => 'line',
        'start_line' => 'start_line',
        'start_side' => 'start_side',
        'in_reply_to' => 'in_reply_to',
        'subject_type' => 'subject_type'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'body' => 'setBody',
        'commit_id' => 'setCommitId',
        'path' => 'setPath',
        'position' => 'setPosition',
        'side' => 'setSide',
        'line' => 'setLine',
        'start_line' => 'setStartLine',
        'start_side' => 'setStartSide',
        'in_reply_to' => 'setInReplyTo',
        'subject_type' => 'setSubjectType'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'body' => 'getBody',
        'commit_id' => 'getCommitId',
        'path' => 'getPath',
        'position' => 'getPosition',
        'side' => 'getSide',
        'line' => 'getLine',
        'start_line' => 'getStartLine',
        'start_side' => 'getStartSide',
        'in_reply_to' => 'getInReplyTo',
        'subject_type' => 'getSubjectType'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SIDE_LEFT = 'LEFT';
    public const SIDE_RIGHT = 'RIGHT';
    public const START_SIDE_LEFT = 'LEFT';
    public const START_SIDE_RIGHT = 'RIGHT';
    public const START_SIDE_SIDE = 'side';
    public const SUBJECT_TYPE_LINE = 'line';
    public const SUBJECT_TYPE_FILE = 'file';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSideAllowableValues()
    {
        return [
            self::SIDE_LEFT,
            self::SIDE_RIGHT,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStartSideAllowableValues()
    {
        return [
            self::START_SIDE_LEFT,
            self::START_SIDE_RIGHT,
            self::START_SIDE_SIDE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSubjectTypeAllowableValues()
    {
        return [
            self::SUBJECT_TYPE_LINE,
            self::SUBJECT_TYPE_FILE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('body', $data ?? [], null);
        $this->setIfExists('commit_id', $data ?? [], null);
        $this->setIfExists('path', $data ?? [], null);
        $this->setIfExists('position', $data ?? [], null);
        $this->setIfExists('side', $data ?? [], null);
        $this->setIfExists('line', $data ?? [], null);
        $this->setIfExists('start_line', $data ?? [], null);
        $this->setIfExists('start_side', $data ?? [], null);
        $this->setIfExists('in_reply_to', $data ?? [], null);
        $this->setIfExists('subject_type', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['body'] === null) {
            $invalidProperties[] = "'body' can't be null";
        }
        if ($this->container['commit_id'] === null) {
            $invalidProperties[] = "'commit_id' can't be null";
        }
        if ($this->container['path'] === null) {
            $invalidProperties[] = "'path' can't be null";
        }
        $allowedValues = $this->getSideAllowableValues();
        if (!is_null($this->container['side']) && !in_array($this->container['side'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'side', must be one of '%s'",
                $this->container['side'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStartSideAllowableValues();
        if (!is_null($this->container['start_side']) && !in_array($this->container['start_side'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'start_side', must be one of '%s'",
                $this->container['start_side'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSubjectTypeAllowableValues();
        if (!is_null($this->container['subject_type']) && !in_array($this->container['subject_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'subject_type', must be one of '%s'",
                $this->container['subject_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets body
     *
     * @return string
     */
    public function getBody()
    {
        return $this->container['body'];
    }

    /**
     * Sets body
     *
     * @param string $body The text of the review comment.
     *
     * @return self
     */
    public function setBody($body)
    {
        if (is_null($body)) {
            throw new \InvalidArgumentException('non-nullable body cannot be null');
        }
        $this->container['body'] = $body;

        return $this;
    }

    /**
     * Gets commit_id
     *
     * @return string
     */
    public function getCommitId()
    {
        return $this->container['commit_id'];
    }

    /**
     * Sets commit_id
     *
     * @param string $commit_id The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.
     *
     * @return self
     */
    public function setCommitId($commit_id)
    {
        if (is_null($commit_id)) {
            throw new \InvalidArgumentException('non-nullable commit_id cannot be null');
        }
        $this->container['commit_id'] = $commit_id;

        return $this;
    }

    /**
     * Gets path
     *
     * @return string
     */
    public function getPath()
    {
        return $this->container['path'];
    }

    /**
     * Sets path
     *
     * @param string $path The relative path to the file that necessitates a comment.
     *
     * @return self
     */
    public function setPath($path)
    {
        if (is_null($path)) {
            throw new \InvalidArgumentException('non-nullable path cannot be null');
        }
        $this->container['path'] = $path;

        return $this;
    }

    /**
     * Gets position
     *
     * @return int|null
     * @deprecated
     */
    public function getPosition()
    {
        return $this->container['position'];
    }

    /**
     * Sets position
     *
     * @param int|null $position **This parameter is deprecated. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
     *
     * @return self
     * @deprecated
     */
    public function setPosition($position)
    {
        if (is_null($position)) {
            throw new \InvalidArgumentException('non-nullable position cannot be null');
        }
        $this->container['position'] = $position;

        return $this;
    }

    /**
     * Gets side
     *
     * @return string|null
     */
    public function getSide()
    {
        return $this->container['side'];
    }

    /**
     * Sets side
     *
     * @param string|null $side In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see \"[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)\" in the GitHub Help documentation.
     *
     * @return self
     */
    public function setSide($side)
    {
        if (is_null($side)) {
            throw new \InvalidArgumentException('non-nullable side cannot be null');
        }
        $allowedValues = $this->getSideAllowableValues();
        if (!in_array($side, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'side', must be one of '%s'",
                    $side,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['side'] = $side;

        return $this;
    }

    /**
     * Gets line
     *
     * @return int|null
     */
    public function getLine()
    {
        return $this->container['line'];
    }

    /**
     * Sets line
     *
     * @param int|null $line **Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.
     *
     * @return self
     */
    public function setLine($line)
    {
        if (is_null($line)) {
            throw new \InvalidArgumentException('non-nullable line cannot be null');
        }
        $this->container['line'] = $line;

        return $this;
    }

    /**
     * Gets start_line
     *
     * @return int|null
     */
    public function getStartLine()
    {
        return $this->container['start_line'];
    }

    /**
     * Sets start_line
     *
     * @param int|null $start_line **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation.
     *
     * @return self
     */
    public function setStartLine($start_line)
    {
        if (is_null($start_line)) {
            throw new \InvalidArgumentException('non-nullable start_line cannot be null');
        }
        $this->container['start_line'] = $start_line;

        return $this;
    }

    /**
     * Gets start_side
     *
     * @return string|null
     */
    public function getStartSide()
    {
        return $this->container['start_side'];
    }

    /**
     * Sets start_side
     *
     * @param string|null $start_side **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation. See `side` in this table for additional context.
     *
     * @return self
     */
    public function setStartSide($start_side)
    {
        if (is_null($start_side)) {
            throw new \InvalidArgumentException('non-nullable start_side cannot be null');
        }
        $allowedValues = $this->getStartSideAllowableValues();
        if (!in_array($start_side, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'start_side', must be one of '%s'",
                    $start_side,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['start_side'] = $start_side;

        return $this;
    }

    /**
     * Gets in_reply_to
     *
     * @return int|null
     */
    public function getInReplyTo()
    {
        return $this->container['in_reply_to'];
    }

    /**
     * Sets in_reply_to
     *
     * @param int|null $in_reply_to The ID of the review comment to reply to. To find the ID of a review comment with [\"List review comments on a pull request\"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.
     *
     * @return self
     */
    public function setInReplyTo($in_reply_to)
    {
        if (is_null($in_reply_to)) {
            throw new \InvalidArgumentException('non-nullable in_reply_to cannot be null');
        }
        $this->container['in_reply_to'] = $in_reply_to;

        return $this;
    }

    /**
     * Gets subject_type
     *
     * @return string|null
     */
    public function getSubjectType()
    {
        return $this->container['subject_type'];
    }

    /**
     * Sets subject_type
     *
     * @param string|null $subject_type The level at which the comment is targeted.
     *
     * @return self
     */
    public function setSubjectType($subject_type)
    {
        if (is_null($subject_type)) {
            throw new \InvalidArgumentException('non-nullable subject_type cannot be null');
        }
        $allowedValues = $this->getSubjectTypeAllowableValues();
        if (!in_array($subject_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'subject_type', must be one of '%s'",
                    $subject_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['subject_type'] = $subject_type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


